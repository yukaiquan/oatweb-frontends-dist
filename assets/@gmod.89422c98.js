import{b as $}from"./buffer.66f81d03.js";import{_ as De}from"./abortable-promise-cache.7cb58d6d.js";import{q as Rn}from"./quick-lru.2e8f10dc.js";import{p as $t}from"./pako.ae457f40.js";import{b as Is}from"./buffer-crc32.64f36e84.js";import{h as on}from"./@jkbonfield.580cc4c5.js";import{m as qo}from"./md5.e4ed9555.js";import{l as Uo,L as Ct}from"./long.81b4bfdc.js";import{f as _r}from"./cross-fetch.5e5fd403.js";import{R as Tt}from"./generic-filehandle.a92b52fd.js";import{o as Ho}from"./object.entries-ponyfill.1bb02ccd.js";import{P as K}from"./binary-parser.62cc4542.js";import{O as As,r as Fs,m as Vo,a as Zo}from"./rxjs.bbb58625.js";import{c as Ie}from"./@babel.d3038ccc.js";import{s as Ts}from"./stream-browserify.c9806a5a.js";import{S as Go}from"./string_decoder.54c7d31f.js";function jo(n,e){for(var t=0;t<e.length;t++){const r=e[t];if(typeof r!="string"&&!Array.isArray(r)){for(const i in r)if(i!=="default"&&!(i in n)){const s=Object.getOwnPropertyDescriptor(r,i);s&&Object.defineProperty(n,i,s.get?s:{enumerable:!0,get:()=>r[i]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}const X={},Dd=Object.freeze(Object.defineProperty({__proto__:null,default:X},Symbol.toStringTag,{value:"Module"})),cn={InfoFields:{AA:{Number:1,Type:"String",Description:"Ancestral allele"},AC:{Number:"A",Type:"Integer",Description:"Allele count in genotypes, for each ALT allele, in the same order as listed"},AD:{Number:"R",Type:"Integer",Description:"Total read depth for each allele"},ADF:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the forward strand"},ADR:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the reverse strand"},AF:{Number:"A",Type:"Float",Description:"Allele frequency for each ALT allele in the same order as listed (estimated from primary data, not called genotypes)"},AN:{Number:1,Type:"Integer",Description:"Total number of alleles in called genotypes"},BQ:{Number:1,Type:"Float",Description:"RMS base quality"},CIGAR:{Number:1,Type:"Float",Description:"Cigar string describing how to align an alternate allele to the reference allele"},DB:{Number:0,Type:"Flag",Description:"dbSNP membership"},DP:{Number:1,Type:"Integer",Description:"combined depth across samples"},END:{Number:1,Type:"Integer",Description:"End position (for use with symbolic alleles)"},H2:{Number:0,Type:"Flag",Description:"HapMap2 membership"},H3:{Number:0,Type:"Flag",Description:"HapMap3 membership"},MQ:{Number:1,Type:null,Description:"RMS mapping quality"},MQ0:{Number:1,Type:"Integer",Description:"Number of MAPQ == 0 reads"},NS:{Number:1,Type:"Integer",Description:"Number of samples with data"},SB:{Number:4,Type:"Integer",Description:"Strand bias"},SOMATIC:{Number:0,Type:"Flag",Description:"Somatic mutation (for cancer genomics)"},VALIDATED:{Number:0,Type:"Flag",Description:"Validated by follow-up experiment"},"1000G":{Number:0,Type:"Flag",Description:"1000 Genomes membership"},IMPRECISE:{Number:0,Type:"Flag",Description:"Imprecise structural variation"},NOVEL:{Number:0,Type:"Flag",Description:"Indicates a novel structural variation"},SVTYPE:{Number:1,Type:"String",Description:"Type of structural variant"},SVLEN:{Number:null,Type:"Integer",Description:"Difference in length between REF and ALT alleles"},CIPOS:{Number:2,Type:"Integer",Description:"Confidence interval around POS for imprecise variants"},CIEND:{Number:2,Type:"Integer",Description:"Confidence interval around END for imprecise variants"},HOMLEN:{Type:"Integer",Description:"Length of base pair identical micro-homology at event breakpoints"},HOMSEQ:{Type:"String",Description:"Sequence of base pair identical micro-homology at event breakpoints"},BKPTID:{Type:"String",Description:"ID of the assembled alternate allele in the assembly file"},MEINFO:{Number:4,Type:"String",Description:"Mobile element info of the form NAME,START,END,POLARITY"},METRANS:{Number:4,Type:"String",Description:"Mobile element transduction info of the form CHR,START,END,POLARITY"},DGVID:{Number:1,Type:"String",Description:"ID of this element in Database of Genomic Variation"},DBVARID:{Number:1,Type:"String",Description:"ID of this element in DBVAR"},DBRIPID:{Number:1,Type:"String",Description:"ID of this element in DBRIP"},MATEID:{Number:null,Type:"String",Description:"ID of mate breakends"},PARID:{Number:1,Type:"String",Description:"ID of partner breakend"},EVENT:{Number:1,Type:"String",Description:"ID of event associated to breakend"},CILEN:{Number:2,Type:"Integer",Description:"Confidence interval around the inserted material between breakend"},DPADJ:{Type:"Integer",Description:"Read Depth of adjacency"},CN:{Number:1,Type:"Integer",Description:"Copy number of segment containing breakend"},CNADJ:{Number:null,Type:"Integer",Description:"Copy number of adjacency"},CICN:{Number:2,Type:"Integer",Description:"Confidence interval around copy number for the segment"},CICNADJ:{Number:null,Type:"Integer",Description:"Confidence interval around copy number for the adjacency"}},GenotypeFields:{AD:{Number:"R",Type:"Integer",Description:"Read depth for each allele"},ADF:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the forward strand"},ADR:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the reverse strand"},DP:{Number:1,Type:"Integer",Description:"Read depth"},EC:{Number:"A",Type:"Integer",Description:"Expected alternate allele counts"},FT:{Number:1,Type:"String",Description:'Filter indicating if this genotype was "called"'},GL:{Number:"G",Type:"Float",Description:"Genotype likelihoods"},GP:{Number:"G",Type:"Float",Description:"Genotype posterior probabilities"},GQ:{Number:1,Type:"Integer",Description:"Conditional genotype quality"},GT:{Number:1,Type:"String",Description:"Genotype"},HQ:{Number:2,Type:"Integer",Description:"Haplotype quality"},MQ:{Number:1,Type:"Integer",Description:"RMS mapping quality"},PL:{Number:"G",Type:"Integer",Description:"Phred-scaled genotype likelihoods rounded to the closest integer"},PQ:{Number:1,Type:"Integer",Description:"Phasing quality"},PS:{Number:1,Type:"Integer",Description:"Phase set"}},AltTypes:{DEL:{Description:"Deletion relative to the reference"},INS:{Description:"Insertion of novel sequence relative to the reference"},DUP:{Description:"Region of elevated copy number relative to the reference"},INV:{Description:"Inversion of reference sequence"},CNV:{Description:"Copy number variable region (may be both deletion and duplication)"},"DUP:TANDEM":{Description:"Tandem duplication"},"DEL:ME":{Description:"Deletion of mobile element relative to the reference"},"INS:ME":{Description:"Insertion of a mobile element relative to the reference"},NON_REF:{Description:"Represents any possible alternative allele at this location"},"*":{Description:"Represents any possible alternative allele at this location"}},FilterTypes:{PASS:{Description:"Passed all filters"}}};function Ko(n){Object.assign(this,n)}function Wo(n){try{return decodeURIComponent(n)}catch{return n}}class Md{constructor({header:e="",strict:t=!0}){if(!e||!e.length)throw new Error("empty header received");const r=e.split(/[\r\n]+/).filter(l=>l);if(!r.length)throw new Error("no non-empty header lines specified");this.strict=t,this.metadata=JSON.parse(JSON.stringify({INFO:cn.InfoFields,FORMAT:cn.GenotypeFields,ALT:cn.AltTypes,FILTER:cn.FilterTypes}));let i;if(r.forEach(l=>{if(l.startsWith("#"))l.startsWith("##")?this._parseMetadata(l):i=l;else throw new Error(`Bad line in header:
${l}`)}),!i)throw new Error("No format line found in header");const s=i.trim().split("	"),a=s.slice(0,8),o=["#CHROM","POS","ID","REF","ALT","QUAL","FILTER","INFO"];if(s.length<8)throw new Error(`VCF header missing columns:
${i}`);if(a.length!==o.length||!a.every((l,c)=>l===o[c]))throw new Error(`VCF column headers not correct:
${i}`);this.samples=s.slice(9)}_parseGenotypes(e,t){const r=t.split("	"),i={},s=e==null?void 0:e.split(":");return s&&this.samples.forEach((a,o)=>{i[a]={},s.forEach(l=>{i[a][l]=null}),r[o].split(":").filter(l=>l).forEach((l,c)=>{let f;if(l===""||l==="."||l===void 0)f=null;else{const g=l.split(",").map(h=>h==="."?null:h),d=this.getMetadata("FORMAT",s[c],"Type");d==="Integer"||d==="Float"?f=g.map(h=>h&&+h):f=g}i[a][s[c]]=f},{})}),i}_parseMetadata(e){const t=e.trim().match(/^##(.+?)=(.*)/);if(!t)throw new Error(`Line is not a valid metadata line: ${e}`);const[r,i]=t.slice(1,3);if(i.startsWith("<")){r in this.metadata||(this.metadata[r]={});const[s,a]=this._parseStructuredMetaVal(i);this.metadata[r][s]=a}else this.metadata[r]=i}_parseStructuredMetaVal(e){const t=this._parseKeyValue(e.replace(/^<|>$/g,""),","),r=t.ID;return delete t.ID,"Number"in t&&(Number.isNaN(Number(t.Number))||(t.Number=Number(t.Number))),[r,t]}getMetadata(...e){let t=this.metadata;for(let r=0;r<e.length;r+=1)if(t=t[e[r]],!t)return t;return t}_parseKeyValue(e,t=";"){const r={};let i="",s="",a=1;for(let o=0;o<e.length;o+=1)a===1?e[o]==="="?a=2:e[o]!==t?i+=e[o]:s===""&&(r[i]=null,i=""):a===2?e[o]===t?(r[i]=s,i="",s="",a=1):e[o]==='"'?a=3:s+=e[o]:a===3&&(e[o]!=='"'?s+=e[o]:a=2);return a===2||a===3?r[i]=s:a===1&&(r[i]=null),r}parseLine(e){if(e=e.trim(),!e.length)return;const t=this;let r=0;for(let I=0;r<e.length&&(e[r]==="	"&&(I+=1),I!==9);r+=1);const i=e.substr(0,r).split("	"),s=e.substr(r+1),[a,o,l,c,f,g,d]=i,h=a,p=+o,b=l==="."?null:l.split(";"),w=c,S=f==="."?null:f.split(","),E=g==="."?null:+g,v=d==="."?null:d.split(";");if(this.strict&&i[7]===void 0)throw new Error("no INFO field specified, must contain at least a '.' (turn off strict mode to allow)");const _=i[7]===void 0||i[7]==="."?{}:this._parseKeyValue(i[7]);Object.keys(_).forEach(I=>{let C;_[I]?C=_[I].split(",").map(N=>N==="."?null:N).map(N=>N&&Wo(N)):C=_[I];const T=this.getMetadata("INFO",I,"Type");T&&(T==="Integer"||T==="Float"?C=C.map(N=>N===null?null:Number(N)):T==="Flag"&&(_[I]?console.warn(`Info field ${I} is a Flag and should not have a value (got value ${_[I]})`):C=!0)),_[I]=C});const k=new Ko({CHROM:h,POS:p,ALT:S,INFO:_,REF:w,FILTER:v&&v.length===1&&v[0]==="PASS"?"PASS":v,ID:b,QUAL:E});return Object.defineProperty(k,"SAMPLES",{get(){const I=t._parseGenotypes(i[8],s);return Object.defineProperty(this,"SAMPLES",{value:I,configurable:!1}),I},configurable:!0}),k}}function $d(n){const e=n.split(/[[\]]/);if(e.length>1){const t=n.includes("[")?"right":"left";let r,i,s;for(let a=0;a<e.length;a+=1){const o=e[a];o&&(o.includes(":")?(s=o,r=i?"right":"left"):i=o)}if(!(s&&r&&i))throw new Error(`Invalid breakend: ${n}`);return{MatePosition:s,Join:r,Replacement:i,MateDirection:t}}}const Un=65536,Qo=10;function Yo(n,e){const t=new Set;return n.filter(r=>{const i=e(r);return t.has(i)?!1:t.add(i)})}class Od{constructor(e,t,r=20){this.ixFile=t,this.ixxFile=e,this.maxResults=r}async search(e,t){let r=[];const s=e.split(" ")[0].toLowerCase(),a=await this._getBuffer(s,t);if(!a)return[];let{seekPosEnd:o,buffer:l}=a,c=!1;for(;!c;){const f=l.toString(),d=f.slice(0,f.lastIndexOf(`
`)).split(`
`).filter(h=>!!h).filter(h=>{const p=h.split(" ")[0],b=p.startsWith(s);return p>s&&(c=!0),b}).map(h=>{const[p,...b]=h.split(" ");return b.map(w=>[p,w.split(",")[0]])}).flat();if(r.length+d.length<this.maxResults&&!c){const h=await this.ixFile.read($.Buffer.alloc(Un),0,Un,o,t);if(!h.bytesRead){r=r.concat(d);break}l=$.Buffer.concat([l,h.buffer]),o+=Un}else if(r.length+d.length>=this.maxResults||c){r=r.concat(d);break}}return Yo(r,f=>f[1]).slice(0,this.maxResults)}async getIndex(e){return(await this.ixxFile.readFile({encoding:"utf8",...e})).split(`
`).filter(r=>!!r).map(r=>{const i=r.length-Qo,s=r.slice(0,i),a=r.slice(i),o=Number.parseInt(a,16);return[s,o]})}async _getBuffer(e,t){let r=0,i=-1;(await this.getIndex(t)).forEach(([l,c])=>{l.slice(0,e.length)<=e&&(r=c,i=c+65536)});const a=i-r;return a<0?void 0:{...await this.ixFile.read($.Buffer.alloc(a),0,a,r,t),seekPosEnd:i}}}function Ns(n){return $.Buffer.from($t.inflate(n))}class yi extends Error{}class Xe extends Error{}class U extends yi{}class Kt extends U{}class Xo extends yi{}class Jo extends yi{}const G=12,Rt=1<<G,kn=1<<23;class Ls{constructor(){this.F=void 0,this.C=void 0}}class ec{constructor(){this.fc=new Array(256);for(let e=0;e<this.fc.length;e+=1)this.fc[e]=new Ls;this.R=null}}class tc{constructor(){this.start=void 0,this.freq=void 0}}function nc(n,e,t){if(!(e<=1<<16))throw new U("assertion failed: start <= 1<<16");if(!(t<=(1<<16)-e))throw new U("assertion failed: freq <= 1<<16");n.start=e,n.freq=t}function Bs(n,e,t,r){const i=(1<<r)-1;return t*(n>>r)+(n&i)-e}function ic(n,e,t){return Bs(n,e.start,e.freq,t)}function rc(n,e){return n&(1<<e)-1}function sc(n,e,t,r,i){const s=(1<<i)-1;if(n=r*(n>>i)+(n&s)-t,n<kn)do{const a=255&e.get();n=n<<8|a}while(n<kn);return n}function ac(n,e,t,r){return sc(n,e,t.start,t.freq,r)}function oc(n,e){if(n<kn)do n=n<<8|255&e.get();while(n<kn);return n}const D={FC:Ls,AriDecoder:ec,Symbol:tc,symbolInit:nc,advanceStep:Bs,advanceSymbolStep:ic,get:rc,advanceSymbol:ac,renormalize:oc};function Rs(n){if(!n)throw new U("assertion failed")}function cc(n,e,t){let r=0,i=0,s=n.get()&255;do e.fc[s]==null&&(e.fc[s]=new D.FC),e.fc[s].F=n.get()&255,e.fc[s].F>=128&&(e.fc[s].F&=-129,e.fc[s].F=(e.fc[s].F&127)<<8|n.get()&255),e.fc[s].C=i,D.symbolInit(t[s],e.fc[s].C,e.fc[s].F),e.R||(e.R=new Array(Rt)),e.R.fill(s,i,i+e.fc[s].F),i+=e.fc[s].F,r===0&&s+1===(255&n.getByteAt(n.position()))?(s=n.get()&255,r=n.get()&255):r!==0?(r-=1,s+=1):s=n.get()&255;while(s!==0);Rs(i<Rt)}function fc(n,e,t){let r=0,i=255&n.get();do{let s=0,a=0,o=255&n.get();e[i]==null&&(e[i]=new D.AriDecoder);do e[i].fc[o]==null&&(e[i].fc[o]=new D.FC),e[i].fc[o].F=255&n.get(),e[i].fc[o].F>=128&&(e[i].fc[o].F&=-129,e[i].fc[o].F=(e[i].fc[o].F&127)<<8|255&n.get()),e[i].fc[o].C=a,e[i].fc[o].F===0&&(e[i].fc[o].F=Rt),t[i][o]==null&&(t[i][o]=new D.RansDecSymbol),D.symbolInit(t[i][o],e[i].fc[o].C,e[i].fc[o].F),e[i].R==null&&(e[i].R=new Array(Rt)),e[i].R.fill(o,a,a+e[i].fc[o].F),a+=e[i].fc[o].F,Rs(a<=Rt),s===0&&o+1===(255&n.getByteAt(n.position()))?(o=255&n.get(),s=255&n.get()):s!==0?(s-=1,o+=1):o=255&n.get();while(o!==0);r===0&&i+1===(255&n.getByteAt(n.position()))?(i=255&n.get(),r=255&n.get()):r!==0?(r-=1,i+=1):i=255&n.get()}while(i!==0)}function lc(n,e,t,r){let i=n.getInt(),s=n.getInt(),a=n.getInt(),o=n.getInt();const l=r.remaining(),c=l&-4;for(let g=0;g<c;g+=4){const d=e.R[D.get(i,G)],h=e.R[D.get(s,G)],p=e.R[D.get(a,G)],b=e.R[D.get(o,G)];r.putAt(g,d),r.putAt(g+1,h),r.putAt(g+2,p),r.putAt(g+3,b),i=D.advanceSymbolStep(i,t[255&d],G),s=D.advanceSymbolStep(s,t[255&h],G),a=D.advanceSymbolStep(a,t[255&p],G),o=D.advanceSymbolStep(o,t[255&b],G),i=D.renormalize(i,n),s=D.renormalize(s,n),a=D.renormalize(a,n),o=D.renormalize(o,n)}r.setPosition(c);let f;switch(l&3){case 0:break;case 1:f=e.R[D.get(i,G)],D.advanceSymbol(i,n,t[255&f],G),r.put(f);break;case 2:f=e.R[D.get(i,G)],D.advanceSymbol(i,n,t[255&f],G),r.put(f),f=e.R[D.get(s,G)],D.advanceSymbol(s,n,t[255&f],G),r.put(f);break;case 3:f=e.R[D.get(i,G)],D.advanceSymbol(i,n,t[255&f],G),r.put(f),f=e.R[D.get(s,G)],D.advanceSymbol(s,n,t[255&f],G),r.put(f),f=e.R[D.get(a,G)],D.advanceSymbol(a,n,t[255&f],G),r.put(f);break;default:throw new U("invalid output size encountered during rANS decoding")}r.setPosition(0)}function hc(n,e,t,r){const i=e.remaining();let s=n.getInt(),a=n.getInt(),o=n.getInt(),l=n.getInt();const c=i>>2;let f=0,g=c,d=2*c,h=3*c,p=0,b=0,w=0,S=0;for(;f<c;f+=1,g+=1,d+=1,h+=1){const E=255&t[p].R[D.get(s,G)],v=255&t[b].R[D.get(a,G)],_=255&t[w].R[D.get(o,G)],k=255&t[S].R[D.get(l,G)];e.putAt(f,E),e.putAt(g,v),e.putAt(d,_),e.putAt(h,k),s=D.advanceSymbolStep(s,r[p][E],G),a=D.advanceSymbolStep(a,r[b][v],G),o=D.advanceSymbolStep(o,r[w][_],G),l=D.advanceSymbolStep(l,r[S][k],G),s=D.renormalize(s,n),a=D.renormalize(a,n),o=D.renormalize(o,n),l=D.renormalize(l,n),p=E,b=v,w=_,S=k}for(;h<i;h+=1){const E=255&t[S].R[D.get(l,G)];e.putAt(h,E),l=D.advanceSymbol(l,n,r[S][E],G),S=E}}const uc=4;function dc(n,e){const t=new D.AriDecoder,r=new Array(256);for(let i=0;i<r.length;i+=1)r[i]=new D.Symbol;return cc(n,t,r),lc(n,t,r,e),e}function gc(n,e){const t=new Array(256);for(let i=0;i<t.length;i+=1)t[i]=new D.AriDecoder;const r=new Array(256);for(let i=0;i<r.length;i+=1){r[i]=new Array(256);for(let s=0;s<r[i].length;s+=1)r[i][s]=new D.Symbol}return fc(n,t,r),hc(n,e,t,r),e}class br{constructor(e,t=0){this._buffer=e,this._position=t,this.length=e.length}get(){const e=this._buffer[this._position];return this._position+=1,e}getByte(){return this.get()}getByteAt(e){return this._buffer[e]}position(){return this._position}put(e){return this._buffer[this._position]=e,this._position+=1,e}putAt(e,t){return this._buffer[e]=t,t}setPosition(e){return this._position=e,e}getInt(){const e=this._buffer.readInt32LE(this._position);return this._position+=4,e}remaining(){return this._buffer.length-this._position}}function pc(n,e,t=0){if(n.length===0)return e.fill(0),e;const r=new br(n,t),i=r.get();if(i!==0&&i!==1)throw new U(`Invalid rANS order ${i}`);if(r.getInt()!==r.remaining()-uc)throw new U("Incorrect input length.");const a=r.getInt(),o=new br(e||$.Buffer.allocUnsafe(a));if(o.length<a)throw new U(`Output buffer too small to fit ${a} bytes.`);switch(i){case 0:return dc(r,o);case 1:return gc(r,o);default:throw new U(`Invalid rANS order: ${i}`)}}var zs={};function mc(n){return new Function("code","return eval(code);").call(globalThis,n)}zs.runInThisContext=mc;var Ps={};function bn(n){return typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?bn=function(t){return typeof t}:bn=function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},bn(n)}var se=function(){this.code="",this.scopes=[["vars"]],this.isAsync=!1,this.bitFields=[],this.tmpVariableCount=0,this.references={}};se.prototype.generateVariable=function(n){var e=[];for(Array.prototype.push.apply(e,this.scopes[this.scopes.length-1]);/^\$parent\./.test(n);)e.pop(),n=n.replace(/^\$parent\./,"");return n&&e.push(n),e.join(".")};se.prototype.generateOption=function(n){switch(bn(n)){case"number":return n.toString();case"string":return this.generateVariable(n);case"function":return"(".concat(n,").call(").concat(this.generateVariable(),", vars)");default:return}};se.prototype.generateError=function(){var n=Array.prototype.slice.call(arguments),e=se.interpolate.apply(this,n);this.isAsync?this.pushCode("return process.nextTick(function() { callback(new Error(".concat(e,"), vars); });")):this.pushCode("throw new Error(".concat(e,");"))};se.prototype.generateTmpVariable=function(){return"$tmp".concat(this.tmpVariableCount++)};se.prototype.pushCode=function(){var n=Array.prototype.slice.call(arguments);this.code+="".concat(se.interpolate.apply(this,n),`
`)};se.prototype.pushPath=function(n){n&&this.scopes[this.scopes.length-1].push(n)};se.prototype.popPath=function(n){n&&this.scopes[this.scopes.length-1].pop()};se.prototype.pushScope=function(n){this.scopes.push([n])};se.prototype.popScope=function(){this.scopes.pop()};se.prototype.addReference=function(n){this.references[n]||(this.references[n]={resolved:!1,requested:!1})};se.prototype.markResolved=function(n){this.references[n].resolved=!0};se.prototype.markRequested=function(n){n.forEach(function(e){this.references[e].requested=!0}.bind(this))};se.prototype.getUnresolvedReferences=function(){var n=this.references;return Object.keys(this.references).filter(function(e){return!n[e].resolved&&!n[e].requested})};se.interpolate=function(n){var e=/{\d+}/g,t=n.match(e),r=Array.prototype.slice.call(arguments,1);return t&&t.forEach(function(i){var s=parseInt(i.substr(1,i.length-2),10);n=n.replace(i,r[s].toString())}),n};Ps.Context=se;function mt(n){return typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?mt=function(t){return typeof t}:mt=function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},mt(n)}var _c=$,Ds=_c.Buffer,bc=zs,wc=Ps.Context,yc=Uo;typeof window<"u"&&(window.Buffer=Ds);typeof self<"u"&&(self.Buffer=Ds);var ye={UInt8:1,UInt16LE:2,UInt16BE:2,UInt32LE:4,UInt32BE:4,Int8:1,Int16LE:2,Int16BE:2,Int32LE:4,Int32BE:4,FloatLE:4,FloatBE:4,DoubleLE:8,DoubleBE:8,UInt64:8,Int64:8},Sc={String:null,Buffer:null,Array:null,Skip:null,Choice:null,Nest:null,Bit:null,Itf8:null,Ltf8:null},et={},Wt="___parser_",Ms=[];(function(){var n;for(n=1;n<=32;n++)Ms.push(n)})();var Pe={};Object.keys(ye).concat(Object.keys(Sc)).forEach(function(n){Pe[n.toLowerCase()]=n});var R=function(){this.varName="",this.type="",this.options={},this.next=null,this.head=null,this.compiled=null,this.endian="le",this.constructorFn=null,this.alias=null};R.start=function(){return new R};Object.keys(ye).forEach(function(n){R.prototype[n.toLowerCase()]=function(t,r){return this.setNextParser(n.toLowerCase(),t,r)};var e=n.replace(/BE|LE/,"").toLowerCase();e in R.prototype||(R.prototype[e]=function(t,r){return this[e+this.endian](t,r)})});Ms.forEach(function(n){R.prototype["bit".concat(n.toString())]=function(e,t){return t||(t={}),t.length=n,this.setNextParser("bit",e,t)}});R.prototype.namely=function(n){return et[n]=this,this.alias=n,this};R.prototype.skip=function(n,e){if(e&&e.assert)throw new Error("assert option on skip is not allowed.");return this.setNextParser("skip","",{length:n})};R.prototype.string=function(n,e){if(!e.zeroTerminated&&!e.length&&!e.greedy)throw new Error("Neither length, zeroTerminated, nor greedy is defined for string.");if((e.zeroTerminated||e.length)&&e.greedy)throw new Error("greedy is mutually exclusive with length and zeroTerminated for string.");if(e.stripNull&&!(e.length||e.greedy))throw new Error("Length or greedy must be defined if stripNull is defined.");return e.encoding=e.encoding||"utf8",this.setNextParser("string",n,e)};R.prototype.buffer=function(n,e){if(!e.length&&!e.readUntil)throw new Error("Length nor readUntil is defined in buffer parser");return this.setNextParser("buffer",n,e)};R.prototype.array=function(n,e){if(!e.readUntil&&!e.length&&!e.lengthInBytes)throw new Error("Length option of array is not defined.");if(!e.type)throw new Error("Type option of array is not defined.");if(typeof e.type=="string"&&!et[e.type]&&Object.keys(ye).indexOf(Pe[e.type])<0)throw new Error('Specified primitive type "'.concat(e.type,'" is not supported.'));return this.setNextParser("array",n,e)};R.prototype.choice=function(n,e){if(arguments.length===1&&mt(n)==="object"&&(e=n,n=null),!e.tag)throw new Error("Tag option of array is not defined.");if(!e.choices)throw new Error("Choices option of array is not defined.");return Object.keys(e.choices).forEach(function(t){if(!e.choices[t])throw new Error("Choice Case ".concat(t," of ").concat(n," is not valid."));if(typeof e.choices[t]=="string"&&!et[e.choices[t]]&&Object.keys(ye).indexOf(Pe[e.choices[t]])<0)throw new Error('Specified primitive type "'.concat(e.choices[t],'" is not supported.'))},this),this.setNextParser("choice",n,e)};R.prototype.nest=function(n,e){if(arguments.length===1&&mt(n)==="object"&&(e=n,n=null),!e.type)throw new Error("Type option of nest is not defined.");if(!(e.type instanceof R)&&!et[e.type])throw new Error("Type option of nest must be a Parser object.");if(!(e.type instanceof R)&&!n)throw new Error("options.type must be a object if variable name is omitted.");return this.setNextParser("nest",n,e)};R.prototype.endianess=function(n){switch(n.toLowerCase()){case"little":this.endian="le";break;case"big":this.endian="be";break;default:throw new Error("Invalid endianess: ".concat(n))}return this};R.prototype.create=function(n){if(!(n instanceof Function))throw new Error("Constructor must be a Function object.");return this.constructorFn=n,this};R.prototype.getCode=function(){var n=new wc;return n.pushCode("if (!Buffer.isBuffer(buffer)) {"),n.generateError('"argument buffer is not a Buffer object"'),n.pushCode("}"),this.alias?this.addAliasedCode(n):this.addRawCode(n),this.alias?n.pushCode("return {0}(0)",Wt+this.alias):n.pushCode("return { offset: offset, result: vars };"),n.code};R.prototype.addRawCode=function(n){n.pushCode("var offset = 0;"),this.constructorFn?n.pushCode("var vars = new constructorFn();"):n.pushCode("var vars = {};"),this.generate(n),this.resolveReferences(n),n.pushCode("return { offset: offset, result: vars };")};R.prototype.addAliasedCode=function(n){return n.pushCode("function {0}(offset) {",Wt+this.alias),this.constructorFn?n.pushCode("var vars = new constructorFn();"):n.pushCode("var vars = {};"),this.generate(n),n.markResolved(this.alias),this.resolveReferences(n),n.pushCode("return { offset: offset, result: vars };"),n.pushCode("}"),n};R.prototype.resolveReferences=function(n){var e=n.getUnresolvedReferences();n.markRequested(e),e.forEach(function(t){var r=et[t];r.addAliasedCode(n)})};R.prototype.compile=function(){var n="(function(buffer, constructorFn, Long) { ".concat(this.getCode()," })");this.compiled=bc.runInThisContext(n)};R.prototype.sizeOf=function(){var n=NaN;if(Object.keys(ye).indexOf(this.type)>=0)n=ye[this.type];else if(this.type==="String"&&typeof this.options.length=="number")n=this.options.length;else if(this.type==="Buffer"&&typeof this.options.length=="number")n=this.options.length;else if(this.type==="Array"&&typeof this.options.length=="number"){var e=NaN;typeof this.options.type=="string"?e=ye[Pe[this.options.type]]:this.options.type instanceof R&&(e=this.options.type.sizeOf()),n=this.options.length*e}else this.type==="Skip"?n=this.options.length:this.type==="Nest"?n=this.options.type.sizeOf():this.type||(n=0);return this.next&&(n+=this.next.sizeOf()),n};R.prototype.parse=function(n){return this.compiled||this.compile(),this.compiled(n,this.constructorFn,yc)};R.prototype.setNextParser=function(n,e,t){var r=new R;return r.type=Pe[n],r.varName=e,r.options=t||r.options,r.endian=this.endian,this.head?this.head.next=r:this.next=r,this.head=r,this};R.prototype.generate=function(n){this.type&&(this["generate".concat(this.type)](n),this.generateAssert(n));var e=n.generateVariable(this.varName);return this.options.formatter&&this.generateFormatter(n,e,this.options.formatter),this.generateNext(n)};R.prototype.generateAssert=function(n){if(!!this.options.assert){var e=n.generateVariable(this.varName);switch(mt(this.options.assert)){case"function":n.pushCode("if (!({0}).call(vars, {1})) {",this.options.assert,e);break;case"number":n.pushCode("if ({0} !== {1}) {",this.options.assert,e);break;case"string":n.pushCode('if ("{0}" !== {1}) {',this.options.assert,e);break;default:throw new Error("Assert option supports only strings, numbers and assert functions.")}n.generateError('"Assert error: {0} is " + {0}',e),n.pushCode("}")}};R.prototype.generateNext=function(n){return this.next&&(n=this.next.generate(n)),n};Object.keys(ye).forEach(function(n){R.prototype["generate".concat(n)]=function(e){n==="UInt64"?e.pushCode("{0} = Long.fromBytes(buffer.slice(offset,offset+8), true, this.endian === 'le').toNumber();",e.generateVariable(this.varName),n):n==="Int64"?e.pushCode("{0} = Long.fromBytes(buffer.slice(offset,offset+8), false, this.endian === 'le').toNumber();",e.generateVariable(this.varName),n):e.pushCode("{0} = buffer.read{1}(offset);",e.generateVariable(this.varName),n),e.pushCode("offset += {0};",ye[n])}});R.prototype.generateBit=function(n){var e=JSON.parse(JSON.stringify(this));if(e.varName=n.generateVariable(e.varName),n.bitFields.push(e),!this.next||this.next&&["Bit","Nest"].indexOf(this.next.type)<0){var t=0;n.bitFields.forEach(function(l){t+=l.options.length});var r=n.generateTmpVariable();if(t<=8)n.pushCode("var {0} = buffer.readUInt8(offset);",r),t=8;else if(t<=16)n.pushCode("var {0} = buffer.readUInt16BE(offset);",r),t=16;else if(t<=24){var i=n.generateTmpVariable(),s=n.generateTmpVariable();n.pushCode("var {0} = buffer.readUInt16BE(offset);",i),n.pushCode("var {0} = buffer.readUInt8(offset + 2);",s),n.pushCode("var {2} = ({0} << 8) | {1};",i,s,r),t=24}else if(t<=32)n.pushCode("var {0} = buffer.readUInt32BE(offset);",r),t=32;else throw new Error("Currently, bit field sequence longer than 4-bytes is not supported.");n.pushCode("offset += {0};",t/8);var a=0,o=this.endian==="be";n.bitFields.forEach(function(l){n.pushCode("{0} = {1} >> {2} & {3};",l.varName,r,o?t-a-l.options.length:a,(1<<l.options.length)-1),a+=l.options.length}),n.bitFields=[]}};R.prototype.generateSkip=function(n){var e=n.generateOption(this.options.length);n.pushCode("offset += {0};",e)};R.prototype.generateString=function(n){var e=n.generateVariable(this.varName),t=n.generateTmpVariable();this.options.length&&this.options.zeroTerminated?(n.pushCode("var {0} = offset;",t),n.pushCode("while(buffer.readUInt8(offset++) !== 0 && offset - {0}  < {1});",t,this.options.length),n.pushCode("{0} = buffer.toString('{1}', {2}, offset - {2} < {3} ? offset - 1 : offset);",e,this.options.encoding,t,this.options.length)):this.options.length?(n.pushCode("{0} = buffer.toString('{1}', offset, offset + {2});",e,this.options.encoding,n.generateOption(this.options.length)),n.pushCode("offset += {0};",n.generateOption(this.options.length))):this.options.zeroTerminated?(n.pushCode("var {0} = offset;",t),n.pushCode("while(buffer.readUInt8(offset++) !== 0);"),n.pushCode("{0} = buffer.toString('{1}', {2}, offset - 1);",e,this.options.encoding,t)):this.options.greedy&&(n.pushCode("var {0} = offset;",t),n.pushCode("while(buffer.length > offset++);"),n.pushCode("{0} = buffer.toString('{1}', {2}, offset);",e,this.options.encoding,t)),this.options.stripNull&&n.pushCode("{0} = {0}.replace(/\\x00+$/g, '')",e)};R.prototype.generateBuffer=function(n){this.options.readUntil==="eof"?n.pushCode("{0} = buffer.slice(offset);",n.generateVariable(this.varName)):(n.pushCode("{0} = buffer.slice(offset, offset + {1});",n.generateVariable(this.varName),n.generateOption(this.options.length)),n.pushCode("offset += {0};",n.generateOption(this.options.length))),this.options.clone&&n.pushCode("{0} = Buffer.from({0});",n.generateVariable(this.varName))};R.prototype.generateArray=function(n){var e=n.generateOption(this.options.length),t=n.generateOption(this.options.lengthInBytes),r=this.options.type,i=n.generateTmpVariable(),s=n.generateVariable(this.varName),a=n.generateTmpVariable(),o=this.options.key,l=typeof o=="string";if(l?n.pushCode("{0} = {};",s):n.pushCode("{0} = [];",s),typeof this.options.readUntil=="function"?n.pushCode("do {"):this.options.readUntil==="eof"?n.pushCode("for (var {0} = 0; offset < buffer.length; {0}++) {",i):t!==void 0?n.pushCode("for (var {0} = offset; offset - {0} < {1}; ) {",i,t):n.pushCode("for (var {0} = 0; {0} < {1}; {0}++) {",i,e),typeof r=="string")if(!et[r])n.pushCode("var {0} = buffer.read{1}(offset);",a,Pe[r]),n.pushCode("offset += {0};",ye[Pe[r]]);else{var c=n.generateTmpVariable();n.pushCode("var {0} = {1}(offset);",c,Wt+r),n.pushCode("var {0} = {1}.result; offset = {1}.offset;",a,c),r!==this.alias&&n.addReference(r)}else r instanceof R&&(n.pushCode("var {0} = {};",a),n.pushScope(a),r.generate(n),n.popScope());l?n.pushCode("{0}[{2}.{1}] = {2};",s,o,a):n.pushCode("{0}.push({1});",s,a),n.pushCode("}"),typeof this.options.readUntil=="function"&&n.pushCode(" while (!({0}).call(this, {1}, buffer.slice(offset)));",this.options.readUntil,a)};R.prototype.generateChoiceCase=function(n,e,t){if(typeof t=="string")if(!et[t])n.pushCode("{0} = buffer.read{1}(offset);",n.generateVariable(this.varName),Pe[t]),n.pushCode("offset += {0};",ye[Pe[t]]);else{var r=n.generateTmpVariable();n.pushCode("var {0} = {1}(offset);",r,Wt+t),n.pushCode("{0} = {1}.result; offset = {1}.offset;",n.generateVariable(this.varName),r),t!==this.alias&&n.addReference(t)}else t instanceof R&&(n.pushPath(e),t.generate(n),n.popPath(e))};R.prototype.generateChoice=function(n){var e=n.generateOption(this.options.tag);this.varName&&n.pushCode("{0} = {};",n.generateVariable(this.varName)),n.pushCode("switch({0}) {",e),Object.keys(this.options.choices).forEach(function(t){var r=this.options.choices[t];Number.isNaN(parseInt(t,10))?n.pushCode("case '{0}':",t):n.pushCode("case {0}:",t),this.generateChoiceCase(n,this.varName,r),n.pushCode("break;")},this),n.pushCode("default:"),this.options.defaultChoice?this.generateChoiceCase(n,this.varName,this.options.defaultChoice):n.generateError('"Met undefined tag value " + {0} + " at choice"',e),n.pushCode("}")};R.prototype.generateNest=function(n){var e=n.generateVariable(this.varName);if(this.options.type instanceof R)this.varName&&n.pushCode("{0} = {};",e),n.pushPath(this.varName),this.options.type.generate(n),n.popPath(this.varName);else if(et[this.options.type]){var t=n.generateTmpVariable();n.pushCode("var {0} = {1}(offset);",t,Wt+this.options.type),n.pushCode("{0} = {1}.result; offset = {1}.offset;",e,t),this.options.type!==this.alias&&n.addReference(this.options.type)}};R.prototype.generateFormatter=function(n,e,t){typeof t=="function"&&n.pushCode("{0} = ({1}).call(this, {0});",e,t)};R.prototype.isInteger=function(){return!!this.type.match(/U?Int[8|16|32][BE|LE]?|Bit\d+/)};R.prototype.itf8=function(n,e){return this.setNextParser("itf8",n,e)};R.prototype.itf8=function(n,e){return this.setNextParser("itf8",n,e)};R.prototype.generateItf8=function(n){var e=n.generateVariable(this.varName),t=n.generateTmpVariable();n.pushCode(`
    var `.concat(t,` = buffer[offset];
    if (`).concat(t,` < 0x80) {
      `).concat(e," = ").concat(t,`;
      offset += 1;
    } else if (`).concat(t,` < 0xc0) {
      `).concat(e," = ((").concat(t,`<<8) | buffer[offset+1]) & 0x3fff;
      offset += 2;
    } else if (`).concat(t,` < 0xe0) {
      `).concat(e," = ((").concat(t,`<<16) | (buffer[offset+1]<< 8) |  buffer[offset+2]) & 0x1fffff;
      offset += 3;
    } else if (`).concat(t,` < 0xf0) {
      `).concat(e," = ((").concat(t,`<<24) | (buffer[offset+1]<<16) | (buffer[offset+2]<<8) | buffer[offset+3]) & 0x0fffffff;
      offset += 4
    } else {
      `).concat(e," = ((").concat(t,` & 0x0f)<<28) | (buffer[offset+1]<<20) | (buffer[offset+2]<<12) | (buffer[offset+3]<<4) | (buffer[offset+4] & 0x0f);
      // x=((0xff & 0x0f)<<28) | (0xff<<20) | (0xff<<12) | (0xff<<4) | (0x0f & 0x0f);
      // TODO *val_p = uv < 0x80000000UL ? uv : -((int32_t) (0xffffffffUL - uv)) - 1;
      offset += 5
    }
  `))};R.prototype.ltf8=function(n,e){return this.setNextParser("ltf8",n,e)};R.prototype.generateLtf8=function(n){var e=n.generateVariable(this.varName),t=n.generateTmpVariable();n.pushCode(`
  var `.concat(t,` = buffer[offset];
  if (`).concat(t,` < 0x80) {
    `).concat(e," = ").concat(t,`;
    offset += 1;
  } else if (`).concat(t,` < 0xc0) {
    `).concat(e,` = ((buffer[offset]<<8) | buffer[offset+1]) & 0x3fff;
    offset += 2;
  } else if (`).concat(t,` < 0xe0) {
    `).concat(e,` = ((buffer[offset]<<16) | (buffer[offset+1]<<8) | buffer[offset+2]) & 0x1fffff;
    `).concat(e," = (((").concat(t,` & 63) << 16) | buffer.readUInt16LE(offset + 1));
    offset += 3;
  } else if (`).concat(t,` < 0xf0) {
    `).concat(e,` = ((buffer[offset]<<24) | (buffer[offset+1]<<16) | (buffer[offset+2]<<8) | buffer[offset+3]) & 0x0fffffff;
    offset += 4;
  } else if (`).concat(t,` < 0xf8) {
    `).concat(e,` = (((buffer[offset] & 15) * Math.pow(2,32))) +
      (buffer[offset+1]<<24) | (buffer[offset+2]<<16 | buffer[offset+3]<<8 | buffer[offset+4])
    // TODO *val_p = uv < 0x80000000UL ? uv : -((int32_t) (0xffffffffUL - uv)) - 1;
    offset += 5;
  } else if (`).concat(t,` < 0xfc) {
    `).concat(e,` = ((((buffer[offset] & 7) << 8) | buffer[offset+1] )) * Math.pow(2,32) +
      (buffer[offset+2]<<24) | (buffer[offset+3]<<16 | buffer[offset+4]<<8 | buffer[offset+5])
    offset += 6;
  } else if (`).concat(t,` < 0xfe) {
    `).concat(e,` = ((((buffer[offset] & 3) << 16) | buffer[offset+1]<<8 | buffer[offset+2])) * Math.pow(2,32) +
      (buffer[offset+3]<<24) | (buffer[offset+4]<<16 | buffer[offset+5]<<8 | buffer[offset+6])
    offset += 7;
  } else if (`).concat(t,` < 0xff) {
    `).concat(e,` = Long.fromBytesBE(buffer.slice(offset+1,offset+8));
    if (`).concat(e,".greaterThan(Number.MAX_SAFE_INTEGER) || ").concat(e,`.lessThan(Number.MIN_SAFE_INTEGER))
      throw new Error('integer overflow')
    `).concat(e," = ").concat(e,`.toNumber()
    offset += 8;
  } else {
    `).concat(e,` = Long.fromBytesBE(buffer.slice(offset+1,offset+9));
    if (`).concat(e,".greaterThan(Number.MAX_SAFE_INTEGER) || ").concat(e,`.lessThan(Number.MIN_SAFE_INTEGER))
      throw new Error('integer overflow')
    `).concat(e," = ").concat(e,`.toNumber()
    offset += 9;
  }
  `))};var O=R;const fn=new O().itf8(),wn={parser:new O().string("magic",{length:4}).uint8("majorVersion").uint8("minorVersion").string("fileId",{length:20,stripNull:!0}),maxLength:26},Ec={parser:new O().uint8("compressionMethod",{formatter:n=>{const e=["raw","gzip","bzip2","lzma","rans","rans4x16","arith","fqzcomp","tok3"][n];if(!e)throw new Error(`compression method number ${n} not implemented`);return e}}).uint8("contentType",{formatter:n=>{const e=["FILE_HEADER","COMPRESSION_HEADER","MAPPED_SLICE_HEADER","UNMAPPED_SLICE_HEADER","EXTERNAL_DATA","CORE_DATA"][n];if(!e)throw new Error(`invalid block content type id ${n}`);return e}}).itf8("contentId").itf8("compressedSize").itf8("uncompressedSize"),maxLength:17},Cc={parser:new O().uint32("crc32"),maxLength:4},xc=new O().itf8("size").buffer("ents",{length:"size",formatter:n=>{function e(s,a){const o=n.toString("utf8",s,a),l=[];for(let c=0;c<o.length;c+=3)l.push(o.substr(c,3));return l}var t=[],r=0,i;for(i=0;i<n.length;i+=1)n[i]||(t.push(e(r,i)),r=i+1);return i>r&&t.push(e(r,i)),t}}),ut=new O().uint8(null,{formatter:n=>!!n}),kc=new O().itf8("mapSize").itf8("mapCount").array("ents",{length:"mapCount",type:new O().string("key",{length:2,stripNull:!1}).choice("value",{tag:"key",choices:{MI:ut,UI:ut,PI:ut,RN:ut,AP:ut,RR:ut,SM:new O().array(null,{type:"uint8",length:5}),TD:new O().nest(null,{type:xc,formatter:n=>n.ents})}})});function Hn(n){const e={};for(let t=0;t<n.ents.length;t+=1){const{key:r,value:i}=n.ents[t];e[r]&&console.warn(`duplicate key ${r} in map`),e[r]=i}return e}const vc={cramFileDefinition:wn,cramBlockHeader:Ec,cramBlockCrc32:Cc},wr={cramUnmappedSliceHeader(n){let e=0,t=new O().itf8("numRecords");return e+=5,n>=3?(t=t.ltf8("recordCounter"),e+=9):n===2&&(t=t.itf8("recordCounter"),e+=5),t=t.itf8("numBlocks").itf8("numContentIds").array("contentIds",{type:fn,length:"numContentIds"}),e+=5*2,n>=2&&(t=t.array("md5",{type:"uint8",length:16}),e+=16),{parser:t,maxLength:i=>e+i*5}},cramMappedSliceHeader(n){let e=new O().itf8("refSeqId").itf8("refSeqStart").itf8("refSeqSpan").itf8("numRecords"),t=5*4;return n>=3?(e=e.ltf8("recordCounter"),t+=9):n===2&&(e=e.itf8("recordCounter"),t+=5),e=e.itf8("numBlocks").itf8("numContentIds").array("contentIds",{type:fn,length:"numContentIds"}).itf8("refBaseBlockId"),t+=5*3,n>=2&&(e=e.array("md5",{type:"uint8",length:16}),t+=16),{parser:e,maxLength:i=>t+i*5}},cramEncoding(n){return{parser:new O().namely("cramEncoding").itf8("codecId").itf8("parametersBytes").choice("parameters",{tag:"codecId",choices:{0:new O,1:new O().itf8("blockContentId"),2:new O().itf8("offset").itf8("M"),3:O.start().itf8("numCodes").array("symbols",{length:"numCodes",type:fn}).itf8("numLengths").array("bitLengths",{length:"numLengths",type:fn}),4:O.start().nest("lengthsEncoding",{type:"cramEncoding"}).nest("valuesEncoding",{type:"cramEncoding"}),5:new O().uint8("stopByte")[n>1?"itf8":"int"]("blockContentId"),6:new O().itf8("offset").itf8("length"),7:new O().itf8("offset").itf8("K"),8:new O().itf8("offset").itf8("log2m"),9:new O().itf8("offset")}})}},cramDataSeriesEncodingMap(n){return new O().itf8("mapSize").itf8("mapCount").array("ents",{length:"mapCount",type:new O().string("key",{length:2,stripNull:!1}).nest("value",{type:this.cramEncoding(n).parser})})},cramTagEncodingMap(n){return new O().itf8("mapSize").itf8("mapCount").array("ents",{length:"mapCount",type:new O().itf8("key",{formatter:e=>String.fromCharCode(e>>16&255)+String.fromCharCode(e>>8&255)+String.fromCharCode(e&255)}).nest("value",{type:this.cramEncoding(n).parser})})},cramCompressionHeader(n){let e=new O;return e=e.nest("preservation",{type:kc,formatter:Hn}).nest("dataSeriesEncoding",{type:this.cramDataSeriesEncodingMap(n),formatter:Hn}).nest("tagEncoding",{type:this.cramTagEncodingMap(n),formatter:Hn}),{parser:e}},cramContainerHeader1(n){let e=new O().int32("length").itf8("refSeqId").itf8("refSeqStart").itf8("alignmentSpan").itf8("numRecords"),t=4+5*4;return n>=3?(e=e.ltf8("recordCounter"),t+=9):n===2&&(e=e.itf8("recordCounter"),t+=5),n>1&&(e=e.ltf8("numBases"),t+=9),e=e.itf8("numBlocks").itf8("numLandmarks"),t+=5+5,{parser:e,maxLength:t}},cramContainerHeader2(n){let e=new O().itf8("numLandmarks").array("landmarks",{type:new O().itf8(),length:"numLandmarks"}),t=0;return n>=3&&(e=e.uint32("crc32"),t=4),{parser:e,maxLength:r=>5+r*5+t}}};function Ic(n){const e=Object.assign({},vc);return Object.keys(wr).forEach(t=>{e[t]=wr[t](n)}),e}function Ac(n){return n&-128?n&-16384?n&-2097152?n&-268435456?5:4:3:2:1}function Fc(n,e){let t=e;const r=n[t];let i;if(r<128?(i=r,t+=1):r<192?(i=(r<<8|n[t+1])&16383,t+=2):r<224?(i=(r<<16|n[t+1]<<8|n[t+2])&2097151,t+=3):r<240?(i=(r<<24|n[t+1]<<16|n[t+2]<<8|n[t+3])&268435455,t+=4):(i=(r&15)<<28|n[t+1]<<20|n[t+2]<<12|n[t+3]<<4|n[t+4]&15,t+=5),t>n.length)throw new Kt("Attempted to read beyond end of buffer; this file seems truncated.");return[i,t-e]}function rt(n,e,t=0,r=0){const{offset:i,result:s}=e.parse(n);return s._endPosition=i+r,s._size=i-t,s}function zn(n,e){const t=n.prototype[e],r=`_memo_${e}`;n.prototype[e]=function(){if(!(r in this)){const s=t.call(this);this[r]=s,Promise.resolve(s).catch(()=>{delete this[r]})}return this[r]}}function Tc(n){return qo.exports(n.toUpperCase().replace(/[^\x21-\x7e]/g,""))}const Nc={CRAM_FLAG_PRESERVE_QUAL_SCORES:1<<0,CRAM_FLAG_DETACHED:1<<1,CRAM_FLAG_MATE_DOWNSTREAM:1<<2,CRAM_FLAG_NO_SEQ:1<<3,CRAM_FLAG_MASK:(1<<4)-1,CRAM_M_REVERSE:1,CRAM_M_UNMAP:2,BAM_FPAIRED:1,BAM_FPROPER_PAIR:2,BAM_FUNMAP:4,BAM_FMUNMAP:8,BAM_FREVERSE:16,BAM_FMREVERSE:32,BAM_FREAD1:64,BAM_FREAD2:128,BAM_FSECONDARY:256,BAM_FQCFAIL:512,BAM_FDUP:1024,BAM_FSUPPLEMENTARY:2048,BAM_CMATCH:0,BAM_CINS:1,BAM_CDEL:2,BAM_CREF_SKIP:3,BAM_CSOFT_CLIP:4,BAM_CHARD_CLIP:5,BAM_CPAD:6,BAM_CEQUAL:7,BAM_CDIFF:8,BAM_CBACK:9,BAM_CIGAR_STR:"MIDNSHP:XB",BAM_CIGAR_SHIFT:4,BAM_CIGAR_MASK:15,BAM_CIGAR_TYPE:246183},j=Nc;function Lc(n,e){if(!n.lengthOnRef&&!n.readLength||n.isUnknownBases())return;const t=n.alignmentStart-e.start;if(!n.readFeatures)return e.seq.substr(t,n.lengthOnRef).toUpperCase();let r="",i=t,s=0;for(;r.length<n.readLength;)if(s<n.readFeatures.length){const a=n.readFeatures[s];if(a.code==="Q"||a.code==="q")s+=1;else if(a.pos===r.length+1)if(s+=1,a.code==="b"){const o=a.data.split(","),l=String.fromCharCode(...o);r+=l,i+=l.length}else a.code==="B"?(r+=a.data[0],i+=1):a.code==="X"?(r+=a.sub,i+=1):a.code==="I"?r+=a.data:a.code==="D"?i+=a.data:a.code==="i"?r+=a.data:a.code==="N"?i+=a.data:a.code==="S"?r+=a.data:a.code==="P"||a.code;else if(s<n.readFeatures.length){const o=e.seq.substr(i,n.readFeatures[s].pos-r.length-1);r+=o,i+=o.length}}else{const a=e.seq.substr(i,n.readLength-r.length);r+=a,i+=a.length}return r.toUpperCase()}const Bc={a:0,A:0,c:1,C:1,g:2,G:2,t:3,T:3,n:4,N:4};function Rc(n,e,t,r){if(!e)return;const i=r.refPos-e.start,s=e.seq.charAt(i);s&&(r.ref=s);let a=Bc[s];a===void 0&&(a=4);const l=t.substitutionMatrix[a][r.data];l&&(r.sub=l)}class zc{constructor(){this.tags={}}isPaired(){return!!(this.flags&j.BAM_FPAIRED)}isProperlyPaired(){return!!(this.flags&j.BAM_FPROPER_PAIR)}isSegmentUnmapped(){return!!(this.flags&j.BAM_FUNMAP)}isMateUnmapped(){return!!(this.flags&j.BAM_FMUNMAP)}isReverseComplemented(){return!!(this.flags&j.BAM_FREVERSE)}isMateReverseComplemented(){return!!(this.flags&j.BAM_FMREVERSE)}isRead1(){return!!(this.flags&j.BAM_FREAD1)}isRead2(){return!!(this.flags&j.BAM_FREAD2)}isSecondary(){return!!(this.flags&j.BAM_FSECONDARY)}isFailedQc(){return!!(this.flags&j.BAM_FQCFAIL)}isDuplicate(){return!!(this.flags&j.BAM_FDUP)}isSupplementary(){return!!(this.flags&j.BAM_FSUPPLEMENTARY)}isDetached(){return!!(this.cramFlags&j.CRAM_FLAG_DETACHED)}hasMateDownStream(){return!!(this.cramFlags&j.CRAM_FLAG_MATE_DOWNSTREAM)}isPreservingQualityScores(){return!!(this.cramFlags&j.CRAM_FLAG_PRESERVE_QUAL_SCORES)}isUnknownBases(){return!!(this.cramFlags&j.CRAM_FLAG_NO_SEQ)}getReadBases(){return!this.readBases&&this._refRegion&&(this.readBases=Lc(this,this._refRegion)),this.readBases}getPairOrientation(){if(!this.isSegmentUnmapped()&&this.isPaired()&&!this.isMateUnmapped()&&this.mate&&this.sequenceId===this.mate.sequenceId){const e=this.isReverseComplemented()?"R":"F",t=this.isMateReverseComplemented()?"R":"F";let r=" ",i=" ";this.isRead1()?(r="1",i="2"):this.isRead2()&&(r="2",i="1");const s=[];let a=this.templateLength||this.templateSize;return this.alignmentStart>this.mate.alignmentStart&&a>0&&(a=-a),a>0?(s[0]=e,s[1]=r,s[2]=t,s[3]=i):(s[2]=e,s[3]=r,s[0]=t,s[1]=i),s.join("")}return null}addReferenceSequence(e,t){this.readFeatures&&this.readFeatures.forEach(r=>{r.code==="X"&&Rc(this,e,t,r)}),!this.readBases&&e.start<=this.alignmentStart&&e.end>=this.alignmentStart+(this.lengthOnRef||this.readLength)-1&&(this._refRegion=e)}toJSON(){const e={};return Object.keys(this).forEach(t=>{t.charAt(0)!=="_"&&(e[t]=this[t])}),e.readBases=this.getReadBases(),e}}function vn(n){let e="";for(let t=0;t<n.length&&n[t]!==0;t++)e+=String.fromCharCode(n[t]);return e}function Pc(n){const e=String.fromCharCode(n[0]),t=Int32Array.from(n.slice(1))[0],r=new Array(t);if(n=n.slice(5),e==="c"){const i=new Int8Array(n.buffer);for(let s=0;s<t;s+=1)r[s]=i[s]}else if(e==="C"){const i=new Uint8Array(n.buffer);for(let s=0;s<t;s+=1)r[s]=i[s]}else if(e==="s"){const i=new Int16Array(n.buffer);for(let s=0;s<t;s+=1)r[s]=i[s]}else if(e==="S"){const i=new Uint16Array(n.buffer);for(let s=0;s<t;s+=1)r[s]=i[s]}else if(e==="i"){const i=new Int32Array(n.buffer);for(let s=0;s<t;s+=1)r[s]=i[s]}else if(e==="I"){const i=new Uint32Array(n.buffer);for(let s=0;s<t;s+=1)r[s]=i[s]}else if(e==="f"){const i=new Float32Array(n.buffer);for(let s=0;s<t;s+=1)r[s]=i[s]}else throw new Error("unknown type: "+e);return r}function Dc(n,e){if(n==="Z")return vn(e);if(n==="A")return String.fromCharCode(e[0]);if(n==="I")return Ct.fromBytesLE(e).toNumber();if(n==="i")return new Int32Array(e.buffer)[0];if(n==="s")return new Int16Array(e.buffer)[0];if(n==="S")return new Uint16Array(e.buffer)[0];if(n==="c")return new Int8Array(e.buffer)[0];if(n==="C")return e[0];if(n==="f")return new Float32Array(e.buffer)[0];if(n==="H")return Number.parseInt(vn(e).replace(/^0x/,""),16);if(n==="B")return Pc(e);throw new U(`Unrecognized tag type ${n}`)}function Mc(n,e,t,r,i){let s=0,a=n.alignmentStart-1;const o=new Array(e);function l([c,f]){const g=t(f);return c==="character"?String.fromCharCode(g):c==="string"?g.toString("utf8"):c==="numArray"?g.toArray():g}for(let c=0;c<e;c+=1){const f=String.fromCharCode(t("FC")),g=t("FP"),d={code:f},h={B:["character","BA"],S:["string",i>1?"SC":"IN"],X:["number","BS"],D:["number","DL"],I:["string","IN"],i:["character","BA"],b:["string","BB"],q:["numArray","QQ"],Q:["number","QS"],H:["number","HC"],P:["number","PD"],N:["number","RS"]}[f];if(!h)throw new U(`invalid read feature code "${f}"`);d.data=l(h);const p={B:["number","QS"]}[f];p&&(d.data=[d.data,l(p)]),s+=g,d.pos=s,a+=g,d.refPos=a,f==="D"||f==="N"?a+=d.data:f==="I"||f==="S"?a-=d.data.length:f==="i"&&(a-=1),o[c]=d}return o}function $c(n,e,t,r,i,s,a,o,l){const c=new zc;if(c.flags=e("BF"),c.cramFlags=e("CF"),o>1&&r.content.refSeqId===-2?c.sequenceId=e("RI"):c.sequenceId=r.content.refSeqId,c.readLength=e("RL"),c.alignmentStart=e("AP"),t.APdelta&&(c.alignmentStart+=a.lastAlignmentStart),a.lastAlignmentStart=c.alignmentStart,c.readGroupId=e("RG"),t.readNamesIncluded&&(c.readName=vn(e("RN"))),c.isDetached()){const h={};h.flags=e("MF"),t.readNamesIncluded||(h.readName=vn(e("RN")),c.readName=h.readName),h.sequenceId=e("NS"),h.alignmentStart=e("NP"),(h.flags||h.sequenceId>-1)&&(c.mate=h),c.templateSize=e("TS"),h.flags&j.CRAM_M_UNMAP&&(c.flags|=j.BAM_FMUNMAP),h.flags&j.CRAM_M_REVERSE&&(c.flags|=j.BAM_FMREVERSE)}else c.hasMateDownStream()&&(c.mateRecordNumber=e("NF")+l+1);const f=e("TL");if(f<0)throw new U("invalid TL index");const g=t.getTagNames(f),d=g.length;for(let h=0;h<d;h+=1){const p=g[h],b=p.substr(0,2),w=p.substr(2,1),S=t.getCodecForTag(p);if(!S)throw new U(`no codec defined for auxiliary tag ${p}`);const E=S.decode(n,i,s,a);c.tags[b]=Dc(w,E)}if(c.isSegmentUnmapped())if(c.isUnknownBases())c.readBases=null,c.qualityScores=null;else{const h=new Array(c.readLength);for(let p=0;p<h.length;p+=1)h[p]=e("BA");if(c.readBases=String.fromCharCode(...h),c.isPreservingQualityScores()){for(let p=0;p<h.length;p+=1)h[p]=e("QS");c.qualityScores=h}}else{const h=e("FN");h&&(c.readFeatures=Mc(c,h,e,t,o));let p=c.readLength;if(c.readFeatures&&c.readFeatures.forEach(({code:b,data:w})=>{b==="D"||b==="N"?p+=w:b==="I"||b==="S"?p-=w.length:b==="i"&&(p-=1)}),Number.isNaN(p)&&(console.warn(`${c.readName||`${c.sequenceId}:${c.alignmentStart}`} record has invalid read features`),p=c.readLength),c.lengthOnRef=p,c.mappingQuality=e("MQ"),c.isPreservingQualityScores()){const b=new Array(c.readLength);for(let w=0;w<b.length;w+=1)b[w]=e("QS");c.qualityScores=b}}return c}function Oc(n,e,t){function r(l){const c=[l];if(l.mateRecordNumber>=0){const f=n[l.mateRecordNumber];if(!f)throw new U("intra-slice mate record not found, this file seems malformed");c.push(...r(f))}return c}const i=r(t),s=i.map(l=>l.alignmentStart),a=i.map(l=>l.alignmentStart+l.readLength-1),o=Math.max(...a)-Math.min(...s)+1;o>=0&&i.forEach(l=>{if(l.templateLength!==void 0)throw new U("mate pair group has some members that have template lengths already, this file seems malformed");l.templateLength=o})}function qc(n,e){const t=Math.min(n.alignmentStart,e.alignmentStart),i=Math.max(n.alignmentStart+n.readLength-1,e.alignmentStart+e.readLength-1)-t+1;n.templateLength=i,e.templateLength=i}function Uc(n,e,t,r){if(!r)throw new U("could not resolve intra-slice mate pairs, file seems truncated or malformed");const i=!!(r.mate||r.mateRecordNumber!==void 0&&r.mateRecordNumber!==e);t.readName||(t.readName=String(t.uniqueId),r.readName=t.readName),t.mate={sequenceId:r.sequenceId,alignmentStart:r.alignmentStart,uniqueId:r.uniqueId},r.readName&&(t.mate.readName=r.readName),!r.mate&&r.mateRecordNumber===void 0&&(r.mate={sequenceId:t.sequenceId,alignmentStart:t.alignmentStart,uniqueId:t.uniqueId},t.readName&&(r.mate.readName=t.readName)),t.flags|=j.BAM_FPAIRED,r.flags&j.BAM_FUNMAP&&(t.flags|=j.BAM_FMUNMAP),t.flags&j.BAM_FUNMAP&&(r.flags|=j.BAM_FMUNMAP),r.flags&j.BAM_FREVERSE&&(t.flags|=j.BAM_FMREVERSE),t.flags&j.BAM_FREVERSE&&(r.flags|=j.BAM_FMREVERSE),t.templateLength===void 0&&(i?Oc(n,e,t):qc(t,r)),delete t.mateRecordNumber}class $s{constructor(e,t){this.container=e,this.file=e.file,this.containerPosition=t}async getHeader(){const e=await this.file.getSectionParsers(),t=await this.container.getHeader(),r=await this.file.readBlock(t._endPosition+this.containerPosition);if(r.contentType==="MAPPED_SLICE_HEADER")r.content=rt(r.content,e.cramMappedSliceHeader.parser,0,t._endPosition);else if(r.contentType==="UNMAPPED_SLICE_HEADER")r.content=rt(r.content,e.cramUnmappedSliceHeader.parser,0,t._endPosition);else throw new U(`error reading slice header block, invalid content type ${r._contentType}`);return r}async getBlocks(){const e=await this.getHeader();let t=e._endPosition;const r=new Array(e.content.numBlocks);for(let i=0;i<r.length;i+=1)r[i]=await this.file.readBlock(t),t=r[i]._endPosition;return r}async getCoreDataBlock(){return(await this.getBlocks())[0]}async _getBlocksContentIdIndex(){const e=await this.getBlocks(),t={};return e.forEach(r=>{r.contentType==="EXTERNAL_DATA"&&(t[r.contentId]=r)}),t}async getBlockByContentId(e){return(await this._getBlocksContentIdIndex())[e]}async getReferenceRegion(){const e=(await this.getHeader()).content;if(e.refSeqId<0)return;const t=await this.container.getCompressionScheme();if(e.refBaseBlockId>=0){const r=this.getBlockByContentId(e.refBaseBlockId);if(!r)throw new U("embedded reference specified, but reference block does not exist");if(e.span>r.uncompressedSize)throw new U("Embedded reference is too small");return{seq:r.data.toString("utf8"),start:e.refSeqStart,end:e.refSeqStart+e.refSeqSpan-1,span:e.refSeqSpan}}if(t.referenceRequired||this.file.fetchReferenceSequenceCallback){if(!this.file.fetchReferenceSequenceCallback)throw new Error("reference sequence not embedded, and seqFetch callback not provided, cannot fetch reference sequence");const r=await this.file.fetchReferenceSequenceCallback(e.refSeqId,e.refSeqStart,e.refSeqStart+e.refSeqSpan-1);if(r.length!==e.refSeqSpan)throw new Jo("seqFetch callback returned a reference sequence of the wrong length");return{seq:r,start:e.refSeqStart,end:e.refSeqStart+e.refSeqSpan-1,span:e.refSeqSpan}}}getAllRecords(){return this.getRecords(()=>!0)}async _fetchRecords(){const{majorVersion:e}=await this.file.getDefinition(),t=await this.container.getCompressionScheme(),r=await this.getHeader(),i=await this._getBlocksContentIdIndex();if(e>1&&this.file.options.checkSequenceMD5&&r.content.refSeqId>=0&&r.content.md5.join("")!=="0000000000000000"){const c=await this.getReferenceRegion();if(c){const{seq:f,start:g,end:d}=c,h=Tc(f),p=r.content.md5.map(b=>(b<16?"0":"")+b.toString(16)).join("");if(h!==p)throw new U(`MD5 checksum reference mismatch for ref ${r.content.refSeqId} pos ${g}..${d}. recorded MD5: ${p}, calculated MD5: ${h}`)}}const s=await this.getCoreDataBlock(),a={lastAlignmentStart:r.content.refSeqStart||0,coreBlock:{bitPosition:7,bytePosition:0},externalBlocks:{map:new Map,getCursor(c){let f=this.map.get(c);return f===void 0&&(f={bitPosition:7,bytePosition:0},this.map.set(c,f)),f}}},o=c=>{const f=t.getCodecForDataSeries(c);if(!f)throw new U(`no codec defined for ${c} data series`);return f.decode(this,s,i,a)};let l=new Array(r.content.numRecords);for(let c=0;c<l.length;c+=1)try{l[c]=$c(this,o,t,r,s,i,a,e,c),l[c].uniqueId=r.contentPosition+r.content.recordCounter+c+1}catch(f){if(f instanceof Kt){console.warn("read attempted beyond end of buffer, file seems truncated."),l=l.filter(g=>!!g);break}else throw f}for(let c=0;c<l.length;c+=1){const{mateRecordNumber:f}=l[c];f>=0&&Uc(l,c,l[c],l[f])}return l}async getRecords(e){const t=this.container.filePosition+this.containerPosition;let r=this.file.featureCache.get(t);r||(r=this._fetchRecords(),this.file.featureCache.set(t,r));const i=(await r).filter(e);if(i.length&&this.file.fetchReferenceSequenceCallback){const s=await this.getHeader();if(s.content.refSeqId>=0||s.content.refSeqId===-2){const a=s.content.refSeqId>=0?s.content.refSeqId:void 0,o=await this.container.getCompressionScheme(),l={};for(let c=0;c<i.length;c+=1){const f=a!==void 0?a:i[c].sequenceId;let g=l[f];g||(g={id:f,start:i[c].alignmentStart,end:-1/0},l[f]=g);const d=i[c].alignmentStart+(i[c].lengthOnRef||i[c].readLength)-1;d>g.end&&(g.end=d),i[c].alignmentStart<g.start&&(g.start=i[c].alignmentStart)}await Promise.all(Object.values(l).map(async c=>{c.id!==-1&&c.start<=c.end&&(c.seq=await this.file.fetchReferenceSequenceCallback(c.id,c.start,c.end))}));for(let c=0;c<i.length;c+=1){const f=a!==void 0?a:i[c].sequenceId,g=l[f];g&&g.seq&&i[c].addReferenceSequence(g,o)}}}return i}}"getHeader getBlocks _getBlocksContentIdIndex".split(" ").forEach(n=>zn($s,n));const Hc={int:!0,byte:!0,long:!0,byteArray:!0,byteArrayBlock:!0};class ct{constructor(e={},t){if(this.parameters=e,this.dataType=t,!t)throw new TypeError("must provide a data type to codec constructor");if(!Hc[t])throw new TypeError(`invalid data type ${t}`)}_getBits(e,t,r){let i=0;if(t.bytePosition+(7-t.bitPosition+r)/8>e.length)throw new Kt("read error during decoding. the file seems to be truncated.");for(let s=r;s;s-=1)i<<=1,i|=e[t.bytePosition]>>t.bitPosition&1,t.bitPosition-=1,t.bitPosition<0&&(t.bytePosition+=1),t.bitPosition&=7;return i}}function Vc(n){let e=n-(n>>1)&1431655765;return e=(e&858993459)+(e>>2&858993459),(e+(e>>4)&252645135)*16843009>>24}class Zc extends ct{constructor(e={},t){if(super(e,t),!["byte","int"].includes(this.dataType))throw new TypeError(`${this.dataType} decoding not yet implemented by HUFFMAN_INT codec`);this.buildCodeBook(),this.buildCodes(),this.buildCaches(),this.sortedCodes[0].bitLength===0&&(this._decode=this._decodeZeroLengthCode)}buildCodeBook(){let e=new Array(this.parameters.numCodes);for(let t=0;t<this.parameters.numCodes;t+=1)e[t]={symbol:this.parameters.symbols[t],bitLength:this.parameters.bitLengths[t]};e=e.sort((t,r)=>t.bitLength-r.bitLength||t.symbol-r.symbol),this.codeBook={},e.forEach(t=>{this.codeBook[t.bitLength]||(this.codeBook[t.bitLength]=[]),this.codeBook[t.bitLength].push(t.symbol)})}buildCodes(){this.codes={};let e=0,t=-1;Object.entries(this.codeBook).forEach(([r,i])=>{r=parseInt(r,10),i.forEach(s=>{const a={bitLength:r,value:s};t+=1;const o=r-e;if(t<<=o,a.bitCode=t,e+=o,Vc(t)>r)throw new U("Symbol out of range");this.codes[s]=a})})}buildCaches(){this.sortedCodes=Object.values(this.codes).sort((t,r)=>t.bitLength-r.bitLength||t.bitCode-r.bitCode),this.sortedByValue=Object.values(this.codes).sort((t,r)=>t.value-r.value),this.sortedValuesByBitCode=this.sortedCodes.map(t=>t.value),this.sortedBitCodes=this.sortedCodes.map(t=>t.bitCode),this.sortedBitLengthsByBitCode=this.sortedCodes.map(t=>t.bitLength);const e=Math.max(...this.sortedBitCodes);this.bitCodeToValue=new Array(e+1).fill(-1);for(let t=0;t<this.sortedBitCodes.length;t+=1)this.bitCodeToValue[this.sortedCodes[t].bitCode]=t}decode(e,t,r,i){return this._decode(e,t,i.coreBlock)}_decodeZeroLengthCode(){return this.sortedCodes[0].value}_decode(e,t,r){const i=t.content;let s=0,a=0;for(let o=0;o<this.sortedCodes.length;o+=1){const l=this.sortedCodes[o].bitLength;a<<=l-s,a|=this._getBits(i,r,l-s),s=l;{const c=this.bitCodeToValue[a];if(c>-1&&this.sortedBitLengthsByBitCode[c]===l)return this.sortedValuesByBitCode[c];for(let f=o;this.sortedCodes[f+1].bitLength===l&&f<this.sortedCodes.length;f+=1)o+=1}}throw new U("Huffman symbol not found.")}}class Gc extends ct{constructor(e={},t){if(super(e,t),this.dataType==="int")this._decodeData=this._decodeInt;else if(this.dataType==="byte")this._decodeData=this._decodeByte;else throw new Xe(`${this.dataType} decoding not yet implemented by EXTERNAL codec`)}decode(e,t,r,i){const{blockContentId:s}=this.parameters,a=r[s];if(!a)throw new U(`no block found with content ID ${s}`);const o=i.externalBlocks.getCursor(s);return this._decodeData(a,o)}_decodeInt(e,t){const[r,i]=Fc(e.content,t.bytePosition);return t.bytePosition+=i,r}_decodeByte(e,t){if(t.bytePosition>=e.content.length)throw new Kt("attempted to read beyond end of block. this file seems truncated.");return e.content[t.bytePosition++]}}class jc extends ct{constructor(e={},t){if(super(e,t),t==="byteArray")this._decode=this._decodeByteArray;else throw new TypeError(`byteArrayStop codec does not support data type ${t}`)}decode(e,t,r,i){const{blockContentId:s}=this.parameters,a=r[s];if(!a)throw new U(`no block found with content ID ${s}`);const o=i.externalBlocks.getCursor(s);return this._decode(a,o)}_decodeByteArray(e,t){const r=e.content,{stopByte:i}=this.parameters,s=t.bytePosition;let a=t.bytePosition;for(;r[a]!==i&&a<r.length;){if(a===r.length)throw new Kt("byteArrayStop reading beyond length of data buffer?");a+=1}return t.bytePosition=a+1,r.slice(s,a)}}class Os extends ct{constructor(e={},t,r){if(super(e,t),this.instantiateCodec=r,t!=="byteArray")throw new TypeError(`byteArrayLength does not support data type ${t}`)}decode(e,t,r,i){const a=this._getLengthCodec().decode(e,t,r,i),o=this._getDataCodec(),l=new Uint8Array(a);for(let c=0;c<a;c+=1)l[c]=o.decode(e,t,r,i);return l}_getLengthCodec(){const e=this.parameters.lengthsEncoding;return this.instantiateCodec(e,"int")}_getDataCodec(){const e=this.parameters.valuesEncoding;return this.instantiateCodec(e,"byte")}}"_getLengthCodec _getDataCodec".split(" ").forEach(n=>zn(Os,n));class Kc extends ct{constructor(e={},t){if(super(e,t),this.dataType!=="int")throw new Xe(`${this.dataType} decoding not yet implemented by BETA codec`)}decode(e,t,r,i){return this._getBits(t.content,i.coreBlock,this.parameters.length)-this.parameters.offset}}class Wc extends ct{constructor(e={},t){if(super(e,t),this.dataType!=="int")throw new Xe(`${this.dataType} decoding not yet implemented by GAMMA codec`)}decode(e,t,r,i){let s=1;for(;this._getBits(t.content,i.coreBlock,1)===0;)s+=1;return(this._getBits(t.content,i.coreBlock,s-1)|1<<s-1)-this.parameters.offset}}class Qc extends ct{constructor(e={},t){if(super(e,t),this.dataType!=="int")throw new Xe(`${this.dataType} decoding not yet implemented by SUBEXP codec`)}decode(e,t,r,i){let s=0;for(;this._getBits(t.content,i.coreBlock,1);)s+=1;let a,o;return s===0?(a=this.parameters.K,o=this._getBits(t.content,i.coreBlock,a)):(a=s+this.parameters.K-1,o=1<<a|this._getBits(t.content,i.coreBlock,a)),o-this.parameters.offset}}const Yc={1:Gc,3:Zc,4:Os,5:jc,6:Kc,7:Qc,9:Wc};function Xc(n){return Yc[n]}function ui(n,e){const t=Xc(e==="ignore"?0:n.codecId);if(!t)throw new Xe(`no codec implemented for codec ID ${n.codecId}`);return new t(n.parameters,e,ui)}const Jc={BF:"int",CF:"int",RI:"int",RL:"int",AP:"int",RG:"int",MF:"int",NS:"int",NP:"int",TS:"int",NF:"int",TC:"byte",TN:"int",FN:"int",FC:"byte",FP:"int",BS:"byte",IN:"byteArray",SC:"byteArray",DL:"int",BA:"byte",BB:"byteArray",RS:"int",PD:"int",HC:"int",MQ:"int",RN:"byteArray",QS:"byte",QQ:"byteArray",TL:"int",TM:"ignore",TV:"ignore"};function ef(n){const e=new Array(5);for(let t=0;t<5;t+=1)e[t]=new Array(4);return e[0][n[0]>>6&3]="C",e[0][n[0]>>4&3]="G",e[0][n[0]>>2&3]="T",e[0][n[0]>>0&3]="N",e[1][n[1]>>6&3]="A",e[1][n[1]>>4&3]="G",e[1][n[1]>>2&3]="T",e[1][n[1]>>0&3]="N",e[2][n[2]>>6&3]="A",e[2][n[2]>>4&3]="C",e[2][n[2]>>2&3]="T",e[2][n[2]>>0&3]="N",e[3][n[3]>>6&3]="A",e[3][n[3]>>4&3]="C",e[3][n[3]>>2&3]="G",e[3][n[3]>>0&3]="N",e[4][n[4]>>6&3]="A",e[4][n[4]>>4&3]="C",e[4][n[4]>>2&3]="G",e[4][n[4]>>0&3]="T",e}class tf{constructor(e){Object.assign(this,e),this.readNamesIncluded=e.preservation.RN,this.APdelta=e.preservation.AP,this.referenceRequired=!!e.preservation.RR,this.tagIdsDictionary=e.preservation.TD,this.substitutionMatrix=ef(e.preservation.SM),this.dataSeriesCodecCache=new Map,this.tagCodecCache={}}getCodecForTag(e){if(!this.tagCodecCache[e]){const t=this.tagEncoding[e];t&&(this.tagCodecCache[e]=ui(t,"byteArray"))}return this.tagCodecCache[e]}getTagNames(e){return this.tagIdsDictionary[e]}getCodecForDataSeries(e){let t=this.dataSeriesCodecCache.get(e);if(t===void 0){const r=this.dataSeriesEncoding[e];if(r){const i=Jc[e];if(!i)throw new U(`data series name ${e} not defined in file compression header`);t=ui(r,i),this.dataSeriesCodecCache.set(e,t)}}return t}toJSON(){const e={};return Object.keys(this).forEach(t=>{/Cache$/.test(t)||(e[t]=this[t])}),e}}class qs{constructor(e,t){this.file=e,this.filePosition=t}getHeader(){return this._readContainerHeader(this.filePosition)}async getCompressionHeaderBlock(){if(!(await this.getHeader()).numRecords)return null;const t=await this.file.getSectionParsers(),r=await this.getFirstBlock();if(r.contentType!=="COMPRESSION_HEADER")throw new U(`invalid content type ${r.contentType} in what is supposed to be the compression header block`);const i=rt(r.content,t.cramCompressionHeader.parser,0,r.contentPosition);return r.content=i,r}async getFirstBlock(){const e=await this.getHeader();return this.file.readBlock(e._endPosition)}async getCompressionScheme(){const e=await this.getCompressionHeaderBlock();if(!!e)return new tf(e.content)}getSlice(e,t){return new $s(this,e,t)}async _readContainerHeader(e){const t=await this.file.getSectionParsers(),{cramContainerHeader1:r,cramContainerHeader2:i}=t,{size:s}=await this.file.stat();if(e>=s)return;const a=$.Buffer.allocUnsafe(r.maxLength);await this.file.read(a,0,r.maxLength,e);const o=rt(a,r.parser),l=Ac(o.numLandmarks);if(e+o.length>=s){console.warn(`${this.file}: container header at ${e} indicates that the container has length ${o.length}, which extends beyond the length of the file. Skipping this container.`);return}const c=$.Buffer.allocUnsafe(i.maxLength(o.numLandmarks));await this.file.read(c,0,i.maxLength(o.numLandmarks),e+o._size-l);const f=rt(c,i.parser);return this.file.validateChecksums&&f.crc32!==void 0&&await this.file.checkCrc32(e,o._size+f._size-l-4,f.crc32,`container header beginning at position ${e}`),Object.assign(o,f,{_size:o._size+f._size-l,_endPosition:o._size+f._size-l+e})}}"getHeader getCompressionHeaderBlock getCompressionScheme".split(" ").forEach(n=>zn(qs,n));class nf{constructor({fetch:e,size:t=1e7,chunkSize:r=32768}){if(!e)throw new Error("fetch function required");this.fetch=e,this.chunkSize=r,this.lruCache=new Rn({maxSize:Math.floor(t/r)})}async get(e,t,r,i){if(e.length<t+r)throw new Error("output buffer not big enough for request");const s=Math.floor(i/this.chunkSize),a=Math.floor((i+r)/this.chunkSize),o=new Array(a-s+1);for(let f=s;f<=a;f+=1)o[f-s]=this._getChunk(f).then(g=>({data:g,chunkNumber:f}));const l=await Promise.all(o),c=i-l[0].chunkNumber*this.chunkSize;l.forEach(({data:f,chunkNumber:g})=>{const d=g*this.chunkSize;let h=0,p=this.chunkSize,b=t+(g-s)*this.chunkSize-c;g===s&&(b=t,h=c),g===a&&(p=i+r-d),f.copy(e,b,h,p)})}_getChunk(e){const t=this.lruCache.get(e);if(t)return t;const r=this.fetch(e*this.chunkSize,this.chunkSize);return this.lruCache.set(e,r),r}}class rf{constructor(e){this.position=0,this.url=e,this.cache=new nf({fetch:(t,r)=>this._fetch(t,r)})}async _fetch(e,t){const r={};t<1/0?r.range=`bytes=${e}-${e+t}`:t===1/0&&e!==0&&(r.range=`bytes=${e}-`);const i=await _r(this.url,{method:"GET",headers:r,redirect:"follow",mode:"cors"});if(i.status===200&&e===0||i.status===206){const s=$.Buffer.from(await i.arrayBuffer()),a=/\/(\d+)$/.exec(i.headers.get("content-range"));return a[1]&&(this._stat={size:parseInt(a[1],10)}),s}throw new Error(`HTTP ${i.status} fetching ${this.url}`)}read(e,t=0,r=1/0,i=0){let s=i;return s===null&&(s=this.position,this.position+=r),this.cache.get(e,t,r,i)}async readFile(){const e=await _r(this.url,{method:"GET",redirect:"follow",mode:"cors"});return $.Buffer.from(await e.arrayBuffer())}async stat(){if(!this._stat){const e=$.Buffer.allocUnsafe(10);if(await this.read(e,0,10,0),!this._stat)throw new Error(`unable to determine size of file at ${this.url}`)}return this._stat}}function sf(n){const{protocol:e,pathname:t}=X.parse(n);return e==="file:"?new X(unescape(t)):new rf(n)}function Us(n,e,t){if(t)return t;if(n)return sf(n);if(e)return new X(e);throw new Error("no url, path, or filehandle provided, cannot open")}function af(n){const e=n.split(/\r?\n/),t=[];return e.forEach(r=>{const[i,...s]=r.split(/\t/),a=s.map(o=>{const[l,c]=o.split(":",2);return{tag:l,value:c}});i&&t.push({tag:i.substr(1),data:a})}),t}function of(){let n=new Uint32Array([287454020]),e=new Uint8Array(n.buffer);return e[0]===68?0:e[0]===17?1:2}class di{constructor(e){if(this.file=Us(e.url,e.path,e.filehandle),this.validateChecksums=!0,this.fetchReferenceSequenceCallback=e.seqFetch,this.options={checkSequenceMD5:e.checkSequenceMD5!==!1,cacheSize:e.cacheSize!==void 0?e.cacheSize:2e4},this.featureCache=new Rn({maxSize:this.options.cacheSize}),of()>0)throw new Error("Detected big-endian machine, may be unable to run")}toString(){return this.file.filename?this.file.filename:this.file.url?this.file.url:"(cram file)"}read(e,t,r,i){return this.file.read(e,t,r,i)}stat(){return this.file.stat()}async getDefinition(){const e=$.Buffer.allocUnsafe(wn.maxLength);await this.file.read(e,0,wn.maxLength,0);const t=wn.parser.parse(e).result;if(t.majorVersion!==2&&t.majorVersion!==3)throw new Xe(`CRAM version ${t.majorVersion} not supported`);return t}async getSamHeader(){const e=await this.getContainerById(0);if(!e)throw new U("file contains no containers");const{content:t}=await e.getFirstBlock(),r=t.readInt32LE(0),i=4,s=t.toString("utf8",i,i+r);return this.header=s,af(s)}async getHeaderText(){return await this.getSamHeader(),this.header}async getSectionParsers(){const{majorVersion:e}=await this.getDefinition();return Ic(e)}async getContainerById(e){const t=await this.getSectionParsers();let r=t.cramFileDefinition.maxLength;const{size:i}=await this.file.stat(),{cramContainerHeader1:s}=t;let a;for(let o=0;o<=e;o+=1){if(r+s.maxLength+8>=i)return;a=this.getContainerAtPosition(r);const l=await a.getHeader();if(!l)throw new U(`container ${e} not found in file`);if(o===0){r=l._endPosition;for(let c=0;c<l.numBlocks;c+=1)r=(await this.readBlock(r))._endPosition}else r+=l._size+l.length}return a}async checkCrc32(e,t,r,i){const s=$.Buffer.allocUnsafe(t);await this.file.read(s,0,t,e);const a=Is.unsigned(s);if(a!==r)throw new U(`crc mismatch in ${i}: recorded CRC32 = ${r}, but calculated CRC32 = ${a}`)}async containerCount(){const e=await this.getSectionParsers(),{size:t}=await this.file.stat(),{cramContainerHeader1:r}=e;let i=0,s=e.cramFileDefinition.maxLength;for(;s+r.maxLength+8<t;){const a=await this.getContainerAtPosition(s).getHeader();if(!a)break;if(i===0){s=a._endPosition;for(let o=0;o<a.numBlocks;o+=1)s=(await this.readBlock(s))._endPosition}else s+=a._size+a.length;i+=1}return i}getContainerAtPosition(e){return new qs(this,e)}async readBlockHeader(e){const t=await this.getSectionParsers(),{cramBlockHeader:r}=t,{size:i}=await this.file.stat();if(e+r.maxLength>=i)return;const s=$.Buffer.allocUnsafe(r.maxLength);return await this.file.read(s,0,r.maxLength,e),rt(s,r.parser,0,e)}async _parseSection(e,t,r=e.maxLength,i){let s;if(i)s=i;else{const{size:o}=await this.file.stat();if(t+r>=o)return;s=$.Buffer.allocUnsafe(r),await this.file.read(s,0,r,t)}const a=rt(s,e.parser,0,t);if(a._size!==r)throw new U(`section read error: requested size ${r} does not equal parsed size ${a._size}`);return a}_uncompress(e,t,r){if(e==="gzip")Ns(t).copy(r);else if(e==="bzip2"){var i=bzip2.array(t),s=bzip2.header(i),a=0;do{var o=bzip2.decompress(i,s);o!=-1&&($.Buffer.from(o).copy(r,a),a+=o.length,s-=o.length)}while(o!=-1)}else if(e==="rans")pc(t,r);else if(e==="rans4x16")on.r4x16_uncompress(t,r);else if(e==="arith")on.arith_uncompress(t,r);else if(e==="fqzcomp")on.fqzcomp_uncompress(t,r);else if(e==="tok3")on.tok3_uncompress(t,r);else throw new Xe(`${e} decompression not yet implemented`)}async readBlock(e){const{majorVersion:t}=await this.getDefinition(),r=await this.getSectionParsers(),i=await this.readBlockHeader(e),s=i._endPosition;i.contentPosition=i._endPosition;const a=$.Buffer.allocUnsafe(i.uncompressedSize);if(i.compressionMethod!=="raw"){const o=$.Buffer.allocUnsafe(i.compressedSize);await this.read(o,0,i.compressedSize,s),this._uncompress(i.compressionMethod,o,a)}else await this.read(a,0,i.uncompressedSize,s);if(i.content=a,t>=3){const o=await this._parseSection(r.cramBlockCrc32,s+i.compressedSize);i.crc32=o.crc32,this.validateChecksums&&await this.checkCrc32(e,i._size+i.compressedSize,i.crc32,"block data"),i._endPosition=o._endPosition,i._size=i.compressedSize+r.cramBlockCrc32.maxLength}else i._endPosition=s+i.compressedSize,i._size=i.compressedSize;return i}}"getDefinition getSectionParsers getSamHeader".split(" ").forEach(n=>zn(di,n));class qd{constructor(e){if(e.cram?this.cram=e.cram:this.cram=new di({url:e.cramUrl,path:e.cramPath,filehandle:e.cramFilehandle,seqFetch:e.seqFetch,checkSequenceMD5:e.checkSequenceMD5,cacheSize:e.cacheSize}),!(this.cram instanceof di))throw new Error("invalid arguments: no cramfile");if(this.index=e.index,!this.index.getEntriesForRange)throw new Error("invalid arguments: not an index");this.fetchSizeLimit=e.fetchSizeLimit||3e6}async getRecordsForRange(e,t,r,i={}){if(i.viewAsPairs=i.viewAsPairs||!1,i.pairAcrossChr=i.pairAcrossChr||!1,i.maxInsertSize=i.maxInsertSize||2e5,typeof e=="string")throw new Xe("string sequence names not yet supported");const s=e,a=await this.index.getEntriesForRange(s,t,r),o=a.map(g=>g.sliceBytes).reduce((g,d)=>g+d,0);if(o>this.fetchSizeLimit)throw new Xo(`data size of ${o.toLocaleString()} bytes exceeded fetch size limit of ${this.fetchSizeLimit.toLocaleString()} bytes`);const l=g=>g.sequenceId===e&&g.alignmentStart<=r&&g.alignmentStart+g.lengthOnRef-1>=t,c=await Promise.all(a.map(g=>this.getRecordsInSlice(g,l)));let f=Array.prototype.concat(...c);if(i.viewAsPairs){const g={},d={};for(let _=0;_<f.length;_+=1){const k=f[_].readName,I=f[_].uniqueId;g[k]||(g[k]=0),g[k]+=1,d[I]=1}const h={};Object.entries(g).forEach(([_,k])=>{k===1&&(h[_]=!0)});const p=[];for(let _=0;_<f.length;_+=1){const k=f[_].readName;if(h[k]&&f[_].mate&&(f[_].mate.sequenceId===s||i.pairAcrossChr)&&Math.abs(f[_].alignmentStart-f[_].mate.alignmentStart)<i.maxInsertSize){const I=this.index.getEntriesForRange(f[_].mate.sequenceId,f[_].mate.alignmentStart,f[_].mate.alignmentStart+1);p.push(I)}}const b=await Promise.all(p);let w=[];for(let _=0;_<b.length;_+=1)w.push(...b[_]);w=w.sort((_,k)=>_.toString().localeCompare(k.toString())).filter((_,k,I)=>!k||_.toString()!==I[k-1].toString());const S=[],E=w.map(_=>_.sliceBytes).reduce((_,k)=>_+k,0);if(E>this.fetchSizeLimit)throw new Error(`mate data size of ${E.toLocaleString()} bytes exceeded fetch size limit of ${this.fetchSizeLimit.toLocaleString()} bytes`);w.forEach(_=>{let k=this.cram.featureCache.get(_.toString());k||(k=this.getRecordsInSlice(_,()=>!0),this.cram.featureCache.set(_.toString(),k));const I=k.then(C=>{const T=[];for(let N=0;N<C.length;N+=1){const L=C[N];h[L.readName]&&!d[L.uniqueId]&&T.push(L)}return T});S.push(I)});const v=await Promise.all(S);if(v.length){const _=v.reduce((k,I)=>k.concat(I));f=f.concat(_)}}return f}getRecordsInSlice({containerStart:e,sliceStart:t,sliceBytes:r},i){return this.cram.getContainerAtPosition(e).getSlice(t,r).getRecords(i)}hasDataForReferenceSequence(e){return this.index.hasDataForReferenceSequence(e)}}const cf=21578050;class ff{constructor(e){Object.assign(this,e)}toString(){return`${this.start}:${this.span}:${this.containerStart}:${this.sliceStart}:${this.sliceBytes}`}}function yr(n,e){if(e.some(l=>l===void 0))throw new U("invalid .crai index file");const[t,r,i,s,a,o]=e;n[t]||(n[t]=[]),n[t].push(new ff({start:r,span:i,containerStart:s,sliceStart:a,sliceBytes:o}))}class Ud{constructor(e){const t=Us(e.url,e.path,e.filehandle);this._parseCache=new De({cache:new Rn({maxSize:1}),fill:(r,i)=>this.parseIndex({signal:i})}),this.readFile=t.readFile.bind(t)}parseIndex(){const e={};return this.readFile().then(t=>t[0]===31&&t[1]===139?Ns(t):t).then(t=>{if(t.length>4&&t.readUInt32LE(0)===cf)throw new U("invalid .crai index file. note: file appears to be a .bai index. this is technically legal but please open a github issue if you need support");let r=[],i="";for(let s=0;s<t.length;s+=1){const a=t[s];if(a>=48&&a<=57||!i&&a===45)i+=String.fromCharCode(a);else if(a===9)r.push(Number.parseInt(i,10)),i="";else if(a===10)r.push(Number.parseInt(i,10)),i="",yr(e,r),r=[];else if(a!==13&&a!==32)throw new U("invalid .crai index file")}return i&&r.push(Number.parseInt(i,10)),r.length===6&&yr(e,r),Object.entries(e).forEach(([s,a])=>{e[s]=a.sort((o,l)=>o.start-l.start||o.span-l.span)}),e})}getIndex(e={}){return this._parseCache.get("index",null,e.signal)}async hasDataForReferenceSequence(e){return!!(await this.getIndex())[e]}async getEntriesForRange(e,t,r){const i=(await this.getIndex())[e];if(!i)return[];const s=o=>{const l=o.start,c=o.start+o.span;return l>r?-1:c<=t?1:0},a=[];for(let o=0;o<i.length;o+=1)s(i[o])===0&&a.push(i[o]);return a}}class Hs{constructor(e,t){this.blockPosition=e,this.dataPosition=t}toString(){return`${this.blockPosition}:${this.dataPosition}`}compareTo(e){return this.blockPosition-e.blockPosition||this.dataPosition-e.dataPosition}static min(...e){let t,r=0;for(;!t;r+=1)t=e[r];for(;r<e.length;r+=1)t.compareTo(e[r])>0&&(t=e[r]);return t}}function _t(n,e=0,t=!1){if(t)throw new Error("big-endian virtual file offsets not implemented");return new Hs(n[e+7]*1099511627776+n[e+6]*4294967296+n[e+5]*16777216+n[e+4]*65536+n[e+3]*256+n[e+2],n[e+1]<<8|n[e])}class In{constructor(e,t,r,i=void 0){this.minv=e,this.maxv=t,this.bin=r,this._fetchedSize=i}toUniqueString(){return`${this.minv}..${this.maxv} (bin ${this.bin}, fetchedSize ${this.fetchedSize()})`}toString(){return this.toUniqueString()}compareTo(e){return this.minv.compareTo(e.minv)||this.maxv.compareTo(e.maxv)||this.bin-e.bin}fetchedSize(){return this._fetchedSize!==void 0?this._fetchedSize:this.maxv.blockPosition+(1<<16)-this.minv.blockPosition}}class Vs{constructor({filehandle:e,renameRefSeq:t=r=>r}){this.filehandle=e,this.renameRefSeq=t}_findFirstData(e,t){const r=e.firstDataLine;r?e.firstDataLine=r.compareTo(t)>0?t:r:e.firstDataLine=t}async parse(e={}){return this.setupP||(this.setupP=this._parse(e).catch(t=>{throw this.setupP=void 0,t})),this.setupP}async hasRefSeq(e,t={}){return!!((await this.parse(t)).indices[e]||{}).binIndex}}function lf(n){return new Promise(e=>setTimeout(e,n))}function Zs(n){if(n.greaterThan(Number.MAX_SAFE_INTEGER)||n.lessThan(Number.MIN_SAFE_INTEGER))throw new Error("integer overflow");return n.toNumber()}function Gs(n){if(!!n&&n.aborted){if(typeof DOMException<"u")throw new DOMException("aborted","AbortError");{const e=new Error("aborted");throw e.code="ERR_ABORTED",e}}}async function js(n){await Promise.resolve(),Gs(n)}function hf(n,e){return e.minv.blockPosition-n.maxv.blockPosition<65e3&&e.maxv.blockPosition-n.minv.blockPosition<5e6}function uf(n={}){return"aborted"in n?{signal:n}:n}function Ks(n,e){const t=[];let r=null;return n.length===0?n:(n.sort((i,s)=>{const a=i.minv.blockPosition-s.minv.blockPosition;return a!==0?a:i.minv.dataPosition-s.minv.dataPosition}),n.forEach(i=>{(!e||i.maxv.compareTo(e)>0)&&(r===null?(t.push(i),r=i):hf(r,i)?i.maxv.compareTo(r.maxv)>0&&(r.maxv=i.maxv):(t.push(i),r=i))}),t)}const df=21578050;function gf(n,e){return n-n%e}function pf(n,e){return n-n%e+e}class It extends Vs{parsePseudoBin(e,t){return{lineCount:Zs(Ct.fromBytesLE(Array.prototype.slice.call(e,t+16,t+24),!0))}}async lineCount(e,t={}){const i=(await this.parse(t)).indices[e];if(!i)return-1;const s=i.stats||{};return s.lineCount===void 0?-1:s.lineCount}fetchBai(e={}){return this.baiP||(this.baiP=this.filehandle.readFile(e).catch(t=>{throw this.baiP=void 0,t})),this.baiP}async _parse(){const e={bai:!0,maxBlockSize:65536},t=await this.fetchBai();if(t.readUInt32LE(0)!==df)throw new Error("Not a BAI file");e.refCount=t.readInt32LE(4);const i=((1<<(5+1)*3)-1)/7;e.indices=new Array(e.refCount);let s=8;for(let a=0;a<e.refCount;a+=1){const o=t.readInt32LE(s);let l;s+=4;const c={};for(let d=0;d<o;d+=1){const h=t.readUInt32LE(s);if(s+=4,h===i+1)s+=4,l=this.parsePseudoBin(t,s),s+=32;else{if(h>i+1)throw new Error("bai index contains too many bins, please use CSI");{const p=t.readInt32LE(s);s+=4;const b=new Array(p);for(let w=0;w<p;w+=1){const S=_t(t,s),E=_t(t,s+8);s+=16,this._findFirstData(e,S),b[w]=new In(S,E,h)}c[h]=b}}}const f=t.readInt32LE(s);s+=4;const g=new Array(f);for(let d=0;d<f;d+=1)g[d]=_t(t,s),s+=8,this._findFirstData(e,g[d]);e.indices[a]={binIndex:c,linearIndex:g,stats:l}}return e}async indexCov(e,t,r,i={}){const a=t!==void 0,l=(await this.parse(i)).indices[e];if(!l)return[];const{linearIndex:c=[],stats:f}=l;if(!c.length)return[];const g=r!==void 0?pf(r,16384):(c.length-1)*16384,d=t!==void 0?gf(t,16384):0;let h;a?h=new Array((g-d)/16384):h=new Array(c.length-1);const p=c[c.length-1].blockPosition;if(g>(c.length-1)*16384)throw new Error("query outside of range of linear index");let b=c[d/16384].blockPosition;for(let w=d/16384,S=0;w<g/16384;w++,S++)h[S]={score:c[w+1].blockPosition-b,start:w*16384,end:w*16384+16384},b=c[w+1].blockPosition;return h.map(w=>({...w,score:w.score*f.lineCount/p}))}reg2bins(e,t){return t-=1,[[0,0],[1+(e>>26),1+(t>>26)],[9+(e>>23),9+(t>>23)],[73+(e>>20),73+(t>>20)],[585+(e>>17),585+(t>>17)],[4681+(e>>14),4681+(t>>14)]]}async blocksForRange(e,t,r,i={}){t<0&&(t=0);const s=await this.parse(i);if(!s)return[];const a=s.indices[e];if(!a)return[];const o=this.reg2bins(t,r),l=[];for(const[h,p]of o)for(let b=h;b<=p;b++)if(a.binIndex[b]){const w=a.binIndex[b];for(let S=0;S<w.length;++S)l.push(new In(w[S].minv,w[S].maxv,b))}const c=a.linearIndex.length;let f=null;const g=Math.min(t>>14,c-1),d=Math.min(r>>14,c-1);for(let h=g;h<=d;++h){const p=a.linearIndex[h];p&&(!f||p.compareTo(f)<0)&&(f=p)}return Ks(l,f)}}async function Je(n){try{let e,t=0,r=0;const i=[];let s=0,a;do{const l=n.subarray(t);if(a=new $t.Inflate,{strm:e}=a,a.push(l,$t.Z_SYNC_FLUSH),a.err)throw new Error(a.msg);t+=e.next_in,i[r]=a.result,s+=i[r].length,r+=1}while(e.avail_in);const o=new Uint8Array(s);for(let l=0,c=0;l<i.length;l++)o.set(i[l],c),c+=i[l].length;return $.Buffer.from(o)}catch(e){throw`${e}`.match(/incorrect header check/)?new Error("problem decompressing block: incorrect gzip header check"):e}}async function Ws(n,e){try{let t;const{minv:r,maxv:i}=e;let s=r.blockPosition,a=r.dataPosition;const o=[],l=[],c=[];let f=0,g=0;do{const p=n.subarray(s-r.blockPosition),b=new $t.Inflate;if({strm:t}=b,b.push(p,$t.Z_SYNC_FLUSH),b.err)throw new Error(b.msg);const w=b.result;o.push(w);let S=w.length;l.push(s),c.push(a),o.length===1&&r.dataPosition&&(o[0]=o[0].subarray(r.dataPosition),S=o[0].length);const E=s;if(s+=t.next_in,a+=S,E>=i.blockPosition){o[g]=o[g].subarray(0,i.blockPosition===r.blockPosition?i.dataPosition-r.dataPosition+1:i.dataPosition+1),l.push(s),c.push(a),f+=o[g].length;break}f+=o[g].length,g++}while(t.avail_in);const d=new Uint8Array(f);for(let p=0,b=0;p<o.length;p++)d.set(o[p],b),b+=o[p].length;return{buffer:$.Buffer.from(d),cpositions:l,dpositions:c}}catch(t){throw`${t}`.match(/incorrect header check/)?new Error("problem decompressing block: incorrect gzip header check"):t}}/**
 * @license
 * Copyright 2009 The Closure Library Authors
 * Copyright 2020 Daniel Wirtz / The long.js Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */var de=null;try{de=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function Y(n,e,t){this.low=n|0,this.high=e|0,this.unsigned=!!t}Y.prototype.__isLong__;Object.defineProperty(Y.prototype,"__isLong__",{value:!0});function ae(n){return(n&&n.__isLong__)===!0}function Sr(n){var e=Math.clz32(n&-n);return n?31-e:e}Y.isLong=ae;var Er={},Cr={};function ft(n,e){var t,r,i;return e?(n>>>=0,(i=0<=n&&n<256)&&(r=Cr[n],r)?r:(t=Z(n,0,!0),i&&(Cr[n]=t),t)):(n|=0,(i=-128<=n&&n<128)&&(r=Er[n],r)?r:(t=Z(n,n<0?-1:0,!1),i&&(Er[n]=t),t))}Y.fromInt=ft;function ge(n,e){if(isNaN(n))return e?ze:we;if(e){if(n<0)return ze;if(n>=Qs)return Js}else{if(n<=-kr)return ce;if(n+1>=kr)return Xs}return n<0?ge(-n,e).neg():Z(n%yt|0,n/yt|0,e)}Y.fromNumber=ge;function Z(n,e,t){return new Y(n,e,t)}Y.fromBits=Z;var An=Math.pow;function Si(n,e,t){if(n.length===0)throw Error("empty string");if(typeof e=="number"?(t=e,e=!1):e=!!e,n==="NaN"||n==="Infinity"||n==="+Infinity"||n==="-Infinity")return e?ze:we;if(t=t||10,t<2||36<t)throw RangeError("radix");var r;if((r=n.indexOf("-"))>0)throw Error("interior hyphen");if(r===0)return Si(n.substring(1),e,t).neg();for(var i=ge(An(t,8)),s=we,a=0;a<n.length;a+=8){var o=Math.min(8,n.length-a),l=parseInt(n.substring(a,a+o),t);if(o<8){var c=ge(An(t,o));s=s.mul(c).add(ge(l))}else s=s.mul(i),s=s.add(ge(l))}return s.unsigned=e,s}Y.fromString=Si;function Ee(n,e){return typeof n=="number"?ge(n,e):typeof n=="string"?Si(n,e):Z(n.low,n.high,typeof e=="boolean"?e:n.unsigned)}Y.fromValue=Ee;var xr=1<<16,mf=1<<24,yt=xr*xr,Qs=yt*yt,kr=Qs/2,vr=ft(mf),we=ft(0);Y.ZERO=we;var ze=ft(0,!0);Y.UZERO=ze;var pt=ft(1);Y.ONE=pt;var Ys=ft(1,!0);Y.UONE=Ys;var gi=ft(-1);Y.NEG_ONE=gi;var Xs=Z(-1,2147483647,!1);Y.MAX_VALUE=Xs;var Js=Z(-1,-1,!0);Y.MAX_UNSIGNED_VALUE=Js;var ce=Z(0,-2147483648,!1);Y.MIN_VALUE=ce;var x=Y.prototype;x.toInt=function(){return this.unsigned?this.low>>>0:this.low};x.toNumber=function(){return this.unsigned?(this.high>>>0)*yt+(this.low>>>0):this.high*yt+(this.low>>>0)};x.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(ce)){var t=ge(e),r=this.div(t),i=r.mul(t).sub(this);return r.toString(e)+i.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var s=ge(An(e,6),this.unsigned),a=this,o="";;){var l=a.div(s),c=a.sub(l.mul(s)).toInt()>>>0,f=c.toString(e);if(a=l,a.isZero())return f+o;for(;f.length<6;)f="0"+f;o=""+f+o}};x.getHighBits=function(){return this.high};x.getHighBitsUnsigned=function(){return this.high>>>0};x.getLowBits=function(){return this.low};x.getLowBitsUnsigned=function(){return this.low>>>0};x.getNumBitsAbs=function(){if(this.isNegative())return this.eq(ce)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,t=31;t>0&&(e&1<<t)==0;t--);return this.high!=0?t+33:t+1};x.isZero=function(){return this.high===0&&this.low===0};x.eqz=x.isZero;x.isNegative=function(){return!this.unsigned&&this.high<0};x.isPositive=function(){return this.unsigned||this.high>=0};x.isOdd=function(){return(this.low&1)===1};x.isEven=function(){return(this.low&1)===0};x.equals=function(e){return ae(e)||(e=Ee(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low};x.eq=x.equals;x.notEquals=function(e){return!this.eq(e)};x.neq=x.notEquals;x.ne=x.notEquals;x.lessThan=function(e){return this.comp(e)<0};x.lt=x.lessThan;x.lessThanOrEqual=function(e){return this.comp(e)<=0};x.lte=x.lessThanOrEqual;x.le=x.lessThanOrEqual;x.greaterThan=function(e){return this.comp(e)>0};x.gt=x.greaterThan;x.greaterThanOrEqual=function(e){return this.comp(e)>=0};x.gte=x.greaterThanOrEqual;x.ge=x.greaterThanOrEqual;x.compare=function(e){if(ae(e)||(e=Ee(e)),this.eq(e))return 0;var t=this.isNegative(),r=e.isNegative();return t&&!r?-1:!t&&r?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};x.comp=x.compare;x.negate=function(){return!this.unsigned&&this.eq(ce)?ce:this.not().add(pt)};x.neg=x.negate;x.add=function(e){ae(e)||(e=Ee(e));var t=this.high>>>16,r=this.high&65535,i=this.low>>>16,s=this.low&65535,a=e.high>>>16,o=e.high&65535,l=e.low>>>16,c=e.low&65535,f=0,g=0,d=0,h=0;return h+=s+c,d+=h>>>16,h&=65535,d+=i+l,g+=d>>>16,d&=65535,g+=r+o,f+=g>>>16,g&=65535,f+=t+a,f&=65535,Z(d<<16|h,f<<16|g,this.unsigned)};x.subtract=function(e){return ae(e)||(e=Ee(e)),this.add(e.neg())};x.sub=x.subtract;x.multiply=function(e){if(this.isZero())return this;if(ae(e)||(e=Ee(e)),de){var t=de.mul(this.low,this.high,e.low,e.high);return Z(t,de.get_high(),this.unsigned)}if(e.isZero())return this.unsigned?ze:we;if(this.eq(ce))return e.isOdd()?ce:we;if(e.eq(ce))return this.isOdd()?ce:we;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(vr)&&e.lt(vr))return ge(this.toNumber()*e.toNumber(),this.unsigned);var r=this.high>>>16,i=this.high&65535,s=this.low>>>16,a=this.low&65535,o=e.high>>>16,l=e.high&65535,c=e.low>>>16,f=e.low&65535,g=0,d=0,h=0,p=0;return p+=a*f,h+=p>>>16,p&=65535,h+=s*f,d+=h>>>16,h&=65535,h+=a*c,d+=h>>>16,h&=65535,d+=i*f,g+=d>>>16,d&=65535,d+=s*c,g+=d>>>16,d&=65535,d+=a*l,g+=d>>>16,d&=65535,g+=r*f+i*c+s*l+a*o,g&=65535,Z(h<<16|p,g<<16|d,this.unsigned)};x.mul=x.multiply;x.divide=function(e){if(ae(e)||(e=Ee(e)),e.isZero())throw Error("division by zero");if(de){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var t=(this.unsigned?de.div_u:de.div_s)(this.low,this.high,e.low,e.high);return Z(t,de.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?ze:we;var r,i,s;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return ze;if(e.gt(this.shru(1)))return Ys;s=ze}else{if(this.eq(ce)){if(e.eq(pt)||e.eq(gi))return ce;if(e.eq(ce))return pt;var a=this.shr(1);return r=a.div(e).shl(1),r.eq(we)?e.isNegative()?pt:gi:(i=this.sub(e.mul(r)),s=r.add(i.div(e)),s)}else if(e.eq(ce))return this.unsigned?ze:we;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();s=we}for(i=this;i.gte(e);){r=Math.max(1,Math.floor(i.toNumber()/e.toNumber()));for(var o=Math.ceil(Math.log(r)/Math.LN2),l=o<=48?1:An(2,o-48),c=ge(r),f=c.mul(e);f.isNegative()||f.gt(i);)r-=l,c=ge(r,this.unsigned),f=c.mul(e);c.isZero()&&(c=pt),s=s.add(c),i=i.sub(f)}return s};x.div=x.divide;x.modulo=function(e){if(ae(e)||(e=Ee(e)),de){var t=(this.unsigned?de.rem_u:de.rem_s)(this.low,this.high,e.low,e.high);return Z(t,de.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};x.mod=x.modulo;x.rem=x.modulo;x.not=function(){return Z(~this.low,~this.high,this.unsigned)};x.countLeadingZeros=function(){return this.high?Math.clz32(this.high):Math.clz32(this.low)+32};x.clz=x.countLeadingZeros;x.countTrailingZeros=function(){return this.low?Sr(this.low):Sr(this.high)+32};x.ctz=x.countTrailingZeros;x.and=function(e){return ae(e)||(e=Ee(e)),Z(this.low&e.low,this.high&e.high,this.unsigned)};x.or=function(e){return ae(e)||(e=Ee(e)),Z(this.low|e.low,this.high|e.high,this.unsigned)};x.xor=function(e){return ae(e)||(e=Ee(e)),Z(this.low^e.low,this.high^e.high,this.unsigned)};x.shiftLeft=function(e){return ae(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Z(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):Z(0,this.low<<e-32,this.unsigned)};x.shl=x.shiftLeft;x.shiftRight=function(e){return ae(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Z(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):Z(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};x.shr=x.shiftRight;x.shiftRightUnsigned=function(e){return ae(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Z(this.low>>>e|this.high<<32-e,this.high>>>e,this.unsigned):e===32?Z(this.high,0,this.unsigned):Z(this.high>>>e-32,0,this.unsigned)};x.shru=x.shiftRightUnsigned;x.shr_u=x.shiftRightUnsigned;x.rotateLeft=function(e){var t;return ae(e)&&(e=e.toInt()),(e&=63)===0?this:e===32?Z(this.high,this.low,this.unsigned):e<32?(t=32-e,Z(this.low<<e|this.high>>>t,this.high<<e|this.low>>>t,this.unsigned)):(e-=32,t=32-e,Z(this.high<<e|this.low>>>t,this.low<<e|this.high>>>t,this.unsigned))};x.rotl=x.rotateLeft;x.rotateRight=function(e){var t;return ae(e)&&(e=e.toInt()),(e&=63)===0?this:e===32?Z(this.high,this.low,this.unsigned):e<32?(t=32-e,Z(this.high<<t|this.low>>>e,this.low<<t|this.high>>>e,this.unsigned)):(e-=32,t=32-e,Z(this.low<<t|this.high>>>e,this.high<<t|this.low>>>e,this.unsigned))};x.rotr=x.rotateRight;x.toSigned=function(){return this.unsigned?Z(this.low,this.high,!1):this};x.toUnsigned=function(){return this.unsigned?this:Z(this.low,this.high,!0)};x.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};x.toBytesLE=function(){var e=this.high,t=this.low;return[t&255,t>>>8&255,t>>>16&255,t>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};x.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,t>>>24,t>>>16&255,t>>>8&255,t&255]};Y.fromBytes=function(e,t,r){return r?Y.fromBytesLE(e,t):Y.fromBytesBE(e,t)};Y.fromBytesLE=function(e,t){return new Y(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)};Y.fromBytesBE=function(e,t){return new Y(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)};const ln=1;class _f{constructor({filehandle:e,path:t}){if(e)this.filehandle=e;else if(t)this.filehandle=new X(t);else throw new TypeError("either filehandle or path must be defined")}_readLongWithOverflow(e,t=0,r=!0){const i=Y.fromBytesLE(e.slice(t,t+8),r);if(i.greaterThan(Number.MAX_SAFE_INTEGER)||i.lessThan(Number.MIN_SAFE_INTEGER))throw new TypeError("integer overflow");return i.toNumber()}_getIndex(){return this.index||(this.index=this._readIndex()),this.index}async _readIndex(){let e=$.Buffer.allocUnsafe(8);await this.filehandle.read(e,0,8,0);const t=this._readLongWithOverflow(e,0,!0);if(!t)return[[0,0]];const r=new Array(t+1);r[0]=[0,0];const i=8*2*t;if(i>Number.MAX_SAFE_INTEGER)throw new TypeError("integer overflow");e=$.Buffer.allocUnsafe(i),await this.filehandle.read(e,0,i,8);for(let s=0;s<t;s+=1){const a=this._readLongWithOverflow(e,s*16),o=this._readLongWithOverflow(e,s*16+8);r[s+1]=[a,o]}return r}async getLastBlock(){const e=await this._getIndex();if(!!e.length)return e[e.length-1]}async getRelevantBlocksForRead(e,t){const r=t+e;if(e===0)return[];const i=await this._getIndex(),s=[],a=(d,h)=>{const p=d[ln],b=h?h[ln]:1/0;return p<=t&&b>t?0:p<t?-1:1};let o=0,l=i.length-1,c=Math.floor(i.length/2),f=a(i[c],i[c+1]);for(;f!==0;)f>0?l=c-1:f<0&&(o=c+1),c=Math.ceil((l-o)/2)+o,f=a(i[c],i[c+1]);s.push(i[c]);let g=c+1;for(;g<i.length&&(s.push(i[g]),!(i[g][ln]>=r));g+=1);return s[s.length-1][ln]<r&&s.push([]),s}}class Ir{constructor({filehandle:e,path:t,gziFilehandle:r,gziPath:i}){if(e)this.filehandle=e;else if(t)this.filehandle=new X(t);else throw new TypeError("either filehandle or path must be defined");if(!r&&!i&&!t)throw new TypeError("either gziFilehandle or gziPath must be defined");this.gzi=new _f({filehandle:r,path:!r&&!i&&t?i:`${t}.gzi`})}async stat(){const e=await this.filehandle.stat();return Object.assign(e,{size:await this.getUncompressedFileSize(),blocks:void 0,blksize:void 0})}async getUncompressedFileSize(){const[,e]=await this.gzi.getLastBlock(),{size:t}=await this.filehandle.stat(),r=$.Buffer.allocUnsafe(4),{bytesRead:i}=await this.filehandle.read(r,0,4,t-28-4);if(i!==4)throw new Error("read error");const s=r.readUInt32LE(0);return e+s}async _readAndUncompressBlock(e,[t],[r]){let i=r;i||(i=(await this.filehandle.stat()).size);const s=i-t;return await this.filehandle.read(e,0,s,t),await Je(e.slice(0,s))}async read(e,t,r,i){const s=await this.gzi.getRelevantBlocksForRead(r,i),a=$.Buffer.allocUnsafe(32768*2);let o=t,l=0;for(let c=0;c<s.length-1;c+=1){const f=await this._readAndUncompressBlock(a,s[c],s[c+1]),[,g]=s[c],d=g>=i?0:i-g,h=Math.min(i+r,g+f.length)-g;d>=0&&d<f.length&&(f.copy(e,o,d,h),o+=h-d,l+=h-d)}return{bytesRead:l,buffer:e}}}const bf=21582659,wf=38359875;function yf(n,e){return n*2**e}function Ar(n,e){return Math.floor(n/2**e)}class Vn extends Vs{constructor(e){super(e),this.maxBinNumber=0,this.depth=0,this.minShift=0}async lineCount(e){const t=await this.parse();if(!t||!t.indices[e])return-1;const{stats:i}=t.indices[e];return i?i.lineCount:-1}async indexCov(){return[]}parseAuxData(e,t,r){if(r<30)return{};const i={};if(i.formatFlags=e.readInt32LE(t),i.coordinateType=i.formatFlags&65536?"zero-based-half-open":"1-based-closed",i.format={0:"generic",1:"SAM",2:"VCF"}[i.formatFlags&15],!i.format)throw new Error(`invalid Tabix preset format flags ${i.formatFlags}`);i.columnNumbers={ref:e.readInt32LE(t+4),start:e.readInt32LE(t+8),end:e.readInt32LE(t+12)},i.metaValue=e.readInt32LE(t+16),i.metaChar=i.metaValue?String.fromCharCode(i.metaValue):"",i.skipLines=e.readInt32LE(t+20);const s=e.readInt32LE(t+24);return Object.assign(i,this._parseNameBytes(e.subarray(t+28,t+28+s))),i}_parseNameBytes(e){let t=0,r=0;const i=[],s={};for(let a=0;a<e.length;a+=1)if(!e[a]){if(r<a){let o=e.toString("utf8",r,a);o=this.renameRefSeq(o),i[t]=o,s[o]=t}r=a+1,t+=1}return{refNameToId:s,refIdToName:i}}async _parse(e){const t={csi:!0,maxBlockSize:65536},r=await this.filehandle.readFile(e),i=await Je(r);if(i.readUInt32LE(0)===bf)t.csiVersion=1;else if(i.readUInt32LE(0)===wf)t.csiVersion=2;else throw new Error("Not a CSI file");this.minShift=i.readInt32LE(4),this.depth=i.readInt32LE(8),this.maxBinNumber=((1<<(this.depth+1)*3)-1)/7;const s=i.readInt32LE(12);s&&Object.assign(t,this.parseAuxData(i,16,s)),t.refCount=i.readInt32LE(16+s),t.indices=new Array(t.refCount);let a=16+s+4;for(let o=0;o<t.refCount;o+=1){await js(e.signal);const l=i.readInt32LE(a);a+=4;const c={};let f;for(let g=0;g<l;g+=1){const d=i.readUInt32LE(a);if(d>this.maxBinNumber)f=this.parsePseudoBin(i,a+4),a+=4+8+4+16+16;else{const h=_t(i,a+4);this._findFirstData(t,h);const p=i.readInt32LE(a+12);a+=16;const b=new Array(p);for(let w=0;w<p;w+=1){const S=_t(i,a),E=_t(i,a+8);a+=16,b[w]=new In(S,E,d)}c[d]=b}}t.indices[o]={binIndex:c,stats:f}}return t}parsePseudoBin(e,t){return{lineCount:Zs(Ct.fromBytesLE(Array.prototype.slice.call(e,t+28,t+36),!0))}}async blocksForRange(e,t,r,i={}){t<0&&(t=0);const s=await this.parse(i),a=s==null?void 0:s.indices[e];if(!a)return[];const o=this.reg2bins(t,r),l=[];for(const[c,f]of o)for(let g=c;g<=f;g++)if(a.binIndex[g]){const d=a.binIndex[g];for(let h=0;h<d.length;++h)l.push(new In(d[h].minv,d[h].maxv,g))}return Ks(l,new Hs(0,0))}reg2bins(e,t){e-=1,e<1&&(e=1),t>2**50&&(t=2**34),t-=1;let r=0,i=0,s=this.minShift+this.depth*3;const a=[];for(;r<=this.depth;s-=3,i+=yf(1,r*3),r+=1){const o=i+Ar(e,s),l=i+Ar(t,s);if(l-o+a.length>this.maxBinNumber)throw new Error(`query ${e}-${t} is too large for current binning scheme (shift ${this.minShift}, depth ${this.depth}), try a smaller query or a coarser index binning scheme`);a.push([o,l])}return a}}const ue={BAM_FPAIRED:1,BAM_FPROPER_PAIR:2,BAM_FUNMAP:4,BAM_FMUNMAP:8,BAM_FREVERSE:16,BAM_FMREVERSE:32,BAM_FREAD1:64,BAM_FREAD2:128,BAM_FSECONDARY:256,BAM_FQCFAIL:512,BAM_FDUP:1024,BAM_FSUPPLEMENTARY:2048},Fr="=ACMGRSVTWYHKDBN".split(""),At="MIDNSHP=X???????".split("");class Sf{constructor(e){this.data={},this._tagList=[],this._allTagsParsed=!1;const{bytes:t,fileOffset:r}=e,{byteArray:i,start:s}=t;this.data={},this.bytes=t,this._id=r,this._refID=i.readInt32LE(s+4),this.data.start=i.readInt32LE(s+8),this.flags=(i.readInt32LE(s+16)&4294901760)>>16}get(e){return this[e]?this.data[e]?this.data[e]:(this.data[e]=this[e](),this.data[e]):this._get(e.toLowerCase())}end(){return this.get("start")+this.get("length_on_ref")}seq_id(){return this._refID}_get(e){return e in this.data?this.data[e]:(this.data[e]=this._parseTag(e),this.data[e])}_tags(){this._parseAllTags();let e=["seq"];this.isSegmentUnmapped()||e.push("start","end","strand","score","qual","MQ","CIGAR","length_on_ref","template_length"),this.isPaired()&&e.push("next_segment_position","pair_orientation"),e=e.concat(this._tagList||[]),Object.keys(this.data).forEach(r=>{r[0]!=="_"&&r!=="next_seq_id"&&e.push(r)});const t={};return e.filter(r=>{if(r in this.data&&this.data[r]===void 0||r==="CG"||r==="cg")return!1;const i=r.toLowerCase(),s=t[i];return t[i]=!0,!s})}parent(){}children(){return this.get("subfeatures")}id(){return this._id}mq(){const e=(this.get("_bin_mq_nl")&65280)>>8;return e===255?void 0:e}score(){return this.get("mq")}qual(){var e;return(e=this.qualRaw())===null||e===void 0?void 0:e.join(" ")}qualRaw(){if(this.isSegmentUnmapped())return;const{start:e,byteArray:t}=this.bytes,r=e+36+this.get("_l_read_name")+this.get("_n_cigar_op")*4+this.get("_seq_bytes"),i=this.get("seq_length");return t.subarray(r,r+i)}strand(){return this.isReverseComplemented()?-1:1}multi_segment_next_segment_strand(){if(!this.isMateUnmapped())return this.isMateReverseComplemented()?-1:1}name(){return this.get("_read_name")}_read_name(){const e=this.get("_l_read_name"),{byteArray:t,start:r}=this.bytes;return t.toString("ascii",r+36,r+36+e-1)}_parseTag(e){if(this._allTagsParsed)return;const{byteArray:t,start:r}=this.bytes;let i=this._tagOffset||r+36+this.get("_l_read_name")+this.get("_n_cigar_op")*4+this.get("_seq_bytes")+this.get("seq_length");const s=this.bytes.end;let a;for(;i<s&&a!==e;){const o=String.fromCharCode(t[i],t[i+1]);a=o.toLowerCase();const l=String.fromCharCode(t[i+2]);i+=3;let c;switch(l){case"A":c=String.fromCharCode(t[i]),i+=1;break;case"i":c=t.readInt32LE(i),i+=4;break;case"I":c=t.readUInt32LE(i),i+=4;break;case"c":c=t.readInt8(i),i+=1;break;case"C":c=t.readUInt8(i),i+=1;break;case"s":c=t.readInt16LE(i),i+=2;break;case"S":c=t.readUInt16LE(i),i+=2;break;case"f":c=t.readFloatLE(i),i+=4;break;case"Z":case"H":for(c="";i<=s;){const f=t[i++];if(f===0)break;c+=String.fromCharCode(f)}break;case"B":{c="";const f=t[i++],g=String.fromCharCode(f),d=t.readInt32LE(i);if(i+=4,g==="i")if(o==="CG")for(let h=0;h<d;h++){const p=t.readInt32LE(i),b=p>>4,w=At[p&15];c+=b+w,i+=4}else for(let h=0;h<d;h++)c+=t.readInt32LE(i),h+1<d&&(c+=","),i+=4;if(g==="I")if(o==="CG")for(let h=0;h<d;h++){const p=t.readUInt32LE(i),b=p>>4,w=At[p&15];c+=b+w,i+=4}else for(let h=0;h<d;h++)c+=t.readUInt32LE(i),h+1<d&&(c+=","),i+=4;if(g==="s")for(let h=0;h<d;h++)c+=t.readInt16LE(i),h+1<d&&(c+=","),i+=2;if(g==="S")for(let h=0;h<d;h++)c+=t.readUInt16LE(i),h+1<d&&(c+=","),i+=2;if(g==="c")for(let h=0;h<d;h++)c+=t.readInt8(i),h+1<d&&(c+=","),i+=1;if(g==="C")for(let h=0;h<d;h++)c+=t.readUInt8(i),h+1<d&&(c+=","),i+=1;if(g==="f")for(let h=0;h<d;h++)c+=t.readFloatLE(i),h+1<d&&(c+=","),i+=4;break}default:console.warn(`Unknown BAM tag type '${l}', tags may be incomplete`),c=void 0,i=s}if(this._tagOffset=i,this._tagList.push(o),a===e)return c;this.data[a]=c}this._allTagsParsed=!0}_parseAllTags(){this._parseTag("")}_parseCigar(e){return e.match(/\d+\D/g).map(t=>[t.match(/\D/)[0].toUpperCase(),parseInt(t,10)])}isPaired(){return!!(this.flags&ue.BAM_FPAIRED)}isProperlyPaired(){return!!(this.flags&ue.BAM_FPROPER_PAIR)}isSegmentUnmapped(){return!!(this.flags&ue.BAM_FUNMAP)}isMateUnmapped(){return!!(this.flags&ue.BAM_FMUNMAP)}isReverseComplemented(){return!!(this.flags&ue.BAM_FREVERSE)}isMateReverseComplemented(){return!!(this.flags&ue.BAM_FMREVERSE)}isRead1(){return!!(this.flags&ue.BAM_FREAD1)}isRead2(){return!!(this.flags&ue.BAM_FREAD2)}isSecondary(){return!!(this.flags&ue.BAM_FSECONDARY)}isFailedQc(){return!!(this.flags&ue.BAM_FQCFAIL)}isDuplicate(){return!!(this.flags&ue.BAM_FDUP)}isSupplementary(){return!!(this.flags&ue.BAM_FSUPPLEMENTARY)}cigar(){if(this.isSegmentUnmapped())return;const{byteArray:e,start:t}=this.bytes,r=this.get("_n_cigar_op");let i=t+36+this.get("_l_read_name");const s=this.get("seq_length");let a="",o=0,l=e.readInt32LE(i),c=l>>4,f=At[l&15];if(f==="S"&&c===s)return i+=4,l=e.readInt32LE(i),c=l>>4,f=At[l&15],f!=="N"&&console.warn("CG tag with no N tag"),this.data.length_on_ref=c,this.get("CG");for(let g=0;g<r;++g)l=e.readInt32LE(i),c=l>>4,f=At[l&15],a+=c+f,f!=="H"&&f!=="S"&&f!=="I"&&(o+=c),i+=4;return this.data.length_on_ref=o,a}_flags(){}length_on_ref(){return this.data.length_on_ref?this.data.length_on_ref:(this.get("cigar"),this.data.length_on_ref)}_n_cigar_op(){return this.get("_flag_nc")&65535}_l_read_name(){return this.get("_bin_mq_nl")&255}_seq_bytes(){return this.get("seq_length")+1>>1}getReadBases(){return this.seq()}seq(){const{byteArray:e,start:t}=this.bytes,r=t+36+this.get("_l_read_name")+this.get("_n_cigar_op")*4,i=this.get("_seq_bytes"),s=this.get("seq_length");let a="",o=0;for(let l=0;l<i;++l){const c=e[r+l];a+=Fr[(c&240)>>4],o++,o<s&&(a+=Fr[c&15],o++)}return a}getPairOrientation(){if(!this.isSegmentUnmapped()&&!this.isMateUnmapped()&&this._refID===this._next_refid()){const e=this.isReverseComplemented()?"R":"F",t=this.isMateReverseComplemented()?"R":"F";let r=" ",i=" ";this.isRead1()?(r="1",i="2"):this.isRead2()&&(r="2",i="1");const s=[];return this.template_length()>0?(s[0]=e,s[1]=r,s[2]=t,s[3]=i):(s[2]=e,s[3]=r,s[0]=t,s[1]=i),s.join("")}return null}_bin_mq_nl(){return this.bytes.byteArray.readInt32LE(this.bytes.start+12)}_flag_nc(){return this.bytes.byteArray.readInt32LE(this.bytes.start+16)}seq_length(){return this.bytes.byteArray.readInt32LE(this.bytes.start+20)}_next_refid(){return this.bytes.byteArray.readInt32LE(this.bytes.start+24)}_next_pos(){return this.bytes.byteArray.readInt32LE(this.bytes.start+28)}template_length(){return this.bytes.byteArray.readInt32LE(this.bytes.start+32)}toJSON(){const e={};return Object.keys(this).forEach(t=>{t.charAt(0)==="_"||t==="bytes"||(e[t]=this[t])}),e}}function ea(n){const e=n.split(/\r?\n/),t=[];return e.forEach(r=>{const[i,...s]=r.split(/\t/),a=s.map(o=>{const[l,c]=o.split(":",2);return{tag:l,value:c}});i&&t.push({tag:i.substr(1),data:a})}),t}const ta=21840194,Zn=1<<16;function Gn(n){return[].concat(...n)}async function Ef(n){const e=[];for await(const t of n)e.push(t);return e}class Cf{constructor({bamFilehandle:e,bamPath:t,bamUrl:r,baiPath:i,baiFilehandle:s,baiUrl:a,csiPath:o,csiFilehandle:l,csiUrl:c,fetchSizeLimit:f,chunkSizeLimit:g,yieldThreadTime:d=100,renameRefSeqs:h=p=>p}){if(this.featureCache=new De({cache:new Rn({maxSize:50}),fill:async({chunk:p,opts:b},w)=>{const{data:S,cpositions:E,dpositions:v}=await this._readChunk({chunk:p,opts:{...b,signal:w}});return await this.readBamFeatures(S,E,v,p)}}),this.renameRefSeq=h,e)this.bam=e;else if(t)this.bam=new X(t);else if(r)this.bam=new Tt(r);else throw new Error("unable to initialize bam");if(l)this.index=new Vn({filehandle:l});else if(o)this.index=new Vn({filehandle:new X(o)});else if(c)this.index=new Vn({filehandle:new Tt(c)});else if(s)this.index=new It({filehandle:s});else if(i)this.index=new It({filehandle:new X(i)});else if(a)this.index=new It({filehandle:new Tt(a)});else if(t)this.index=new It({filehandle:new X(`${t}.bai`)});else if(r)this.index=new It({filehandle:new Tt(`${r}.bai`)});else throw new Error("unable to infer index format");this.fetchSizeLimit=f||5e8,this.chunkSizeLimit=g||3e8,this.yieldThreadTime=d}async getHeader(e={}){const t=uf(e),r=await this.index.parse(t),i=r.firstDataLine?r.firstDataLine.blockPosition+65535:void 0;let s;if(i){const f=await this.bam.read($.Buffer.alloc(i+Zn),0,i+Zn,0,t),{bytesRead:g}=f;if({buffer:s}=f,!g)throw new Error("Error reading header");g<i?s=s.subarray(0,g):s=s.subarray(0,i)}else s=await this.bam.readFile(t);const a=await Je(s);if(a.readInt32LE(0)!==ta)throw new Error("Not a BAM file");const o=a.readInt32LE(4);this.header=a.toString("utf8",8,8+o);const{chrToIndex:l,indexToChr:c}=await this._readRefSeqs(o+8,65535,t);return this.chrToIndex=l,this.indexToChr=c,ea(this.header)}async getHeaderText(e={}){return await this.getHeader(e),this.header}async _readRefSeqs(e,t,r={}){if(e>t)return this._readRefSeqs(e,t*2,r);const i=t+Zn,{bytesRead:s,buffer:a}=await this.bam.read($.Buffer.alloc(i),0,t,0,r);if(!s)throw new Error("Error reading refseqs from header");const o=await Je(a.subarray(0,Math.min(s,t))),l=o.readInt32LE(e);let c=e+4;const f={},g=[];for(let d=0;d<l;d+=1){const h=o.readInt32LE(c),p=this.renameRefSeq(o.toString("utf8",c+4,c+4+h-1)),b=o.readInt32LE(c+h+4);if(f[p]=d,g.push({refName:p,length:b}),c=c+8+h,c>o.length)return console.warn(`BAM header is very big.  Re-fetching ${t} bytes.`),this._readRefSeqs(e,t*2,r)}return{chrToIndex:f,indexToChr:g}}async getRecordsForRange(e,t,r,i={viewAsPairs:!1,pairAcrossChr:!1,maxInsertSize:2e5}){return Gn(await Ef(this.streamRecordsForRange(e,t,r,i)))}async*streamRecordsForRange(e,t,r,i={}){const{signal:s}=i,a=this.chrToIndex&&this.chrToIndex[e];let o;if(!(a>=0))o=[];else if(o=await this.index.blocksForRange(a,t-1,r,i),!o)throw new Error("Error in index fetch");for(let c=0;c<o.length;c+=1){await js(s);const f=o[c].fetchedSize();if(f>this.chunkSizeLimit)throw new Error(`Too many BAM features. BAM chunk size ${f} bytes exceeds chunkSizeLimit of ${this.chunkSizeLimit}`)}const l=o.map(c=>c.fetchedSize()).reduce((c,f)=>c+f,0);if(l>this.fetchSizeLimit)throw new Error(`data size of ${l.toLocaleString()} bytes exceeded fetch size limit of ${this.fetchSizeLimit.toLocaleString()} bytes`);yield*this._fetchChunkFeatures(o,a,t,r,i)}async*_fetchChunkFeatures(e,t,r,i,s){const{viewAsPairs:a=!1}=s,o=[];let l=!1;for(let c=0;c<e.length;c++){const f=e[c],g=await this.featureCache.get(f.toString(),{chunk:f,opts:s},s.signal),d=[];for(let h=0;h<g.length;h+=1){const p=g[h];if(p.seq_id()===t)if(p.get("start")>=i){l=!0;break}else p.get("end")>=r&&d.push(p)}if(o.push(d),yield d,l)break}Gs(s.signal),a&&(yield this.fetchPairs(t,o,s))}async fetchPairs(e,t,r){const{pairAcrossChr:i=!1,maxInsertSize:s=2e5}=r,a={},o={};t.map(d=>{const h={};for(let p=0;p<d.length;p++){const b=d[p].name(),w=d[p].id();h[b]||(h[b]=0),h[b]++,o[w]=1}Ho(h).forEach(([p,b])=>{b===1&&(a[p]=!0)})});const l=[];t.map(d=>{for(let h=0;h<d.length;h++){const p=d[h],b=p.name(),w=p.get("start"),S=p._next_pos(),E=p._next_refid();a[b]&&(i||E===e&&Math.abs(w-S)<s)&&l.push(this.index.blocksForRange(E,S,S+1,r))}});const c=Gn(await Promise.all(l)).sort().filter((d,h,p)=>!h||d.toString()!==p[h-1].toString()),f=c.map(d=>d.fetchedSize()).reduce((d,h)=>d+h,0);if(f>this.fetchSizeLimit)throw new Error(`data size of ${f.toLocaleString()} bytes exceeded fetch size limit of ${this.fetchSizeLimit.toLocaleString()} bytes`);const g=c.map(async d=>{const{data:h,cpositions:p,dpositions:b,chunk:w}=await this._readChunk({chunk:d,opts:r}),S=await this.readBamFeatures(h,p,b,w),E=[];for(let v=0;v<S.length;v+=1){const _=S[v];a[_.get("name")]&&!o[_.id()]&&E.push(_)}return E});return Gn(await Promise.all(g))}async _readChunk({chunk:e,opts:t}){const r=e.fetchedSize(),{buffer:i,bytesRead:s}=await this.bam.read($.Buffer.alloc(r),0,r,e.minv.blockPosition,t),{buffer:a,cpositions:o,dpositions:l}=await Ws(i.subarray(0,Math.min(s,r)),e);return{data:a,cpositions:o,dpositions:l,chunk:e}}async readBamFeatures(e,t,r,i){let s=0;const a=[];let o=0,l=+Date.now();for(;s+4<e.length;){const c=e.readInt32LE(s),f=s+4+c-1;if(r){for(;s+i.minv.dataPosition>=r[o++];);o--}if(f<e.length){const g=new Sf({bytes:{byteArray:e,start:s,end:f},fileOffset:t?t[o]*256+(s-r[o])+i.minv.dataPosition+1:Is.signed(e.slice(s,f))});a.push(g),this.yieldThreadTime&&+Date.now()-l>this.yieldThreadTime&&(await lf(1),l=+Date.now())}s=f+1}return a}async hasRefSeq(e){const t=this.chrToIndex&&this.chrToIndex[e];return this.index.hasRefSeq(t)}async lineCount(e){const t=this.chrToIndex&&this.chrToIndex[e];return this.index.lineCount(t)}async indexCov(e,t,r){await this.index.parse();const i=this.chrToIndex&&this.chrToIndex[e];return this.index.indexCov(i,t,r)}async blocksForRange(e,t,r,i){await this.index.parse();const s=this.chrToIndex&&this.chrToIndex[e];return this.index.blocksForRange(s,t,r,i)}}async function Tr(n,e){const t=await Promise.all(n.map(async r=>{const{url:i,headers:s}=r;if(i.startsWith("data:"))return $.Buffer.from(i.split(",")[1],"base64");{const{referer:a,...o}=s,l=await fetch(i,{...e,headers:{...e.headers,...o}});if(!l.ok)throw new Error(`Failed to fetch ${l.statusText}`);return $.Buffer.from(await l.arrayBuffer())}}));return $.Buffer.concat(await Promise.all(t.map(r=>Je(r))))}class Hd extends Cf{constructor(e){super({bamFilehandle:"?",baiFilehandle:"?"}),this.baseUrl=e.baseUrl,this.trackId=e.trackId}async*streamRecordsForRange(e,t,r,i={viewAsPairs:!1,pairAcrossChr:!1,maxInsertSize:2e5}){const a=`${`${this.baseUrl}/${this.trackId}`}?referenceName=${e}&start=${t}&end=${r}&format=BAM`,o=this.chrToIndex&&this.chrToIndex[e],l=await fetch(a,{...i});if(!l.ok)throw new Error(l.statusText);const c=await l.json(),g={buffer:await Tr(c.htsget.urls.slice(1),i),chunk:{minv:{dataPosition:0}},toString(){return`${e}_${t}_${r}`}};yield*this._fetchChunkFeatures([g],o,t,r,i)}async _readChunk(e){const{chunk:t}=e,{buffer:r,chunk:i}=t;return{data:r,cpositions:null,dpositions:null,chunk:i}}async getHeader(e={}){const t=`${this.baseUrl}/${this.trackId}?referenceName=na&class=header`,r=await fetch(t,e);if(!r.ok)throw new Error(`Failed to fetch ${r.statusText}`);const i=await r.json(),s=await Tr(i.htsget.urls,e);if(s.readInt32LE(0)!==ta)throw new Error("Not a BAM file");const a=s.readInt32LE(4),o=s.toString("utf8",8,8+a),l=ea(o),c=[],f={};return l.filter(d=>d.tag==="SQ").forEach((d,h)=>{d.data.forEach(p=>{if(p.tag==="SN"){const b=p.value;f[b]=h,c[h]=b}})}),this.chrToIndex=f,this.indexToChr=c,l}}class xf{constructor(e={}){if(!(e.maxSize&&e.maxSize>0))throw new TypeError("`maxSize` must be a number greater than 0");this.maxSize=e.maxSize,this.cache=new Map,this.oldCache=new Map,this._size=0}_set(e,t){this.cache.set(e,t),this._size++,this._size>=this.maxSize&&(this._size=0,this.oldCache=this.cache,this.cache=new Map)}get(e){if(this.cache.has(e))return this.cache.get(e);if(this.oldCache.has(e)){const t=this.oldCache.get(e);return this.oldCache.delete(e),this._set(e,t),t}}set(e,t){return this.cache.has(e)?this.cache.set(e,t):this._set(e,t),this}has(e){return this.cache.has(e)||this.oldCache.has(e)}peek(e){if(this.cache.has(e))return this.cache.get(e);if(this.oldCache.has(e))return this.oldCache.get(e)}delete(e){const t=this.cache.delete(e);return t&&this._size--,this.oldCache.delete(e)||t}clear(){this.cache.clear(),this.oldCache.clear(),this._size=0}*keys(){for(const[e]of this)yield e}*values(){for(const[,e]of this)yield e}*[Symbol.iterator](){for(const e of this.cache)yield e;for(const e of this.oldCache){const[t]=e;this.cache.has(t)||(yield e)}}get size(){let e=0;for(const t of this.oldCache.keys())this.cache.has(t)||e++;return this._size+e}}var na=xf;class Ze{constructor(e,t){this.ranges=arguments.length===2?[{min:e,max:t}]:0 in e?Object.assign({},e):[e]}min(){return this.ranges[0].min}max(){return this.ranges[this.ranges.length-1].max}contains(e){for(let t=0;t<this.ranges.length;t+=1){const r=this.ranges[t];if(r.min<=e&&r.max>=e)return!0}return!1}isContiguous(){return this.ranges.length>1}getRanges(){return this.ranges.map(e=>new Ze(e.min,e.max))}toString(){return this.ranges.map(e=>`[${e.min}-${e.max}]`).join(",")}union(e){const t=this.getRanges().concat(e.getRanges()).sort(this.rangeOrder),r=[];let i=t[0];for(let s=1;s<t.length;s+=1){const a=t[s];a.min()>i.max()+1?(r.push(i),i=a):a.max()>i.max()&&(i=new Ze(i.min(),a.max()))}return r.push(i),r.length===1?r[0]:new Ze(r)}intersection(e){let t=this,r=e;const i=this.ranges(),s=r.ranges(),a=i.length,o=s.length;let l=0,c=0;const f=[];for(;l<a&&c<o;){t=i[l],r=s[c];const g=Math.max(t.min(),r.min()),d=Math.min(t.max(),r.max());d>=g&&f.push(new Ze(g,d)),t.max()>r.max()?c+=1:l+=1}if(f.length===0)throw new Error("found range of length 0");return f.length===1?f[0]:new Ze(f)}coverage(){let e=0;const t=this.ranges();for(let r=0;r<t.length;r+=1){const i=t[r];e+=i.max()-i.min()+1}return e}rangeOrder(e,t){let r=e,i=t;return arguments.length<2&&(i=r,r=this),r.min()<i.min()?-1:r.min()>i.min()?1:r.max()<i.max()?-1:i.max()>r.max()?1:0}}/*! pako 2.0.4 https://github.com/nodeca/pako @license (MIT AND Zlib) */const kf=4,Nr=0,Lr=1,vf=2;function xt(n){let e=n.length;for(;--e>=0;)n[e]=0}const If=0,ia=1,Af=2,Ff=3,Tf=258,Ei=29,Qt=256,Ot=Qt+1+Ei,bt=30,Ci=19,ra=2*Ot+1,nt=15,jn=16,Nf=7,xi=256,sa=16,aa=17,oa=18,pi=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),yn=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),Lf=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),ca=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Bf=512,Be=new Array((Ot+2)*2);xt(Be);const zt=new Array(bt*2);xt(zt);const qt=new Array(Bf);xt(qt);const Ut=new Array(Tf-Ff+1);xt(Ut);const ki=new Array(Ei);xt(ki);const Fn=new Array(bt);xt(Fn);function Kn(n,e,t,r,i){this.static_tree=n,this.extra_bits=e,this.extra_base=t,this.elems=r,this.max_length=i,this.has_stree=n&&n.length}let fa,la,ha;function Wn(n,e){this.dyn_tree=n,this.max_code=0,this.stat_desc=e}const ua=n=>n<256?qt[n]:qt[256+(n>>>7)],Ht=(n,e)=>{n.pending_buf[n.pending++]=e&255,n.pending_buf[n.pending++]=e>>>8&255},fe=(n,e,t)=>{n.bi_valid>jn-t?(n.bi_buf|=e<<n.bi_valid&65535,Ht(n,n.bi_buf),n.bi_buf=e>>jn-n.bi_valid,n.bi_valid+=t-jn):(n.bi_buf|=e<<n.bi_valid&65535,n.bi_valid+=t)},ke=(n,e,t)=>{fe(n,t[e*2],t[e*2+1])},da=(n,e)=>{let t=0;do t|=n&1,n>>>=1,t<<=1;while(--e>0);return t>>>1},Rf=n=>{n.bi_valid===16?(Ht(n,n.bi_buf),n.bi_buf=0,n.bi_valid=0):n.bi_valid>=8&&(n.pending_buf[n.pending++]=n.bi_buf&255,n.bi_buf>>=8,n.bi_valid-=8)},zf=(n,e)=>{const t=e.dyn_tree,r=e.max_code,i=e.stat_desc.static_tree,s=e.stat_desc.has_stree,a=e.stat_desc.extra_bits,o=e.stat_desc.extra_base,l=e.stat_desc.max_length;let c,f,g,d,h,p,b=0;for(d=0;d<=nt;d++)n.bl_count[d]=0;for(t[n.heap[n.heap_max]*2+1]=0,c=n.heap_max+1;c<ra;c++)f=n.heap[c],d=t[t[f*2+1]*2+1]+1,d>l&&(d=l,b++),t[f*2+1]=d,!(f>r)&&(n.bl_count[d]++,h=0,f>=o&&(h=a[f-o]),p=t[f*2],n.opt_len+=p*(d+h),s&&(n.static_len+=p*(i[f*2+1]+h)));if(b!==0){do{for(d=l-1;n.bl_count[d]===0;)d--;n.bl_count[d]--,n.bl_count[d+1]+=2,n.bl_count[l]--,b-=2}while(b>0);for(d=l;d!==0;d--)for(f=n.bl_count[d];f!==0;)g=n.heap[--c],!(g>r)&&(t[g*2+1]!==d&&(n.opt_len+=(d-t[g*2+1])*t[g*2],t[g*2+1]=d),f--)}},ga=(n,e,t)=>{const r=new Array(nt+1);let i=0,s,a;for(s=1;s<=nt;s++)r[s]=i=i+t[s-1]<<1;for(a=0;a<=e;a++){let o=n[a*2+1];o!==0&&(n[a*2]=da(r[o]++,o))}},Pf=()=>{let n,e,t,r,i;const s=new Array(nt+1);for(t=0,r=0;r<Ei-1;r++)for(ki[r]=t,n=0;n<1<<pi[r];n++)Ut[t++]=r;for(Ut[t-1]=r,i=0,r=0;r<16;r++)for(Fn[r]=i,n=0;n<1<<yn[r];n++)qt[i++]=r;for(i>>=7;r<bt;r++)for(Fn[r]=i<<7,n=0;n<1<<yn[r]-7;n++)qt[256+i++]=r;for(e=0;e<=nt;e++)s[e]=0;for(n=0;n<=143;)Be[n*2+1]=8,n++,s[8]++;for(;n<=255;)Be[n*2+1]=9,n++,s[9]++;for(;n<=279;)Be[n*2+1]=7,n++,s[7]++;for(;n<=287;)Be[n*2+1]=8,n++,s[8]++;for(ga(Be,Ot+1,s),n=0;n<bt;n++)zt[n*2+1]=5,zt[n*2]=da(n,5);fa=new Kn(Be,pi,Qt+1,Ot,nt),la=new Kn(zt,yn,0,bt,nt),ha=new Kn(new Array(0),Lf,0,Ci,Nf)},pa=n=>{let e;for(e=0;e<Ot;e++)n.dyn_ltree[e*2]=0;for(e=0;e<bt;e++)n.dyn_dtree[e*2]=0;for(e=0;e<Ci;e++)n.bl_tree[e*2]=0;n.dyn_ltree[xi*2]=1,n.opt_len=n.static_len=0,n.last_lit=n.matches=0},ma=n=>{n.bi_valid>8?Ht(n,n.bi_buf):n.bi_valid>0&&(n.pending_buf[n.pending++]=n.bi_buf),n.bi_buf=0,n.bi_valid=0},Df=(n,e,t,r)=>{ma(n),r&&(Ht(n,t),Ht(n,~t)),n.pending_buf.set(n.window.subarray(e,e+t),n.pending),n.pending+=t},Br=(n,e,t,r)=>{const i=e*2,s=t*2;return n[i]<n[s]||n[i]===n[s]&&r[e]<=r[t]},Qn=(n,e,t)=>{const r=n.heap[t];let i=t<<1;for(;i<=n.heap_len&&(i<n.heap_len&&Br(e,n.heap[i+1],n.heap[i],n.depth)&&i++,!Br(e,r,n.heap[i],n.depth));)n.heap[t]=n.heap[i],t=i,i<<=1;n.heap[t]=r},Rr=(n,e,t)=>{let r,i,s=0,a,o;if(n.last_lit!==0)do r=n.pending_buf[n.d_buf+s*2]<<8|n.pending_buf[n.d_buf+s*2+1],i=n.pending_buf[n.l_buf+s],s++,r===0?ke(n,i,e):(a=Ut[i],ke(n,a+Qt+1,e),o=pi[a],o!==0&&(i-=ki[a],fe(n,i,o)),r--,a=ua(r),ke(n,a,t),o=yn[a],o!==0&&(r-=Fn[a],fe(n,r,o)));while(s<n.last_lit);ke(n,xi,e)},mi=(n,e)=>{const t=e.dyn_tree,r=e.stat_desc.static_tree,i=e.stat_desc.has_stree,s=e.stat_desc.elems;let a,o,l=-1,c;for(n.heap_len=0,n.heap_max=ra,a=0;a<s;a++)t[a*2]!==0?(n.heap[++n.heap_len]=l=a,n.depth[a]=0):t[a*2+1]=0;for(;n.heap_len<2;)c=n.heap[++n.heap_len]=l<2?++l:0,t[c*2]=1,n.depth[c]=0,n.opt_len--,i&&(n.static_len-=r[c*2+1]);for(e.max_code=l,a=n.heap_len>>1;a>=1;a--)Qn(n,t,a);c=s;do a=n.heap[1],n.heap[1]=n.heap[n.heap_len--],Qn(n,t,1),o=n.heap[1],n.heap[--n.heap_max]=a,n.heap[--n.heap_max]=o,t[c*2]=t[a*2]+t[o*2],n.depth[c]=(n.depth[a]>=n.depth[o]?n.depth[a]:n.depth[o])+1,t[a*2+1]=t[o*2+1]=c,n.heap[1]=c++,Qn(n,t,1);while(n.heap_len>=2);n.heap[--n.heap_max]=n.heap[1],zf(n,e),ga(t,l,n.bl_count)},zr=(n,e,t)=>{let r,i=-1,s,a=e[0*2+1],o=0,l=7,c=4;for(a===0&&(l=138,c=3),e[(t+1)*2+1]=65535,r=0;r<=t;r++)s=a,a=e[(r+1)*2+1],!(++o<l&&s===a)&&(o<c?n.bl_tree[s*2]+=o:s!==0?(s!==i&&n.bl_tree[s*2]++,n.bl_tree[sa*2]++):o<=10?n.bl_tree[aa*2]++:n.bl_tree[oa*2]++,o=0,i=s,a===0?(l=138,c=3):s===a?(l=6,c=3):(l=7,c=4))},Pr=(n,e,t)=>{let r,i=-1,s,a=e[0*2+1],o=0,l=7,c=4;for(a===0&&(l=138,c=3),r=0;r<=t;r++)if(s=a,a=e[(r+1)*2+1],!(++o<l&&s===a)){if(o<c)do ke(n,s,n.bl_tree);while(--o!==0);else s!==0?(s!==i&&(ke(n,s,n.bl_tree),o--),ke(n,sa,n.bl_tree),fe(n,o-3,2)):o<=10?(ke(n,aa,n.bl_tree),fe(n,o-3,3)):(ke(n,oa,n.bl_tree),fe(n,o-11,7));o=0,i=s,a===0?(l=138,c=3):s===a?(l=6,c=3):(l=7,c=4)}},Mf=n=>{let e;for(zr(n,n.dyn_ltree,n.l_desc.max_code),zr(n,n.dyn_dtree,n.d_desc.max_code),mi(n,n.bl_desc),e=Ci-1;e>=3&&n.bl_tree[ca[e]*2+1]===0;e--);return n.opt_len+=3*(e+1)+5+5+4,e},$f=(n,e,t,r)=>{let i;for(fe(n,e-257,5),fe(n,t-1,5),fe(n,r-4,4),i=0;i<r;i++)fe(n,n.bl_tree[ca[i]*2+1],3);Pr(n,n.dyn_ltree,e-1),Pr(n,n.dyn_dtree,t-1)},Of=n=>{let e=4093624447,t;for(t=0;t<=31;t++,e>>>=1)if(e&1&&n.dyn_ltree[t*2]!==0)return Nr;if(n.dyn_ltree[9*2]!==0||n.dyn_ltree[10*2]!==0||n.dyn_ltree[13*2]!==0)return Lr;for(t=32;t<Qt;t++)if(n.dyn_ltree[t*2]!==0)return Lr;return Nr};let Dr=!1;const qf=n=>{Dr||(Pf(),Dr=!0),n.l_desc=new Wn(n.dyn_ltree,fa),n.d_desc=new Wn(n.dyn_dtree,la),n.bl_desc=new Wn(n.bl_tree,ha),n.bi_buf=0,n.bi_valid=0,pa(n)},_a=(n,e,t,r)=>{fe(n,(If<<1)+(r?1:0),3),Df(n,e,t,!0)},Uf=n=>{fe(n,ia<<1,3),ke(n,xi,Be),Rf(n)},Hf=(n,e,t,r)=>{let i,s,a=0;n.level>0?(n.strm.data_type===vf&&(n.strm.data_type=Of(n)),mi(n,n.l_desc),mi(n,n.d_desc),a=Mf(n),i=n.opt_len+3+7>>>3,s=n.static_len+3+7>>>3,s<=i&&(i=s)):i=s=t+5,t+4<=i&&e!==-1?_a(n,e,t,r):n.strategy===kf||s===i?(fe(n,(ia<<1)+(r?1:0),3),Rr(n,Be,zt)):(fe(n,(Af<<1)+(r?1:0),3),$f(n,n.l_desc.max_code+1,n.d_desc.max_code+1,a+1),Rr(n,n.dyn_ltree,n.dyn_dtree)),pa(n),r&&ma(n)},Vf=(n,e,t)=>(n.pending_buf[n.d_buf+n.last_lit*2]=e>>>8&255,n.pending_buf[n.d_buf+n.last_lit*2+1]=e&255,n.pending_buf[n.l_buf+n.last_lit]=t&255,n.last_lit++,e===0?n.dyn_ltree[t*2]++:(n.matches++,e--,n.dyn_ltree[(Ut[t]+Qt+1)*2]++,n.dyn_dtree[ua(e)*2]++),n.last_lit===n.lit_bufsize-1);var Zf=qf,Gf=_a,jf=Hf,Kf=Vf,Wf=Uf,Qf={_tr_init:Zf,_tr_stored_block:Gf,_tr_flush_block:jf,_tr_tally:Kf,_tr_align:Wf};const Yf=(n,e,t,r)=>{let i=n&65535|0,s=n>>>16&65535|0,a=0;for(;t!==0;){a=t>2e3?2e3:t,t-=a;do i=i+e[r++]|0,s=s+i|0;while(--a);i%=65521,s%=65521}return i|s<<16|0};var Vt=Yf;const Xf=()=>{let n,e=[];for(var t=0;t<256;t++){n=t;for(var r=0;r<8;r++)n=n&1?3988292384^n>>>1:n>>>1;e[t]=n}return e},Jf=new Uint32Array(Xf()),el=(n,e,t,r)=>{const i=Jf,s=r+t;n^=-1;for(let a=r;a<s;a++)n=n>>>8^i[(n^e[a])&255];return n^-1};var ne=el,St={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},Yt={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8};const{_tr_init:tl,_tr_stored_block:nl,_tr_flush_block:il,_tr_tally:We,_tr_align:rl}=Qf,{Z_NO_FLUSH:lt,Z_PARTIAL_FLUSH:sl,Z_FULL_FLUSH:al,Z_FINISH:Qe,Z_BLOCK:Mr,Z_OK:ve,Z_STREAM_END:$r,Z_STREAM_ERROR:pe,Z_DATA_ERROR:ol,Z_BUF_ERROR:Yn,Z_DEFAULT_COMPRESSION:cl,Z_FILTERED:fl,Z_HUFFMAN_ONLY:hn,Z_RLE:ll,Z_FIXED:hl,Z_DEFAULT_STRATEGY:ul,Z_UNKNOWN:dl,Z_DEFLATED:Pn}=Yt,gl=9,pl=15,ml=8,_l=29,bl=256,_i=bl+1+_l,wl=30,yl=19,Sl=2*_i+1,El=15,q=3,je=258,Se=je+q+1,Cl=32,Dn=42,bi=69,Sn=73,En=91,Cn=103,it=113,Nt=666,te=1,Xt=2,st=3,kt=4,xl=3,Ke=(n,e)=>(n.msg=St[e],e),Or=n=>(n<<1)-(n>4?9:0),Ge=n=>{let e=n.length;for(;--e>=0;)n[e]=0};let kl=(n,e,t)=>(e<<n.hash_shift^t)&n.hash_mask,Ye=kl;const He=n=>{const e=n.state;let t=e.pending;t>n.avail_out&&(t=n.avail_out),t!==0&&(n.output.set(e.pending_buf.subarray(e.pending_out,e.pending_out+t),n.next_out),n.next_out+=t,e.pending_out+=t,n.total_out+=t,n.avail_out-=t,e.pending-=t,e.pending===0&&(e.pending_out=0))},re=(n,e)=>{il(n,n.block_start>=0?n.block_start:-1,n.strstart-n.block_start,e),n.block_start=n.strstart,He(n.strm)},V=(n,e)=>{n.pending_buf[n.pending++]=e},Ft=(n,e)=>{n.pending_buf[n.pending++]=e>>>8&255,n.pending_buf[n.pending++]=e&255},vl=(n,e,t,r)=>{let i=n.avail_in;return i>r&&(i=r),i===0?0:(n.avail_in-=i,e.set(n.input.subarray(n.next_in,n.next_in+i),t),n.state.wrap===1?n.adler=Vt(n.adler,e,i,t):n.state.wrap===2&&(n.adler=ne(n.adler,e,i,t)),n.next_in+=i,n.total_in+=i,i)},ba=(n,e)=>{let t=n.max_chain_length,r=n.strstart,i,s,a=n.prev_length,o=n.nice_match;const l=n.strstart>n.w_size-Se?n.strstart-(n.w_size-Se):0,c=n.window,f=n.w_mask,g=n.prev,d=n.strstart+je;let h=c[r+a-1],p=c[r+a];n.prev_length>=n.good_match&&(t>>=2),o>n.lookahead&&(o=n.lookahead);do if(i=e,!(c[i+a]!==p||c[i+a-1]!==h||c[i]!==c[r]||c[++i]!==c[r+1])){r+=2,i++;do;while(c[++r]===c[++i]&&c[++r]===c[++i]&&c[++r]===c[++i]&&c[++r]===c[++i]&&c[++r]===c[++i]&&c[++r]===c[++i]&&c[++r]===c[++i]&&c[++r]===c[++i]&&r<d);if(s=je-(d-r),r=d-je,s>a){if(n.match_start=e,a=s,s>=o)break;h=c[r+a-1],p=c[r+a]}}while((e=g[e&f])>l&&--t!==0);return a<=n.lookahead?a:n.lookahead},at=n=>{const e=n.w_size;let t,r,i,s,a;do{if(s=n.window_size-n.lookahead-n.strstart,n.strstart>=e+(e-Se)){n.window.set(n.window.subarray(e,e+e),0),n.match_start-=e,n.strstart-=e,n.block_start-=e,r=n.hash_size,t=r;do i=n.head[--t],n.head[t]=i>=e?i-e:0;while(--r);r=e,t=r;do i=n.prev[--t],n.prev[t]=i>=e?i-e:0;while(--r);s+=e}if(n.strm.avail_in===0)break;if(r=vl(n.strm,n.window,n.strstart+n.lookahead,s),n.lookahead+=r,n.lookahead+n.insert>=q)for(a=n.strstart-n.insert,n.ins_h=n.window[a],n.ins_h=Ye(n,n.ins_h,n.window[a+1]);n.insert&&(n.ins_h=Ye(n,n.ins_h,n.window[a+q-1]),n.prev[a&n.w_mask]=n.head[n.ins_h],n.head[n.ins_h]=a,a++,n.insert--,!(n.lookahead+n.insert<q)););}while(n.lookahead<Se&&n.strm.avail_in!==0)},Il=(n,e)=>{let t=65535;for(t>n.pending_buf_size-5&&(t=n.pending_buf_size-5);;){if(n.lookahead<=1){if(at(n),n.lookahead===0&&e===lt)return te;if(n.lookahead===0)break}n.strstart+=n.lookahead,n.lookahead=0;const r=n.block_start+t;if((n.strstart===0||n.strstart>=r)&&(n.lookahead=n.strstart-r,n.strstart=r,re(n,!1),n.strm.avail_out===0)||n.strstart-n.block_start>=n.w_size-Se&&(re(n,!1),n.strm.avail_out===0))return te}return n.insert=0,e===Qe?(re(n,!0),n.strm.avail_out===0?st:kt):(n.strstart>n.block_start&&(re(n,!1),n.strm.avail_out===0),te)},Xn=(n,e)=>{let t,r;for(;;){if(n.lookahead<Se){if(at(n),n.lookahead<Se&&e===lt)return te;if(n.lookahead===0)break}if(t=0,n.lookahead>=q&&(n.ins_h=Ye(n,n.ins_h,n.window[n.strstart+q-1]),t=n.prev[n.strstart&n.w_mask]=n.head[n.ins_h],n.head[n.ins_h]=n.strstart),t!==0&&n.strstart-t<=n.w_size-Se&&(n.match_length=ba(n,t)),n.match_length>=q)if(r=We(n,n.strstart-n.match_start,n.match_length-q),n.lookahead-=n.match_length,n.match_length<=n.max_lazy_match&&n.lookahead>=q){n.match_length--;do n.strstart++,n.ins_h=Ye(n,n.ins_h,n.window[n.strstart+q-1]),t=n.prev[n.strstart&n.w_mask]=n.head[n.ins_h],n.head[n.ins_h]=n.strstart;while(--n.match_length!==0);n.strstart++}else n.strstart+=n.match_length,n.match_length=0,n.ins_h=n.window[n.strstart],n.ins_h=Ye(n,n.ins_h,n.window[n.strstart+1]);else r=We(n,0,n.window[n.strstart]),n.lookahead--,n.strstart++;if(r&&(re(n,!1),n.strm.avail_out===0))return te}return n.insert=n.strstart<q-1?n.strstart:q-1,e===Qe?(re(n,!0),n.strm.avail_out===0?st:kt):n.last_lit&&(re(n,!1),n.strm.avail_out===0)?te:Xt},dt=(n,e)=>{let t,r,i;for(;;){if(n.lookahead<Se){if(at(n),n.lookahead<Se&&e===lt)return te;if(n.lookahead===0)break}if(t=0,n.lookahead>=q&&(n.ins_h=Ye(n,n.ins_h,n.window[n.strstart+q-1]),t=n.prev[n.strstart&n.w_mask]=n.head[n.ins_h],n.head[n.ins_h]=n.strstart),n.prev_length=n.match_length,n.prev_match=n.match_start,n.match_length=q-1,t!==0&&n.prev_length<n.max_lazy_match&&n.strstart-t<=n.w_size-Se&&(n.match_length=ba(n,t),n.match_length<=5&&(n.strategy===fl||n.match_length===q&&n.strstart-n.match_start>4096)&&(n.match_length=q-1)),n.prev_length>=q&&n.match_length<=n.prev_length){i=n.strstart+n.lookahead-q,r=We(n,n.strstart-1-n.prev_match,n.prev_length-q),n.lookahead-=n.prev_length-1,n.prev_length-=2;do++n.strstart<=i&&(n.ins_h=Ye(n,n.ins_h,n.window[n.strstart+q-1]),t=n.prev[n.strstart&n.w_mask]=n.head[n.ins_h],n.head[n.ins_h]=n.strstart);while(--n.prev_length!==0);if(n.match_available=0,n.match_length=q-1,n.strstart++,r&&(re(n,!1),n.strm.avail_out===0))return te}else if(n.match_available){if(r=We(n,0,n.window[n.strstart-1]),r&&re(n,!1),n.strstart++,n.lookahead--,n.strm.avail_out===0)return te}else n.match_available=1,n.strstart++,n.lookahead--}return n.match_available&&(r=We(n,0,n.window[n.strstart-1]),n.match_available=0),n.insert=n.strstart<q-1?n.strstart:q-1,e===Qe?(re(n,!0),n.strm.avail_out===0?st:kt):n.last_lit&&(re(n,!1),n.strm.avail_out===0)?te:Xt},Al=(n,e)=>{let t,r,i,s;const a=n.window;for(;;){if(n.lookahead<=je){if(at(n),n.lookahead<=je&&e===lt)return te;if(n.lookahead===0)break}if(n.match_length=0,n.lookahead>=q&&n.strstart>0&&(i=n.strstart-1,r=a[i],r===a[++i]&&r===a[++i]&&r===a[++i])){s=n.strstart+je;do;while(r===a[++i]&&r===a[++i]&&r===a[++i]&&r===a[++i]&&r===a[++i]&&r===a[++i]&&r===a[++i]&&r===a[++i]&&i<s);n.match_length=je-(s-i),n.match_length>n.lookahead&&(n.match_length=n.lookahead)}if(n.match_length>=q?(t=We(n,1,n.match_length-q),n.lookahead-=n.match_length,n.strstart+=n.match_length,n.match_length=0):(t=We(n,0,n.window[n.strstart]),n.lookahead--,n.strstart++),t&&(re(n,!1),n.strm.avail_out===0))return te}return n.insert=0,e===Qe?(re(n,!0),n.strm.avail_out===0?st:kt):n.last_lit&&(re(n,!1),n.strm.avail_out===0)?te:Xt},Fl=(n,e)=>{let t;for(;;){if(n.lookahead===0&&(at(n),n.lookahead===0)){if(e===lt)return te;break}if(n.match_length=0,t=We(n,0,n.window[n.strstart]),n.lookahead--,n.strstart++,t&&(re(n,!1),n.strm.avail_out===0))return te}return n.insert=0,e===Qe?(re(n,!0),n.strm.avail_out===0?st:kt):n.last_lit&&(re(n,!1),n.strm.avail_out===0)?te:Xt};function xe(n,e,t,r,i){this.good_length=n,this.max_lazy=e,this.nice_length=t,this.max_chain=r,this.func=i}const Lt=[new xe(0,0,0,0,Il),new xe(4,4,8,4,Xn),new xe(4,5,16,8,Xn),new xe(4,6,32,32,Xn),new xe(4,4,16,16,dt),new xe(8,16,32,32,dt),new xe(8,16,128,128,dt),new xe(8,32,128,256,dt),new xe(32,128,258,1024,dt),new xe(32,258,258,4096,dt)],Tl=n=>{n.window_size=2*n.w_size,Ge(n.head),n.max_lazy_match=Lt[n.level].max_lazy,n.good_match=Lt[n.level].good_length,n.nice_match=Lt[n.level].nice_length,n.max_chain_length=Lt[n.level].max_chain,n.strstart=0,n.block_start=0,n.lookahead=0,n.insert=0,n.match_length=n.prev_length=q-1,n.match_available=0,n.ins_h=0};function Nl(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=Pn,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(Sl*2),this.dyn_dtree=new Uint16Array((2*wl+1)*2),this.bl_tree=new Uint16Array((2*yl+1)*2),Ge(this.dyn_ltree),Ge(this.dyn_dtree),Ge(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(El+1),this.heap=new Uint16Array(2*_i+1),Ge(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(2*_i+1),Ge(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}const wa=n=>{if(!n||!n.state)return Ke(n,pe);n.total_in=n.total_out=0,n.data_type=dl;const e=n.state;return e.pending=0,e.pending_out=0,e.wrap<0&&(e.wrap=-e.wrap),e.status=e.wrap?Dn:it,n.adler=e.wrap===2?0:1,e.last_flush=lt,tl(e),ve},ya=n=>{const e=wa(n);return e===ve&&Tl(n.state),e},Ll=(n,e)=>!n||!n.state||n.state.wrap!==2?pe:(n.state.gzhead=e,ve),Sa=(n,e,t,r,i,s)=>{if(!n)return pe;let a=1;if(e===cl&&(e=6),r<0?(a=0,r=-r):r>15&&(a=2,r-=16),i<1||i>gl||t!==Pn||r<8||r>15||e<0||e>9||s<0||s>hl)return Ke(n,pe);r===8&&(r=9);const o=new Nl;return n.state=o,o.strm=n,o.wrap=a,o.gzhead=null,o.w_bits=r,o.w_size=1<<o.w_bits,o.w_mask=o.w_size-1,o.hash_bits=i+7,o.hash_size=1<<o.hash_bits,o.hash_mask=o.hash_size-1,o.hash_shift=~~((o.hash_bits+q-1)/q),o.window=new Uint8Array(o.w_size*2),o.head=new Uint16Array(o.hash_size),o.prev=new Uint16Array(o.w_size),o.lit_bufsize=1<<i+6,o.pending_buf_size=o.lit_bufsize*4,o.pending_buf=new Uint8Array(o.pending_buf_size),o.d_buf=1*o.lit_bufsize,o.l_buf=(1+2)*o.lit_bufsize,o.level=e,o.strategy=s,o.method=t,ya(n)},Bl=(n,e)=>Sa(n,e,Pn,pl,ml,ul),Rl=(n,e)=>{let t,r;if(!n||!n.state||e>Mr||e<0)return n?Ke(n,pe):pe;const i=n.state;if(!n.output||!n.input&&n.avail_in!==0||i.status===Nt&&e!==Qe)return Ke(n,n.avail_out===0?Yn:pe);i.strm=n;const s=i.last_flush;if(i.last_flush=e,i.status===Dn)if(i.wrap===2)n.adler=0,V(i,31),V(i,139),V(i,8),i.gzhead?(V(i,(i.gzhead.text?1:0)+(i.gzhead.hcrc?2:0)+(i.gzhead.extra?4:0)+(i.gzhead.name?8:0)+(i.gzhead.comment?16:0)),V(i,i.gzhead.time&255),V(i,i.gzhead.time>>8&255),V(i,i.gzhead.time>>16&255),V(i,i.gzhead.time>>24&255),V(i,i.level===9?2:i.strategy>=hn||i.level<2?4:0),V(i,i.gzhead.os&255),i.gzhead.extra&&i.gzhead.extra.length&&(V(i,i.gzhead.extra.length&255),V(i,i.gzhead.extra.length>>8&255)),i.gzhead.hcrc&&(n.adler=ne(n.adler,i.pending_buf,i.pending,0)),i.gzindex=0,i.status=bi):(V(i,0),V(i,0),V(i,0),V(i,0),V(i,0),V(i,i.level===9?2:i.strategy>=hn||i.level<2?4:0),V(i,xl),i.status=it);else{let a=Pn+(i.w_bits-8<<4)<<8,o=-1;i.strategy>=hn||i.level<2?o=0:i.level<6?o=1:i.level===6?o=2:o=3,a|=o<<6,i.strstart!==0&&(a|=Cl),a+=31-a%31,i.status=it,Ft(i,a),i.strstart!==0&&(Ft(i,n.adler>>>16),Ft(i,n.adler&65535)),n.adler=1}if(i.status===bi)if(i.gzhead.extra){for(t=i.pending;i.gzindex<(i.gzhead.extra.length&65535)&&!(i.pending===i.pending_buf_size&&(i.gzhead.hcrc&&i.pending>t&&(n.adler=ne(n.adler,i.pending_buf,i.pending-t,t)),He(n),t=i.pending,i.pending===i.pending_buf_size));)V(i,i.gzhead.extra[i.gzindex]&255),i.gzindex++;i.gzhead.hcrc&&i.pending>t&&(n.adler=ne(n.adler,i.pending_buf,i.pending-t,t)),i.gzindex===i.gzhead.extra.length&&(i.gzindex=0,i.status=Sn)}else i.status=Sn;if(i.status===Sn)if(i.gzhead.name){t=i.pending;do{if(i.pending===i.pending_buf_size&&(i.gzhead.hcrc&&i.pending>t&&(n.adler=ne(n.adler,i.pending_buf,i.pending-t,t)),He(n),t=i.pending,i.pending===i.pending_buf_size)){r=1;break}i.gzindex<i.gzhead.name.length?r=i.gzhead.name.charCodeAt(i.gzindex++)&255:r=0,V(i,r)}while(r!==0);i.gzhead.hcrc&&i.pending>t&&(n.adler=ne(n.adler,i.pending_buf,i.pending-t,t)),r===0&&(i.gzindex=0,i.status=En)}else i.status=En;if(i.status===En)if(i.gzhead.comment){t=i.pending;do{if(i.pending===i.pending_buf_size&&(i.gzhead.hcrc&&i.pending>t&&(n.adler=ne(n.adler,i.pending_buf,i.pending-t,t)),He(n),t=i.pending,i.pending===i.pending_buf_size)){r=1;break}i.gzindex<i.gzhead.comment.length?r=i.gzhead.comment.charCodeAt(i.gzindex++)&255:r=0,V(i,r)}while(r!==0);i.gzhead.hcrc&&i.pending>t&&(n.adler=ne(n.adler,i.pending_buf,i.pending-t,t)),r===0&&(i.status=Cn)}else i.status=Cn;if(i.status===Cn&&(i.gzhead.hcrc?(i.pending+2>i.pending_buf_size&&He(n),i.pending+2<=i.pending_buf_size&&(V(i,n.adler&255),V(i,n.adler>>8&255),n.adler=0,i.status=it)):i.status=it),i.pending!==0){if(He(n),n.avail_out===0)return i.last_flush=-1,ve}else if(n.avail_in===0&&Or(e)<=Or(s)&&e!==Qe)return Ke(n,Yn);if(i.status===Nt&&n.avail_in!==0)return Ke(n,Yn);if(n.avail_in!==0||i.lookahead!==0||e!==lt&&i.status!==Nt){let a=i.strategy===hn?Fl(i,e):i.strategy===ll?Al(i,e):Lt[i.level].func(i,e);if((a===st||a===kt)&&(i.status=Nt),a===te||a===st)return n.avail_out===0&&(i.last_flush=-1),ve;if(a===Xt&&(e===sl?rl(i):e!==Mr&&(nl(i,0,0,!1),e===al&&(Ge(i.head),i.lookahead===0&&(i.strstart=0,i.block_start=0,i.insert=0))),He(n),n.avail_out===0))return i.last_flush=-1,ve}return e!==Qe?ve:i.wrap<=0?$r:(i.wrap===2?(V(i,n.adler&255),V(i,n.adler>>8&255),V(i,n.adler>>16&255),V(i,n.adler>>24&255),V(i,n.total_in&255),V(i,n.total_in>>8&255),V(i,n.total_in>>16&255),V(i,n.total_in>>24&255)):(Ft(i,n.adler>>>16),Ft(i,n.adler&65535)),He(n),i.wrap>0&&(i.wrap=-i.wrap),i.pending!==0?ve:$r)},zl=n=>{if(!n||!n.state)return pe;const e=n.state.status;return e!==Dn&&e!==bi&&e!==Sn&&e!==En&&e!==Cn&&e!==it&&e!==Nt?Ke(n,pe):(n.state=null,e===it?Ke(n,ol):ve)},Pl=(n,e)=>{let t=e.length;if(!n||!n.state)return pe;const r=n.state,i=r.wrap;if(i===2||i===1&&r.status!==Dn||r.lookahead)return pe;if(i===1&&(n.adler=Vt(n.adler,e,t,0)),r.wrap=0,t>=r.w_size){i===0&&(Ge(r.head),r.strstart=0,r.block_start=0,r.insert=0);let l=new Uint8Array(r.w_size);l.set(e.subarray(t-r.w_size,t),0),e=l,t=r.w_size}const s=n.avail_in,a=n.next_in,o=n.input;for(n.avail_in=t,n.next_in=0,n.input=e,at(r);r.lookahead>=q;){let l=r.strstart,c=r.lookahead-(q-1);do r.ins_h=Ye(r,r.ins_h,r.window[l+q-1]),r.prev[l&r.w_mask]=r.head[r.ins_h],r.head[r.ins_h]=l,l++;while(--c);r.strstart=l,r.lookahead=q-1,at(r)}return r.strstart+=r.lookahead,r.block_start=r.strstart,r.insert=r.lookahead,r.lookahead=0,r.match_length=r.prev_length=q-1,r.match_available=0,n.next_in=a,n.input=o,n.avail_in=s,r.wrap=i,ve};var Dl=Bl,Ml=Sa,$l=ya,Ol=wa,ql=Ll,Ul=Rl,Hl=zl,Vl=Pl,Zl="pako deflate (from Nodeca project)",Pt={deflateInit:Dl,deflateInit2:Ml,deflateReset:$l,deflateResetKeep:Ol,deflateSetHeader:ql,deflate:Ul,deflateEnd:Hl,deflateSetDictionary:Vl,deflateInfo:Zl};const Gl=(n,e)=>Object.prototype.hasOwnProperty.call(n,e);var jl=function(n){const e=Array.prototype.slice.call(arguments,1);for(;e.length;){const t=e.shift();if(!!t){if(typeof t!="object")throw new TypeError(t+"must be non-object");for(const r in t)Gl(t,r)&&(n[r]=t[r])}}return n},Kl=n=>{let e=0;for(let r=0,i=n.length;r<i;r++)e+=n[r].length;const t=new Uint8Array(e);for(let r=0,i=0,s=n.length;r<s;r++){let a=n[r];t.set(a,i),i+=a.length}return t},Mn={assign:jl,flattenChunks:Kl};let Ea=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch{Ea=!1}const Zt=new Uint8Array(256);for(let n=0;n<256;n++)Zt[n]=n>=252?6:n>=248?5:n>=240?4:n>=224?3:n>=192?2:1;Zt[254]=Zt[254]=1;var Wl=n=>{if(typeof TextEncoder=="function"&&TextEncoder.prototype.encode)return new TextEncoder().encode(n);let e,t,r,i,s,a=n.length,o=0;for(i=0;i<a;i++)t=n.charCodeAt(i),(t&64512)===55296&&i+1<a&&(r=n.charCodeAt(i+1),(r&64512)===56320&&(t=65536+(t-55296<<10)+(r-56320),i++)),o+=t<128?1:t<2048?2:t<65536?3:4;for(e=new Uint8Array(o),s=0,i=0;s<o;i++)t=n.charCodeAt(i),(t&64512)===55296&&i+1<a&&(r=n.charCodeAt(i+1),(r&64512)===56320&&(t=65536+(t-55296<<10)+(r-56320),i++)),t<128?e[s++]=t:t<2048?(e[s++]=192|t>>>6,e[s++]=128|t&63):t<65536?(e[s++]=224|t>>>12,e[s++]=128|t>>>6&63,e[s++]=128|t&63):(e[s++]=240|t>>>18,e[s++]=128|t>>>12&63,e[s++]=128|t>>>6&63,e[s++]=128|t&63);return e};const Ql=(n,e)=>{if(e<65534&&n.subarray&&Ea)return String.fromCharCode.apply(null,n.length===e?n:n.subarray(0,e));let t="";for(let r=0;r<e;r++)t+=String.fromCharCode(n[r]);return t};var Yl=(n,e)=>{const t=e||n.length;if(typeof TextDecoder=="function"&&TextDecoder.prototype.decode)return new TextDecoder().decode(n.subarray(0,e));let r,i;const s=new Array(t*2);for(i=0,r=0;r<t;){let a=n[r++];if(a<128){s[i++]=a;continue}let o=Zt[a];if(o>4){s[i++]=65533,r+=o-1;continue}for(a&=o===2?31:o===3?15:7;o>1&&r<t;)a=a<<6|n[r++]&63,o--;if(o>1){s[i++]=65533;continue}a<65536?s[i++]=a:(a-=65536,s[i++]=55296|a>>10&1023,s[i++]=56320|a&1023)}return Ql(s,i)},Xl=(n,e)=>{e=e||n.length,e>n.length&&(e=n.length);let t=e-1;for(;t>=0&&(n[t]&192)===128;)t--;return t<0||t===0?e:t+Zt[n[t]]>e?t:e},Gt={string2buf:Wl,buf2string:Yl,utf8border:Xl};function Jl(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}var Ca=Jl;const xa=Object.prototype.toString,{Z_NO_FLUSH:eh,Z_SYNC_FLUSH:th,Z_FULL_FLUSH:nh,Z_FINISH:ih,Z_OK:Tn,Z_STREAM_END:rh,Z_DEFAULT_COMPRESSION:sh,Z_DEFAULT_STRATEGY:ah,Z_DEFLATED:oh}=Yt;function vi(n){this.options=Mn.assign({level:sh,method:oh,chunkSize:16384,windowBits:15,memLevel:8,strategy:ah},n||{});let e=this.options;e.raw&&e.windowBits>0?e.windowBits=-e.windowBits:e.gzip&&e.windowBits>0&&e.windowBits<16&&(e.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new Ca,this.strm.avail_out=0;let t=Pt.deflateInit2(this.strm,e.level,e.method,e.windowBits,e.memLevel,e.strategy);if(t!==Tn)throw new Error(St[t]);if(e.header&&Pt.deflateSetHeader(this.strm,e.header),e.dictionary){let r;if(typeof e.dictionary=="string"?r=Gt.string2buf(e.dictionary):xa.call(e.dictionary)==="[object ArrayBuffer]"?r=new Uint8Array(e.dictionary):r=e.dictionary,t=Pt.deflateSetDictionary(this.strm,r),t!==Tn)throw new Error(St[t]);this._dict_set=!0}}vi.prototype.push=function(n,e){const t=this.strm,r=this.options.chunkSize;let i,s;if(this.ended)return!1;for(e===~~e?s=e:s=e===!0?ih:eh,typeof n=="string"?t.input=Gt.string2buf(n):xa.call(n)==="[object ArrayBuffer]"?t.input=new Uint8Array(n):t.input=n,t.next_in=0,t.avail_in=t.input.length;;){if(t.avail_out===0&&(t.output=new Uint8Array(r),t.next_out=0,t.avail_out=r),(s===th||s===nh)&&t.avail_out<=6){this.onData(t.output.subarray(0,t.next_out)),t.avail_out=0;continue}if(i=Pt.deflate(t,s),i===rh)return t.next_out>0&&this.onData(t.output.subarray(0,t.next_out)),i=Pt.deflateEnd(this.strm),this.onEnd(i),this.ended=!0,i===Tn;if(t.avail_out===0){this.onData(t.output);continue}if(s>0&&t.next_out>0){this.onData(t.output.subarray(0,t.next_out)),t.avail_out=0;continue}if(t.avail_in===0)break}return!0};vi.prototype.onData=function(n){this.chunks.push(n)};vi.prototype.onEnd=function(n){n===Tn&&(this.result=Mn.flattenChunks(this.chunks)),this.chunks=[],this.err=n,this.msg=this.strm.msg};const un=30,ch=12;var fh=function(e,t){let r,i,s,a,o,l,c,f,g,d,h,p,b,w,S,E,v,_,k,I,C,T,N,L;const P=e.state;r=e.next_in,N=e.input,i=r+(e.avail_in-5),s=e.next_out,L=e.output,a=s-(t-e.avail_out),o=s+(e.avail_out-257),l=P.dmax,c=P.wsize,f=P.whave,g=P.wnext,d=P.window,h=P.hold,p=P.bits,b=P.lencode,w=P.distcode,S=(1<<P.lenbits)-1,E=(1<<P.distbits)-1;e:do{p<15&&(h+=N[r++]<<p,p+=8,h+=N[r++]<<p,p+=8),v=b[h&S];t:for(;;){if(_=v>>>24,h>>>=_,p-=_,_=v>>>16&255,_===0)L[s++]=v&65535;else if(_&16){k=v&65535,_&=15,_&&(p<_&&(h+=N[r++]<<p,p+=8),k+=h&(1<<_)-1,h>>>=_,p-=_),p<15&&(h+=N[r++]<<p,p+=8,h+=N[r++]<<p,p+=8),v=w[h&E];n:for(;;){if(_=v>>>24,h>>>=_,p-=_,_=v>>>16&255,_&16){if(I=v&65535,_&=15,p<_&&(h+=N[r++]<<p,p+=8,p<_&&(h+=N[r++]<<p,p+=8)),I+=h&(1<<_)-1,I>l){e.msg="invalid distance too far back",P.mode=un;break e}if(h>>>=_,p-=_,_=s-a,I>_){if(_=I-_,_>f&&P.sane){e.msg="invalid distance too far back",P.mode=un;break e}if(C=0,T=d,g===0){if(C+=c-_,_<k){k-=_;do L[s++]=d[C++];while(--_);C=s-I,T=L}}else if(g<_){if(C+=c+g-_,_-=g,_<k){k-=_;do L[s++]=d[C++];while(--_);if(C=0,g<k){_=g,k-=_;do L[s++]=d[C++];while(--_);C=s-I,T=L}}}else if(C+=g-_,_<k){k-=_;do L[s++]=d[C++];while(--_);C=s-I,T=L}for(;k>2;)L[s++]=T[C++],L[s++]=T[C++],L[s++]=T[C++],k-=3;k&&(L[s++]=T[C++],k>1&&(L[s++]=T[C++]))}else{C=s-I;do L[s++]=L[C++],L[s++]=L[C++],L[s++]=L[C++],k-=3;while(k>2);k&&(L[s++]=L[C++],k>1&&(L[s++]=L[C++]))}}else if((_&64)===0){v=w[(v&65535)+(h&(1<<_)-1)];continue n}else{e.msg="invalid distance code",P.mode=un;break e}break}}else if((_&64)===0){v=b[(v&65535)+(h&(1<<_)-1)];continue t}else if(_&32){P.mode=ch;break e}else{e.msg="invalid literal/length code",P.mode=un;break e}break}}while(r<i&&s<o);k=p>>3,r-=k,p-=k<<3,h&=(1<<p)-1,e.next_in=r,e.next_out=s,e.avail_in=r<i?5+(i-r):5-(r-i),e.avail_out=s<o?257+(o-s):257-(s-o),P.hold=h,P.bits=p};const gt=15,qr=852,Ur=592,Hr=0,Jn=1,Vr=2,lh=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),hh=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),uh=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),dh=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),gh=(n,e,t,r,i,s,a,o)=>{const l=o.bits;let c=0,f=0,g=0,d=0,h=0,p=0,b=0,w=0,S=0,E=0,v,_,k,I,C,T=null,N=0,L;const P=new Uint16Array(gt+1),ie=new Uint16Array(gt+1);let _e=null,Me=0,tt,$e,ht;for(c=0;c<=gt;c++)P[c]=0;for(f=0;f<r;f++)P[e[t+f]]++;for(h=l,d=gt;d>=1&&P[d]===0;d--);if(h>d&&(h=d),d===0)return i[s++]=1<<24|64<<16|0,i[s++]=1<<24|64<<16|0,o.bits=1,0;for(g=1;g<d&&P[g]===0;g++);for(h<g&&(h=g),w=1,c=1;c<=gt;c++)if(w<<=1,w-=P[c],w<0)return-1;if(w>0&&(n===Hr||d!==1))return-1;for(ie[1]=0,c=1;c<gt;c++)ie[c+1]=ie[c]+P[c];for(f=0;f<r;f++)e[t+f]!==0&&(a[ie[e[t+f]]++]=f);if(n===Hr?(T=_e=a,L=19):n===Jn?(T=lh,N-=257,_e=hh,Me-=257,L=256):(T=uh,_e=dh,L=-1),E=0,f=0,c=g,C=s,p=h,b=0,k=-1,S=1<<h,I=S-1,n===Jn&&S>qr||n===Vr&&S>Ur)return 1;for(;;){tt=c-b,a[f]<L?($e=0,ht=a[f]):a[f]>L?($e=_e[Me+a[f]],ht=T[N+a[f]]):($e=32+64,ht=0),v=1<<c-b,_=1<<p,g=_;do _-=v,i[C+(E>>b)+_]=tt<<24|$e<<16|ht|0;while(_!==0);for(v=1<<c-1;E&v;)v>>=1;if(v!==0?(E&=v-1,E+=v):E=0,f++,--P[c]===0){if(c===d)break;c=e[t+a[f]]}if(c>h&&(E&I)!==k){for(b===0&&(b=h),C+=g,p=c-b,w=1<<p;p+b<d&&(w-=P[p+b],!(w<=0));)p++,w<<=1;if(S+=1<<p,n===Jn&&S>qr||n===Vr&&S>Ur)return 1;k=E&I,i[k]=h<<24|p<<16|C-s|0}}return E!==0&&(i[C+E]=c-b<<24|64<<16|0),o.bits=h,0};var Dt=gh;const ph=0,ka=1,va=2,{Z_FINISH:Zr,Z_BLOCK:mh,Z_TREES:dn,Z_OK:ot,Z_STREAM_END:_h,Z_NEED_DICT:bh,Z_STREAM_ERROR:me,Z_DATA_ERROR:Ia,Z_MEM_ERROR:Aa,Z_BUF_ERROR:wh,Z_DEFLATED:Gr}=Yt,Fa=1,jr=2,Kr=3,Wr=4,Qr=5,Yr=6,Xr=7,Jr=8,es=9,ts=10,Nn=11,Ne=12,ei=13,ns=14,ti=15,is=16,rs=17,ss=18,as=19,gn=20,pn=21,os=22,cs=23,fs=24,ls=25,hs=26,ni=27,us=28,ds=29,ee=30,Ta=31,yh=32,Sh=852,Eh=592,Ch=15,xh=Ch,gs=n=>(n>>>24&255)+(n>>>8&65280)+((n&65280)<<8)+((n&255)<<24);function kh(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}const Na=n=>{if(!n||!n.state)return me;const e=n.state;return n.total_in=n.total_out=e.total=0,n.msg="",e.wrap&&(n.adler=e.wrap&1),e.mode=Fa,e.last=0,e.havedict=0,e.dmax=32768,e.head=null,e.hold=0,e.bits=0,e.lencode=e.lendyn=new Int32Array(Sh),e.distcode=e.distdyn=new Int32Array(Eh),e.sane=1,e.back=-1,ot},La=n=>{if(!n||!n.state)return me;const e=n.state;return e.wsize=0,e.whave=0,e.wnext=0,Na(n)},Ba=(n,e)=>{let t;if(!n||!n.state)return me;const r=n.state;return e<0?(t=0,e=-e):(t=(e>>4)+1,e<48&&(e&=15)),e&&(e<8||e>15)?me:(r.window!==null&&r.wbits!==e&&(r.window=null),r.wrap=t,r.wbits=e,La(n))},Ra=(n,e)=>{if(!n)return me;const t=new kh;n.state=t,t.window=null;const r=Ba(n,e);return r!==ot&&(n.state=null),r},vh=n=>Ra(n,xh);let ps=!0,ii,ri;const Ih=n=>{if(ps){ii=new Int32Array(512),ri=new Int32Array(32);let e=0;for(;e<144;)n.lens[e++]=8;for(;e<256;)n.lens[e++]=9;for(;e<280;)n.lens[e++]=7;for(;e<288;)n.lens[e++]=8;for(Dt(ka,n.lens,0,288,ii,0,n.work,{bits:9}),e=0;e<32;)n.lens[e++]=5;Dt(va,n.lens,0,32,ri,0,n.work,{bits:5}),ps=!1}n.lencode=ii,n.lenbits=9,n.distcode=ri,n.distbits=5},za=(n,e,t,r)=>{let i;const s=n.state;return s.window===null&&(s.wsize=1<<s.wbits,s.wnext=0,s.whave=0,s.window=new Uint8Array(s.wsize)),r>=s.wsize?(s.window.set(e.subarray(t-s.wsize,t),0),s.wnext=0,s.whave=s.wsize):(i=s.wsize-s.wnext,i>r&&(i=r),s.window.set(e.subarray(t-r,t-r+i),s.wnext),r-=i,r?(s.window.set(e.subarray(t-r,t),0),s.wnext=r,s.whave=s.wsize):(s.wnext+=i,s.wnext===s.wsize&&(s.wnext=0),s.whave<s.wsize&&(s.whave+=i))),0},Ah=(n,e)=>{let t,r,i,s,a,o,l,c,f,g,d,h,p,b,w=0,S,E,v,_,k,I,C,T;const N=new Uint8Array(4);let L,P;const ie=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(!n||!n.state||!n.output||!n.input&&n.avail_in!==0)return me;t=n.state,t.mode===Ne&&(t.mode=ei),a=n.next_out,i=n.output,l=n.avail_out,s=n.next_in,r=n.input,o=n.avail_in,c=t.hold,f=t.bits,g=o,d=l,T=ot;e:for(;;)switch(t.mode){case Fa:if(t.wrap===0){t.mode=ei;break}for(;f<16;){if(o===0)break e;o--,c+=r[s++]<<f,f+=8}if(t.wrap&2&&c===35615){t.check=0,N[0]=c&255,N[1]=c>>>8&255,t.check=ne(t.check,N,2,0),c=0,f=0,t.mode=jr;break}if(t.flags=0,t.head&&(t.head.done=!1),!(t.wrap&1)||(((c&255)<<8)+(c>>8))%31){n.msg="incorrect header check",t.mode=ee;break}if((c&15)!==Gr){n.msg="unknown compression method",t.mode=ee;break}if(c>>>=4,f-=4,C=(c&15)+8,t.wbits===0)t.wbits=C;else if(C>t.wbits){n.msg="invalid window size",t.mode=ee;break}t.dmax=1<<t.wbits,n.adler=t.check=1,t.mode=c&512?ts:Ne,c=0,f=0;break;case jr:for(;f<16;){if(o===0)break e;o--,c+=r[s++]<<f,f+=8}if(t.flags=c,(t.flags&255)!==Gr){n.msg="unknown compression method",t.mode=ee;break}if(t.flags&57344){n.msg="unknown header flags set",t.mode=ee;break}t.head&&(t.head.text=c>>8&1),t.flags&512&&(N[0]=c&255,N[1]=c>>>8&255,t.check=ne(t.check,N,2,0)),c=0,f=0,t.mode=Kr;case Kr:for(;f<32;){if(o===0)break e;o--,c+=r[s++]<<f,f+=8}t.head&&(t.head.time=c),t.flags&512&&(N[0]=c&255,N[1]=c>>>8&255,N[2]=c>>>16&255,N[3]=c>>>24&255,t.check=ne(t.check,N,4,0)),c=0,f=0,t.mode=Wr;case Wr:for(;f<16;){if(o===0)break e;o--,c+=r[s++]<<f,f+=8}t.head&&(t.head.xflags=c&255,t.head.os=c>>8),t.flags&512&&(N[0]=c&255,N[1]=c>>>8&255,t.check=ne(t.check,N,2,0)),c=0,f=0,t.mode=Qr;case Qr:if(t.flags&1024){for(;f<16;){if(o===0)break e;o--,c+=r[s++]<<f,f+=8}t.length=c,t.head&&(t.head.extra_len=c),t.flags&512&&(N[0]=c&255,N[1]=c>>>8&255,t.check=ne(t.check,N,2,0)),c=0,f=0}else t.head&&(t.head.extra=null);t.mode=Yr;case Yr:if(t.flags&1024&&(h=t.length,h>o&&(h=o),h&&(t.head&&(C=t.head.extra_len-t.length,t.head.extra||(t.head.extra=new Uint8Array(t.head.extra_len)),t.head.extra.set(r.subarray(s,s+h),C)),t.flags&512&&(t.check=ne(t.check,r,h,s)),o-=h,s+=h,t.length-=h),t.length))break e;t.length=0,t.mode=Xr;case Xr:if(t.flags&2048){if(o===0)break e;h=0;do C=r[s+h++],t.head&&C&&t.length<65536&&(t.head.name+=String.fromCharCode(C));while(C&&h<o);if(t.flags&512&&(t.check=ne(t.check,r,h,s)),o-=h,s+=h,C)break e}else t.head&&(t.head.name=null);t.length=0,t.mode=Jr;case Jr:if(t.flags&4096){if(o===0)break e;h=0;do C=r[s+h++],t.head&&C&&t.length<65536&&(t.head.comment+=String.fromCharCode(C));while(C&&h<o);if(t.flags&512&&(t.check=ne(t.check,r,h,s)),o-=h,s+=h,C)break e}else t.head&&(t.head.comment=null);t.mode=es;case es:if(t.flags&512){for(;f<16;){if(o===0)break e;o--,c+=r[s++]<<f,f+=8}if(c!==(t.check&65535)){n.msg="header crc mismatch",t.mode=ee;break}c=0,f=0}t.head&&(t.head.hcrc=t.flags>>9&1,t.head.done=!0),n.adler=t.check=0,t.mode=Ne;break;case ts:for(;f<32;){if(o===0)break e;o--,c+=r[s++]<<f,f+=8}n.adler=t.check=gs(c),c=0,f=0,t.mode=Nn;case Nn:if(t.havedict===0)return n.next_out=a,n.avail_out=l,n.next_in=s,n.avail_in=o,t.hold=c,t.bits=f,bh;n.adler=t.check=1,t.mode=Ne;case Ne:if(e===mh||e===dn)break e;case ei:if(t.last){c>>>=f&7,f-=f&7,t.mode=ni;break}for(;f<3;){if(o===0)break e;o--,c+=r[s++]<<f,f+=8}switch(t.last=c&1,c>>>=1,f-=1,c&3){case 0:t.mode=ns;break;case 1:if(Ih(t),t.mode=gn,e===dn){c>>>=2,f-=2;break e}break;case 2:t.mode=rs;break;case 3:n.msg="invalid block type",t.mode=ee}c>>>=2,f-=2;break;case ns:for(c>>>=f&7,f-=f&7;f<32;){if(o===0)break e;o--,c+=r[s++]<<f,f+=8}if((c&65535)!==(c>>>16^65535)){n.msg="invalid stored block lengths",t.mode=ee;break}if(t.length=c&65535,c=0,f=0,t.mode=ti,e===dn)break e;case ti:t.mode=is;case is:if(h=t.length,h){if(h>o&&(h=o),h>l&&(h=l),h===0)break e;i.set(r.subarray(s,s+h),a),o-=h,s+=h,l-=h,a+=h,t.length-=h;break}t.mode=Ne;break;case rs:for(;f<14;){if(o===0)break e;o--,c+=r[s++]<<f,f+=8}if(t.nlen=(c&31)+257,c>>>=5,f-=5,t.ndist=(c&31)+1,c>>>=5,f-=5,t.ncode=(c&15)+4,c>>>=4,f-=4,t.nlen>286||t.ndist>30){n.msg="too many length or distance symbols",t.mode=ee;break}t.have=0,t.mode=ss;case ss:for(;t.have<t.ncode;){for(;f<3;){if(o===0)break e;o--,c+=r[s++]<<f,f+=8}t.lens[ie[t.have++]]=c&7,c>>>=3,f-=3}for(;t.have<19;)t.lens[ie[t.have++]]=0;if(t.lencode=t.lendyn,t.lenbits=7,L={bits:t.lenbits},T=Dt(ph,t.lens,0,19,t.lencode,0,t.work,L),t.lenbits=L.bits,T){n.msg="invalid code lengths set",t.mode=ee;break}t.have=0,t.mode=as;case as:for(;t.have<t.nlen+t.ndist;){for(;w=t.lencode[c&(1<<t.lenbits)-1],S=w>>>24,E=w>>>16&255,v=w&65535,!(S<=f);){if(o===0)break e;o--,c+=r[s++]<<f,f+=8}if(v<16)c>>>=S,f-=S,t.lens[t.have++]=v;else{if(v===16){for(P=S+2;f<P;){if(o===0)break e;o--,c+=r[s++]<<f,f+=8}if(c>>>=S,f-=S,t.have===0){n.msg="invalid bit length repeat",t.mode=ee;break}C=t.lens[t.have-1],h=3+(c&3),c>>>=2,f-=2}else if(v===17){for(P=S+3;f<P;){if(o===0)break e;o--,c+=r[s++]<<f,f+=8}c>>>=S,f-=S,C=0,h=3+(c&7),c>>>=3,f-=3}else{for(P=S+7;f<P;){if(o===0)break e;o--,c+=r[s++]<<f,f+=8}c>>>=S,f-=S,C=0,h=11+(c&127),c>>>=7,f-=7}if(t.have+h>t.nlen+t.ndist){n.msg="invalid bit length repeat",t.mode=ee;break}for(;h--;)t.lens[t.have++]=C}}if(t.mode===ee)break;if(t.lens[256]===0){n.msg="invalid code -- missing end-of-block",t.mode=ee;break}if(t.lenbits=9,L={bits:t.lenbits},T=Dt(ka,t.lens,0,t.nlen,t.lencode,0,t.work,L),t.lenbits=L.bits,T){n.msg="invalid literal/lengths set",t.mode=ee;break}if(t.distbits=6,t.distcode=t.distdyn,L={bits:t.distbits},T=Dt(va,t.lens,t.nlen,t.ndist,t.distcode,0,t.work,L),t.distbits=L.bits,T){n.msg="invalid distances set",t.mode=ee;break}if(t.mode=gn,e===dn)break e;case gn:t.mode=pn;case pn:if(o>=6&&l>=258){n.next_out=a,n.avail_out=l,n.next_in=s,n.avail_in=o,t.hold=c,t.bits=f,fh(n,d),a=n.next_out,i=n.output,l=n.avail_out,s=n.next_in,r=n.input,o=n.avail_in,c=t.hold,f=t.bits,t.mode===Ne&&(t.back=-1);break}for(t.back=0;w=t.lencode[c&(1<<t.lenbits)-1],S=w>>>24,E=w>>>16&255,v=w&65535,!(S<=f);){if(o===0)break e;o--,c+=r[s++]<<f,f+=8}if(E&&(E&240)===0){for(_=S,k=E,I=v;w=t.lencode[I+((c&(1<<_+k)-1)>>_)],S=w>>>24,E=w>>>16&255,v=w&65535,!(_+S<=f);){if(o===0)break e;o--,c+=r[s++]<<f,f+=8}c>>>=_,f-=_,t.back+=_}if(c>>>=S,f-=S,t.back+=S,t.length=v,E===0){t.mode=hs;break}if(E&32){t.back=-1,t.mode=Ne;break}if(E&64){n.msg="invalid literal/length code",t.mode=ee;break}t.extra=E&15,t.mode=os;case os:if(t.extra){for(P=t.extra;f<P;){if(o===0)break e;o--,c+=r[s++]<<f,f+=8}t.length+=c&(1<<t.extra)-1,c>>>=t.extra,f-=t.extra,t.back+=t.extra}t.was=t.length,t.mode=cs;case cs:for(;w=t.distcode[c&(1<<t.distbits)-1],S=w>>>24,E=w>>>16&255,v=w&65535,!(S<=f);){if(o===0)break e;o--,c+=r[s++]<<f,f+=8}if((E&240)===0){for(_=S,k=E,I=v;w=t.distcode[I+((c&(1<<_+k)-1)>>_)],S=w>>>24,E=w>>>16&255,v=w&65535,!(_+S<=f);){if(o===0)break e;o--,c+=r[s++]<<f,f+=8}c>>>=_,f-=_,t.back+=_}if(c>>>=S,f-=S,t.back+=S,E&64){n.msg="invalid distance code",t.mode=ee;break}t.offset=v,t.extra=E&15,t.mode=fs;case fs:if(t.extra){for(P=t.extra;f<P;){if(o===0)break e;o--,c+=r[s++]<<f,f+=8}t.offset+=c&(1<<t.extra)-1,c>>>=t.extra,f-=t.extra,t.back+=t.extra}if(t.offset>t.dmax){n.msg="invalid distance too far back",t.mode=ee;break}t.mode=ls;case ls:if(l===0)break e;if(h=d-l,t.offset>h){if(h=t.offset-h,h>t.whave&&t.sane){n.msg="invalid distance too far back",t.mode=ee;break}h>t.wnext?(h-=t.wnext,p=t.wsize-h):p=t.wnext-h,h>t.length&&(h=t.length),b=t.window}else b=i,p=a-t.offset,h=t.length;h>l&&(h=l),l-=h,t.length-=h;do i[a++]=b[p++];while(--h);t.length===0&&(t.mode=pn);break;case hs:if(l===0)break e;i[a++]=t.length,l--,t.mode=pn;break;case ni:if(t.wrap){for(;f<32;){if(o===0)break e;o--,c|=r[s++]<<f,f+=8}if(d-=l,n.total_out+=d,t.total+=d,d&&(n.adler=t.check=t.flags?ne(t.check,i,d,a-d):Vt(t.check,i,d,a-d)),d=l,(t.flags?c:gs(c))!==t.check){n.msg="incorrect data check",t.mode=ee;break}c=0,f=0}t.mode=us;case us:if(t.wrap&&t.flags){for(;f<32;){if(o===0)break e;o--,c+=r[s++]<<f,f+=8}if(c!==(t.total&4294967295)){n.msg="incorrect length check",t.mode=ee;break}c=0,f=0}t.mode=ds;case ds:T=_h;break e;case ee:T=Ia;break e;case Ta:return Aa;case yh:default:return me}return n.next_out=a,n.avail_out=l,n.next_in=s,n.avail_in=o,t.hold=c,t.bits=f,(t.wsize||d!==n.avail_out&&t.mode<ee&&(t.mode<ni||e!==Zr))&&za(n,n.output,n.next_out,d-n.avail_out),g-=n.avail_in,d-=n.avail_out,n.total_in+=g,n.total_out+=d,t.total+=d,t.wrap&&d&&(n.adler=t.check=t.flags?ne(t.check,i,d,n.next_out-d):Vt(t.check,i,d,n.next_out-d)),n.data_type=t.bits+(t.last?64:0)+(t.mode===Ne?128:0)+(t.mode===gn||t.mode===ti?256:0),(g===0&&d===0||e===Zr)&&T===ot&&(T=wh),T},Fh=n=>{if(!n||!n.state)return me;let e=n.state;return e.window&&(e.window=null),n.state=null,ot},Th=(n,e)=>{if(!n||!n.state)return me;const t=n.state;return(t.wrap&2)===0?me:(t.head=e,e.done=!1,ot)},Nh=(n,e)=>{const t=e.length;let r,i,s;return!n||!n.state||(r=n.state,r.wrap!==0&&r.mode!==Nn)?me:r.mode===Nn&&(i=1,i=Vt(i,e,t,0),i!==r.check)?Ia:(s=za(n,e,t,t),s?(r.mode=Ta,Aa):(r.havedict=1,ot))};var Lh=La,Bh=Ba,Rh=Na,zh=vh,Ph=Ra,Dh=Ah,Mh=Fh,$h=Th,Oh=Nh,qh="pako inflate (from Nodeca project)",Re={inflateReset:Lh,inflateReset2:Bh,inflateResetKeep:Rh,inflateInit:zh,inflateInit2:Ph,inflate:Dh,inflateEnd:Mh,inflateGetHeader:$h,inflateSetDictionary:Oh,inflateInfo:qh};function Uh(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}var Hh=Uh;const Pa=Object.prototype.toString,{Z_NO_FLUSH:Vh,Z_FINISH:Zh,Z_OK:jt,Z_STREAM_END:si,Z_NEED_DICT:ai,Z_STREAM_ERROR:Gh,Z_DATA_ERROR:ms,Z_MEM_ERROR:jh}=Yt;function Jt(n){this.options=Mn.assign({chunkSize:1024*64,windowBits:15,to:""},n||{});const e=this.options;e.raw&&e.windowBits>=0&&e.windowBits<16&&(e.windowBits=-e.windowBits,e.windowBits===0&&(e.windowBits=-15)),e.windowBits>=0&&e.windowBits<16&&!(n&&n.windowBits)&&(e.windowBits+=32),e.windowBits>15&&e.windowBits<48&&(e.windowBits&15)===0&&(e.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new Ca,this.strm.avail_out=0;let t=Re.inflateInit2(this.strm,e.windowBits);if(t!==jt)throw new Error(St[t]);if(this.header=new Hh,Re.inflateGetHeader(this.strm,this.header),e.dictionary&&(typeof e.dictionary=="string"?e.dictionary=Gt.string2buf(e.dictionary):Pa.call(e.dictionary)==="[object ArrayBuffer]"&&(e.dictionary=new Uint8Array(e.dictionary)),e.raw&&(t=Re.inflateSetDictionary(this.strm,e.dictionary),t!==jt)))throw new Error(St[t])}Jt.prototype.push=function(n,e){const t=this.strm,r=this.options.chunkSize,i=this.options.dictionary;let s,a,o;if(this.ended)return!1;for(e===~~e?a=e:a=e===!0?Zh:Vh,Pa.call(n)==="[object ArrayBuffer]"?t.input=new Uint8Array(n):t.input=n,t.next_in=0,t.avail_in=t.input.length;;){for(t.avail_out===0&&(t.output=new Uint8Array(r),t.next_out=0,t.avail_out=r),s=Re.inflate(t,a),s===ai&&i&&(s=Re.inflateSetDictionary(t,i),s===jt?s=Re.inflate(t,a):s===ms&&(s=ai));t.avail_in>0&&s===si&&t.state.wrap>0&&n[t.next_in]!==0;)Re.inflateReset(t),s=Re.inflate(t,a);switch(s){case Gh:case ms:case ai:case jh:return this.onEnd(s),this.ended=!0,!1}if(o=t.avail_out,t.next_out&&(t.avail_out===0||s===si))if(this.options.to==="string"){let l=Gt.utf8border(t.output,t.next_out),c=t.next_out-l,f=Gt.buf2string(t.output,l);t.next_out=c,t.avail_out=r-c,c&&t.output.set(t.output.subarray(l,l+c),0),this.onData(f)}else this.onData(t.output.length===t.next_out?t.output:t.output.subarray(0,t.next_out));if(!(s===jt&&o===0)){if(s===si)return s=Re.inflateEnd(this.strm),this.onEnd(s),this.ended=!0,!0;if(t.avail_in===0)break}}return!0};Jt.prototype.onData=function(n){this.chunks.push(n)};Jt.prototype.onEnd=function(n){n===jt&&(this.options.to==="string"?this.result=this.chunks.join(""):this.result=Mn.flattenChunks(this.chunks)),this.chunks=[],this.err=n,this.msg=this.strm.msg};function Ii(n,e){const t=new Jt(e);if(t.push(n),t.err)throw t.msg||St[t.err];return t.result}function Kh(n,e){return e=e||{},e.raw=!0,Ii(n,e)}var Wh=Jt,Qh=Ii,Yh=Kh,Xh=Ii,Jh=Yt,eu={Inflate:Wh,inflate:Qh,inflateRaw:Yh,ungzip:Xh,constants:Jh};const{Inflate:Vd,inflate:Zd,inflateRaw:tu,ungzip:Gd}=eu;var nu=tu;function iu(n){return nu(n.subarray(2))}class ru extends Error{constructor(e){super(e),this.code="ERR_ABORTED"}}function su(n){n.sort((i,s)=>Number(i.offset)-Number(s.offset));const e=[];let t,r;for(let i=0;i<n.length;i+=1)t&&r&&Number(n[i].offset)-r<=2e3?(t.length=BigInt(Number(t.length)+Number(n[i].length)-r+Number(n[i].offset)),t.blocks.push(n[i])):e.push(t={blocks:[n[i]],length:n[i].length,offset:n[i].offset}),r=Number(t.offset)+Number(t.length);return e}function mn(n){if(!!n&&n.aborted){if(typeof DOMException<"u")throw new DOMException("aborted","AbortError");{const e=new ru("aborted");throw e.code="ERR_ABORTED",e}}}const au=1,ou=2,cu=3;function oi(n,e,t,r){return n<r&&e>=t}function fu(n){const e=n?"big":"little",t=new K().endianess(e).uint32("chromId").uint32("start").uint32("end").uint32("validCnt").floatle("minScore").floatle("maxScore").floatle("sumData").floatle("sumSqData").saveOffset("offset"),r=new K().endianess(e).uint8("isLeaf").skip(1).uint16("cnt").choice({tag:"isLeaf",choices:{1:new K().endianess(e).array("blocksToFetch",{length:"cnt",type:new K().endianess(e).uint32("startChrom").uint32("startBase").uint32("endChrom").uint32("endBase").uint64("blockOffset").uint64("blockSize").saveOffset("offset")}),0:new K().array("recurOffsets",{length:"cnt",type:new K().endianess(e).uint32("startChrom").uint32("startBase").uint32("endChrom").uint32("endBase").uint64("blockOffset").saveOffset("offset")})}}),i=new K().endianess(e).uint32("chromId").int32("start").int32("end").string("rest",{zeroTerminated:!0}).saveOffset("offset");return{bigWigParser:new K().endianess(e).skip(4).int32("blockStart").skip(4).uint32("itemStep").uint32("itemSpan").uint8("blockType").skip(1).uint16("itemCount").choice({tag:"blockType",choices:{[cu]:new K().array("items",{length:"itemCount",type:new K().floatle("score")}),[ou]:new K().array("items",{length:"itemCount",type:new K().endianess(e).int32("start").floatle("score")}),[au]:new K().array("items",{length:"itemCount",type:new K().endianess(e).int32("start").int32("end").floatle("score")})}}),bigBedParser:i,summaryParser:t,leafParser:r}}class Da{constructor(e,t,r,i,s,a){if(this.bbi=e,this.refsByName=t,this.cirTreeOffset=r,this.isBigEndian=i,this.isCompressed=s,this.blockType=a,this.featureCache=new De({cache:new na({maxSize:1e3}),fill:async(l,c)=>{const f=Number(l.length),g=Number(l.offset),{buffer:d}=await this.bbi.read($.Buffer.alloc(f),0,f,g,{signal:c});return d}}),!(r>=0))throw new Error("invalid cirTreeOffset!");const o=fu(i);this.leafParser=o.leafParser,this.bigBedParser=o.bigBedParser}async readWigData(e,t,r,i,s){try{const{refsByName:a,bbi:o,cirTreeOffset:l,isBigEndian:c}=this,f=a[e];f===void 0&&i.complete();const g={chrId:f,start:t,end:r};if(!this.cirTreePromise){const _=Number(l);this.cirTreePromise=o.read($.Buffer.alloc(48),0,48,_,s)}const{buffer:d}=await this.cirTreePromise,h=c?d.readUInt32BE(4):d.readUInt32LE(4);let p=[],b=0;const w=(_,k,I)=>{try{const C=_.subarray(k),T=this.leafParser.parse(C);if(T.blocksToFetch&&(p=p.concat(T.blocksToFetch.filter(S).map(N=>({offset:N.blockOffset,length:N.blockSize})))),T.recurOffsets){const N=T.recurOffsets.filter(S).map(L=>Number(L.blockOffset));N.length>0&&v(N,I+1)}}catch(C){i.error(C)}},S=_=>{const{startChrom:k,startBase:I,endChrom:C,endBase:T}=_;return(k<f||k===f&&I<=r)&&(C>f||C===f&&T>=t)},E=async(_,k,I)=>{try{const C=k.max()-k.min(),T=k.min(),N=await this.featureCache.get(`${C}_${T}`,{length:C,offset:T},s.signal);for(let L=0;L<_.length;L+=1)k.contains(_[L])&&(w(N,_[L]-T,I),b-=1,b===0&&this.readFeatures(i,p,{...s,request:g}))}catch(C){i.error(C)}},v=(_,k)=>{try{b+=_.length;const I=4+Number(h)*32;let C=new Ze(_[0],_[0]+I);for(let T=1;T<_.length;T+=1){const N=new Ze(_[T],_[T]+I);C=C.union(N)}C.getRanges().map(T=>E(_,T,k))}catch(I){i.error(I)}};return v([Number(l)+48],1)}catch(a){i.error(a)}}parseSummaryBlock(e,t,r){const i=[];let s=t;const a=new DataView(e.buffer,e.byteOffset,e.length);for(;s<e.byteLength;){const o=a.getUint32(s,!0);s+=4;const l=a.getUint32(s,!0);s+=4;const c=a.getUint32(s,!0);s+=4;const f=a.getUint32(s,!0);s+=4;const g=a.getFloat32(s,!0);s+=4;const d=a.getFloat32(s,!0);s+=4;const h=a.getFloat32(s,!0);s+=4,s+=4,(!r||o===r.chrId&&oi(l,c,r.start,r.end))&&i.push({start:l,end:c,maxScore:d,minScore:g,summary:!0,score:h/(f||1)})}return i}parseBigBedBlock(e,t,r,i){const s=[];let a=t;for(;a<e.byteLength;){const o=this.bigBedParser.parse(e.subarray(a));s.push({...o,uniqueId:`bb-${r+a}`}),a+=o.offset}return i?s.filter(o=>oi(o.start,o.end,i.start,i.end)):s}parseBigWigBlock(e,t,r){const i=e.subarray(t),s=new DataView(i.buffer,i.byteOffset,i.length);let a=0;a+=4;const o=s.getInt32(a,!0);a+=8;const l=s.getUint32(a,!0);a+=4;const c=s.getUint32(a,!0);a+=4;const f=s.getUint8(a);a+=2;const g=s.getUint16(a,!0);a+=2;const d=new Array(g);switch(f){case 1:for(let h=0;h<g;h++){const p=s.getInt32(a,!0);a+=4;const b=s.getInt32(a,!0);a+=4;const w=s.getFloat32(a,!0);a+=4,d[h]={start:p,end:b,score:w}}break;case 2:for(let h=0;h<g;h++){const p=s.getInt32(a,!0);a+=4;const b=s.getFloat32(a,!0);a+=4,d[h]={score:b,start:p,end:p+c}}break;case 3:for(let h=0;h<g;h++){const p=s.getFloat32(a,!0);a+=4;const b=o+h*l;d[h]={score:p,start:b,end:b+c}}break}return r?d.filter(h=>oi(h.start,h.end,r.start,r.end)):d}async readFeatures(e,t,r={}){try{const{blockType:i,isCompressed:s}=this,{signal:a,request:o}=r,l=su(t);mn(a),await Promise.all(l.map(async c=>{mn(a);const{length:f,offset:g}=c,d=await this.featureCache.get(`${f}_${g}`,c,a);c.blocks.forEach(h=>{mn(a);let p=Number(h.offset)-Number(c.offset),b=d;switch(s&&(b=iu(d.subarray(p)),p=0),mn(a),i){case"summary":e.next(this.parseSummaryBlock(b,p,o));break;case"bigwig":e.next(this.parseBigWigBlock(b,p,o));break;case"bigbed":e.next(this.parseBigBedBlock(b,p,Number(h.offset)*(1<<8),o));break;default:console.warn(`Don't know what to do with ${i}`)}})})),e.complete()}catch(i){e.error(i)}}}const _s=-2003829722,ci=-2021002517;function bs(n){const e=n?"big":"little",t=new K().endianess(e).int32("magic").uint16("version").uint16("numZoomLevels").uint64("chromTreeOffset").uint64("unzoomedDataOffset").uint64("unzoomedIndexOffset").uint16("fieldCount").uint16("definedFieldCount").uint64("asOffset").uint64("totalSummaryOffset").uint32("uncompressBufSize").uint64("extHeaderOffset").array("zoomLevels",{length:"numZoomLevels",type:new K().endianess(e).uint32("reductionLevel").uint32("reserved").uint64("dataOffset").uint64("indexOffset")}),r=new K().endianess(e).uint64("basesCovered").doublele("scoreMin").doublele("scoreMax").doublele("scoreSum").doublele("scoreSumSquares"),i=new K().endianess(e).uint32("magic").uint32("blockSize").uint32("keySize").uint32("valSize").uint64("itemCount"),s=new K().endianess(e).uint8("isLeafNode").skip(1).uint16("cnt").saveOffset("offset");return{chromTreeParser:i,totalSummaryParser:r,headerParser:t,isLeafNode:s}}class Ma{constructor(e={}){const{filehandle:t,renameRefSeqs:r=a=>a,path:i,url:s}=e;if(this.renameRefSeqs=r,t)this.bbi=t;else if(s)this.bbi=new Tt(s);else if(i)this.bbi=new X(i);else throw new Error("no file given")}getHeader(e={}){const t="aborted"in e?{signal:e}:e;return this.headerP||(this.headerP=this._getHeader(t).catch(r=>{throw this.headerP=void 0,r})),this.headerP}async _getHeader(e){const t=await this._getMainHeader(e),r=await this._readChromTree(t,e);return{...t,...r}}async _getMainHeader(e,t=2e3){const{buffer:r}=await this.bbi.read($.Buffer.alloc(t),0,t,0,e),i=this._isBigEndian(r),s=bs(i),a=s.headerParser.parse(r),{magic:o,asOffset:l,totalSummaryOffset:c}=a;if(a.fileType=o===ci?"bigbed":"bigwig",l>t||c>t)return this._getMainHeader(e,t*2);if(l){const f=Number(a.asOffset);a.autoSql=r.subarray(f,r.indexOf(0,f)).toString("utf8")}if(a.totalSummaryOffset>t)return this._getMainHeader(e,t*2);if(a.totalSummaryOffset){const f=r.subarray(Number(a.totalSummaryOffset)),g=s.totalSummaryParser.parse(f);a.totalSummary={...g,basesCovered:Number(g.basesCovered)}}return{...a,isBigEndian:i}}_isBigEndian(e){let t=e.readInt32LE(0);if(t===_s||t===ci)return!1;if(t=e.readInt32BE(0),t===_s||t===ci)return!0;throw new Error("not a BigWig/BigBed file")}async _readChromTree(e,t){const r=e.isBigEndian,i=r?"big":"little",s=[],a={};let o=Number(e.unzoomedDataOffset);const l=Number(e.chromTreeOffset);for(;o%4!==0;)o+=1;const c=o-l,{buffer:f}=await this.bbi.read($.Buffer.alloc(c),0,c,Number(l),t),g=bs(r),{keySize:d}=g.chromTreeParser.parse(f),h=new K().endianess(i).string("key",{stripNull:!0,length:d}).uint32("refId").uint32("refSize").saveOffset("offset"),p=new K().endianess(i).skip(d).uint64("childOffset").saveOffset("offset"),b=32,w=async S=>{let E=S;if(E>=f.length)throw new Error("reading beyond end of buffer");const v=g.isLeafNode.parse(f.subarray(E)),{isLeafNode:_,cnt:k}=v;if(E+=v.offset,_)for(let I=0;I<k;I+=1){const C=h.parse(f.subarray(E));E+=C.offset;const{key:T,refId:N,refSize:L}=C,P={name:T,id:N,length:L};a[this.renameRefSeqs(T)]=N,s[N]=P}else{const I=[];for(let C=0;C<k;C+=1){const T=p.parse(f.subarray(E)),{childOffset:N}=T;E+=T.offset,I.push(w(Number(N)-Number(l)))}await Promise.all(I)}};return await w(b),{refsByName:a,refsByNumber:s}}async getUnzoomedView(e){const{unzoomedIndexOffset:t,refsByName:r,uncompressBufSize:i,isBigEndian:s,fileType:a}=await this.getHeader(e);return new Da(this.bbi,r,t,s,i>0,a)}async getFeatureStream(e,t,r,i={scale:1}){await this.getHeader(i);const s=this.renameRefSeqs(e);let a;if(i.basesPerSpan?a=await this.getView(1/i.basesPerSpan,i):i.scale?a=await this.getView(i.scale,i):a=await this.getView(1,i),!a)throw new Error("unable to get block view for data");return new As(o=>{a.readWigData(s,t,r,o,i)})}async getFeatures(e,t,r,i={scale:1}){return await(await this.getFeatureStream(e,t,r,i)).pipe(Fs((o,l)=>o.concat(l))).toPromise()||[]}}class jd extends Ma{async getView(e,t){const{zoomLevels:r,refsByName:i,fileSize:s,isBigEndian:a,uncompressBufSize:o}=await this.getHeader(t),l=1/e;let c=r.length;s||(c-=1);for(let f=c;f>=0;f-=1){const g=r[f];if(g&&g.reductionLevel<=2*l){const d=Number(g.indexOffset);return new Da(this.bbi,i,d,a,o>0,"summary")}}return this.getUnzoomedView(t)}}function lu(n){return n.filter(e=>!!e)}class Kd extends Ma{constructor(){super(...arguments),this.readIndicesCache=new De({cache:new na({maxSize:1}),fill:async(e,t)=>this._readIndices({...e,signal:t})})}readIndices(e={}){const t="aborted"in e?{signal:e}:e;return this.readIndicesCache.get(JSON.stringify(t),t,t.signal)}async getView(e,t){return this.getUnzoomedView(t)}async _readIndices(e){const{extHeaderOffset:t,isBigEndian:r}=await this.getHeader(e),{buffer:i}=await this.bbi.read($.Buffer.alloc(64),0,64,Number(t)),s=r?"big":"little",a=new K().endianess(s).uint16("size").uint16("count").uint64("offset").parse(i),{count:o,offset:l}=a;if(o===0)return[];const c=20,f=c*o,{buffer:g}=await this.bbi.read($.Buffer.alloc(f),0,f,Number(l)),d=new K().endianess(s).int16("type").int16("fieldcount").uint64("offset").skip(4).int16("field"),h=[];for(let p=0;p<o;p+=1)h.push(d.parse(g.subarray(p*c)));return h}async searchExtraIndexBlocks(e,t={}){const{isBigEndian:r}=await this.getHeader(t),i=await this.readIndices(t);if(!i.length)return[];const s=i.map(async a=>{const{offset:o,field:l}=a,{buffer:c}=await this.bbi.read($.Buffer.alloc(32),0,32,Number(o),t),f=r?"big":"little",g=new K().endianess(f).int32("magic").int32("blockSize").int32("keySize").int32("valSize").uint64("itemCount"),{blockSize:d,keySize:h,valSize:p}=g.parse(c),b=new K().endianess(f).int8("nodeType").skip(1).int16("cnt").choice({tag:"nodeType",choices:{0:new K().array("leafkeys",{length:"cnt",type:new K().endianess(f).string("key",{length:h,stripNull:!0}).uint64("offset")}),1:new K().array("keys",{length:"cnt",type:new K().endianess(f).string("key",{length:h,stripNull:!0}).uint64("offset").uint32("length").uint32("reserved")})}}),w=async E=>{const v=Number(E),_=4+d*(h+p),{buffer:k}=await this.bbi.read($.Buffer.alloc(_),0,_,v,t),I=b.parse(k);if(I.leafkeys){let C;for(let T=0;T<I.leafkeys.length;T+=1){const{key:N}=I.leafkeys[T];if(e.localeCompare(N)<0&&C)return w(C);C=I.leafkeys[T].offset}return w(C)}for(let C=0;C<I.keys.length;C+=1)if(I.keys[C].key===e)return{...I.keys[C],field:l}},S=32;return w(Number(o)+S)});return lu(await Promise.all(s))}async searchExtraIndex(e,t={}){const r=await this.searchExtraIndexBlocks(e,t);if(!r.length)return[];const i=await this.getUnzoomedView(t),s=r.map(o=>new As(l=>{i.readFeatures(l,[o],t)}).pipe(Fs((l,c)=>l.concat(c)),Vo(l=>{for(let c=0;c<l.length;c+=1)l[c].field=o.field;return l})));return(await Zo(...s).toPromise()).filter(o=>{var l;return((l=o.rest)===null||l===void 0?void 0:l.split("	")[(o.field||0)-3])===e})}}function hu(n,e){function t(){this.constructor=n}t.prototype=e.prototype,n.prototype=new t}function Et(n,e,t,r){this.message=n,this.expected=e,this.found=t,this.location=r,this.name="SyntaxError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Et)}hu(Et,Error);Et.buildMessage=function(n,e){var t={literal:function(c){return'"'+i(c.text)+'"'},class:function(c){var f="",g;for(g=0;g<c.parts.length;g++)f+=c.parts[g]instanceof Array?s(c.parts[g][0])+"-"+s(c.parts[g][1]):s(c.parts[g]);return"["+(c.inverted?"^":"")+f+"]"},any:function(c){return"any character"},end:function(c){return"end of input"},other:function(c){return c.description}};function r(c){return c.charCodeAt(0).toString(16).toUpperCase()}function i(c){return c.replace(/\\/g,"\\\\").replace(/"/g,'\\"').replace(/\0/g,"\\0").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\r/g,"\\r").replace(/[\x00-\x0F]/g,function(f){return"\\x0"+r(f)}).replace(/[\x10-\x1F\x7F-\x9F]/g,function(f){return"\\x"+r(f)})}function s(c){return c.replace(/\\/g,"\\\\").replace(/\]/g,"\\]").replace(/\^/g,"\\^").replace(/-/g,"\\-").replace(/\0/g,"\\0").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\r/g,"\\r").replace(/[\x00-\x0F]/g,function(f){return"\\x0"+r(f)}).replace(/[\x10-\x1F\x7F-\x9F]/g,function(f){return"\\x"+r(f)})}function a(c){return t[c.type](c)}function o(c){var f=new Array(c.length),g,d;for(g=0;g<c.length;g++)f[g]=a(c[g]);if(f.sort(),f.length>0){for(g=1,d=1;g<f.length;g++)f[g-1]!==f[g]&&(f[d]=f[g],d++);f.length=d}switch(f.length){case 1:return f[0];case 2:return f[0]+" or "+f[1];default:return f.slice(0,-1).join(", ")+", or "+f[f.length-1]}}function l(c){return c?'"'+i(c)+'"':"end of input"}return"Expected "+o(n)+" but "+l(e)+" found."};function uu(n,e){e=e!==void 0?e:{};var t={},r={declaration:ur},i=ur,s="(",a=W("(",!1),o=")",l=W(")",!1),c=function(u,y,A,F){return{type:u,name:y,comment:A,fields:F}},f="simple",g=W("simple",!1),d="object",h=W("object",!1),p="table",b=W("table",!1),w="auto",S=W("auto",!1),E="primary",v=W("primary",!1),_="index",k=W("index",!1),I="unique",C=W("unique",!1),T=function(u,y){return y},N=function(u,y){return u.name&&y.unshift(u),y},L="#",P=W("#",!1),ie=";",_e=W(";",!1),Me=function(u,y,A){return{type:u,name:y,comment:A}},tt="[",$e=W("[",!1),ht="]",ao=W("]",!1),oo=function(u,y,A,F){return{type:u,size:y,name:A,comment:F}},co=function(u,y,A,F){return{type:u,vals:y,name:A,comment:F}},Mi=",",$i=W(",",!1),fo=function(u,y){return y.unshift(u),y},Oi="int",lo=W("int",!1),qi="uint",ho=W("uint",!1),Ui="short",uo=W("short",!1),Hi="ushort",go=W("ushort",!1),Vi="byte",po=W("byte",!1),Zi="ubyte",mo=W("ubyte",!1),Gi="float",_o=W("float",!1),ji="char",bo=W("char",!1),Ki="string",wo=W("string",!1),Wi="lstring",yo=W("lstring",!1),Qi="enum",So=W("enum",!1),Yi="double",Eo=W("double",!1),Xi="bigint",Co=W("bigint",!1),Ji="set",xo=W("set",!1),ko=function(u,y){return u+" "+y},vo=/^[a-zA-Z_]/,Io=vt([["a","z"],["A","Z"],"_"],!1,!1),er=/^[a-zA-Z0-9_]/,tr=vt([["a","z"],["A","Z"],["0","9"],"_"],!1,!1),Ao=function(u){return cr()},nr=/^[^\n\r]/,ir=vt([`
`,"\r"],!0,!1),Fo=function(u){return u.join("").replace(/^"/,"").replace(/"$/,"")},To=fr("integer"),rr=/^[0-9]/,sr=vt([["0","9"]],!1,!1),No=function(){return parseInt(cr(),10)},Lo=fr("whitespace"),ar=/^[ \t\n\r]/,or=vt([" ","	",`
`,"\r"],!1,!1),m=0,oe=0,rn=[{line:1,column:1}],Ce=0,$n=[],z=0,sn;if("startRule"in e){if(!(e.startRule in r))throw new Error(`Can't start parsing from rule "`+e.startRule+'".');i=r[e.startRule]}function cr(){return n.substring(oe,m)}function W(u,y){return{type:"literal",text:u,ignoreCase:y}}function vt(u,y,A){return{type:"class",parts:u,inverted:y,ignoreCase:A}}function Bo(){return{type:"end"}}function fr(u){return{type:"other",description:u}}function lr(u){var y=rn[u],A;if(y)return y;for(A=u-1;!rn[A];)A--;for(y=rn[A],y={line:y.line,column:y.column};A<u;)n.charCodeAt(A)===10?(y.line++,y.column=1):y.column++,A++;return rn[u]=y,y}function hr(u,y){var A=lr(u),F=lr(y);return{start:{offset:u,line:A.line,column:A.column},end:{offset:y,line:F.line,column:F.column}}}function M(u){m<Ce||(m>Ce&&(Ce=m,$n=[]),$n.push(u))}function Ro(u,y,A){return new Et(Et.buildMessage(u,y),u,y,A)}function ur(){var u,y,A,F,B,Q,J,he,Oe,Ae,qe,Fe,Ue,Te;return u=m,y=H(),y!==t?(A=dr(),A!==t?(F=H(),F!==t?(B=gr(),B!==t?(Q=H(),Q!==t?(J=an(),J!==t?(he=H(),he!==t?(n.charCodeAt(m)===40?(Oe=s,m++):(Oe=t,z===0&&M(a)),Oe!==t?(Ae=H(),Ae!==t?(qe=zo(),qe!==t?(Fe=H(),Fe!==t?(n.charCodeAt(m)===41?(Ue=o,m++):(Ue=t,z===0&&M(l)),Ue!==t?(Te=H(),Te!==t?(oe=u,y=c(A,B,J,qe),u=y):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)):(m=u,u=t),u}function dr(){var u;return n.substr(m,6)===f?(u=f,m+=6):(u=t,z===0&&M(g)),u===t&&(n.substr(m,6)===d?(u=d,m+=6):(u=t,z===0&&M(h)),u===t&&(n.substr(m,5)===p?(u=p,m+=5):(u=t,z===0&&M(b)))),u}function gr(){var u,y,A,F;return u=be(),u===t&&(u=m,y=be(),y!==t?(A=pr(),A!==t?(y=[y,A],u=y):(m=u,u=t)):(m=u,u=t),u===t&&(u=m,y=be(),y!==t?(n.substr(m,4)===w?(A=w,m+=4):(A=t,z===0&&M(S)),A!==t?(y=[y,A],u=y):(m=u,u=t)):(m=u,u=t),u===t&&(u=m,y=be(),y!==t?(A=pr(),A!==t?(n.substr(m,4)===w?(F=w,m+=4):(F=t,z===0&&M(S)),F!==t?(y=[y,A,F],u=y):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)))),u}function pr(){var u;return n.substr(m,7)===E?(u=E,m+=7):(u=t,z===0&&M(v)),u===t&&(n.substr(m,5)===_?(u=_,m+=5):(u=t,z===0&&M(k)),u===t&&(n.substr(m,6)===I?(u=I,m+=6):(u=t,z===0&&M(C)))),u}function an(){var u;return u=mr(),u===t&&(u=H()),u}function zo(){var u,y,A,F,B,Q,J;if(u=m,y=On(),y!==t)if(A=H(),A!==t){for(F=[],B=m,Q=H(),Q!==t?(J=On(),J!==t?(oe=B,Q=T(y,J),B=Q):(m=B,B=t)):(m=B,B=t);B!==t;)F.push(B),B=m,Q=H(),Q!==t?(J=On(),J!==t?(oe=B,Q=T(y,J),B=Q):(m=B,B=t)):(m=B,B=t);F!==t?(B=H(),B!==t?(oe=u,y=N(y,F),u=y):(m=u,u=t)):(m=u,u=t)}else m=u,u=t;else m=u,u=t;return u}function Po(){var u;return n.charCodeAt(m)===35?(u=L,m++):(u=t,z===0&&M(P)),u}function Do(){var u,y,A,F,B;return u=m,y=H(),y!==t?(A=Po(),A!==t?(F=mr(),F!==t?(B=H(),B!==t?(y=[y,A,F,B],u=y):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)):(m=u,u=t),u}function On(){var u,y,A,F,B,Q,J,he,Oe,Ae,qe,Fe,Ue,Te;return u=m,y=qn(),y!==t?(A=H(),A!==t?(F=be(),F!==t?(B=H(),B!==t?(n.charCodeAt(m)===59?(Q=ie,m++):(Q=t,z===0&&M(_e)),Q!==t?(J=H(),J!==t?(he=an(),he!==t?(oe=u,y=Me(y,F,he),u=y):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)):(m=u,u=t),u===t&&(u=m,y=qn(),y!==t?(A=H(),A!==t?(n.charCodeAt(m)===91?(F=tt,m++):(F=t,z===0&&M($e)),F!==t?(B=H(),B!==t?(Q=$o(),Q!==t?(J=H(),J!==t?(n.charCodeAt(m)===93?(he=ht,m++):(he=t,z===0&&M(ao)),he!==t?(Oe=H(),Oe!==t?(Ae=be(),Ae!==t?(qe=H(),qe!==t?(n.charCodeAt(m)===59?(Fe=ie,m++):(Fe=t,z===0&&M(_e)),Fe!==t?(Ue=H(),Ue!==t?(Te=an(),Te!==t?(oe=u,y=oo(y,Q,Ae,Te),u=y):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)):(m=u,u=t),u===t&&(u=m,y=qn(),y!==t?(A=H(),A!==t?(n.charCodeAt(m)===40?(F=s,m++):(F=t,z===0&&M(a)),F!==t?(B=H(),B!==t?(Q=Mo(),Q!==t?(J=H(),J!==t?(n.charCodeAt(m)===41?(he=o,m++):(he=t,z===0&&M(l)),he!==t?(Oe=H(),Oe!==t?(Ae=be(),Ae!==t?(qe=H(),qe!==t?(n.charCodeAt(m)===59?(Fe=ie,m++):(Fe=t,z===0&&M(_e)),Fe!==t?(Ue=H(),Ue!==t?(Te=an(),Te!==t?(oe=u,y=co(y,Q,Ae,Te),u=y):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)):(m=u,u=t)):(m=u,u=t),u===t&&(u=Do()))),u}function Mo(){var u,y,A,F,B,Q,J;if(u=m,y=be(),y!==t){for(A=[],F=m,n.charCodeAt(m)===44?(B=Mi,m++):(B=t,z===0&&M($i)),B!==t?(Q=H(),Q!==t?(J=be(),J!==t?(oe=F,B=T(y,J),F=B):(m=F,F=t)):(m=F,F=t)):(m=F,F=t);F!==t;)A.push(F),F=m,n.charCodeAt(m)===44?(B=Mi,m++):(B=t,z===0&&M($i)),B!==t?(Q=H(),Q!==t?(J=be(),J!==t?(oe=F,B=T(y,J),F=B):(m=F,F=t)):(m=F,F=t)):(m=F,F=t);A!==t?(oe=u,y=fo(y,A),u=y):(m=u,u=t)}else m=u,u=t;return u}function qn(){var u,y,A,F;return n.substr(m,3)===Oi?(u=Oi,m+=3):(u=t,z===0&&M(lo)),u===t&&(n.substr(m,4)===qi?(u=qi,m+=4):(u=t,z===0&&M(ho)),u===t&&(n.substr(m,5)===Ui?(u=Ui,m+=5):(u=t,z===0&&M(uo)),u===t&&(n.substr(m,6)===Hi?(u=Hi,m+=6):(u=t,z===0&&M(go)),u===t&&(n.substr(m,4)===Vi?(u=Vi,m+=4):(u=t,z===0&&M(po)),u===t&&(n.substr(m,5)===Zi?(u=Zi,m+=5):(u=t,z===0&&M(mo)),u===t&&(n.substr(m,5)===Gi?(u=Gi,m+=5):(u=t,z===0&&M(_o)),u===t&&(n.substr(m,4)===ji?(u=ji,m+=4):(u=t,z===0&&M(bo)),u===t&&(n.substr(m,6)===Ki?(u=Ki,m+=6):(u=t,z===0&&M(wo)),u===t&&(n.substr(m,7)===Wi?(u=Wi,m+=7):(u=t,z===0&&M(yo)),u===t&&(n.substr(m,4)===Qi?(u=Qi,m+=4):(u=t,z===0&&M(So)),u===t&&(n.substr(m,6)===Yi?(u=Yi,m+=6):(u=t,z===0&&M(Eo)),u===t&&(n.substr(m,6)===Xi?(u=Xi,m+=6):(u=t,z===0&&M(Co)),u===t&&(n.substr(m,3)===Ji?(u=Ji,m+=3):(u=t,z===0&&M(xo)),u===t&&(u=m,y=dr(),y!==t?(A=H(),A!==t?(F=gr(),F!==t?(oe=u,y=ko(y,F),u=y):(m=u,u=t)):(m=u,u=t)):(m=u,u=t))))))))))))))),u}function $o(){var u;return u=Oo(),u===t&&(u=be()),u}function be(){var u,y,A,F,B;if(u=m,y=m,vo.test(n.charAt(m))?(A=n.charAt(m),m++):(A=t,z===0&&M(Io)),A!==t){for(F=[],er.test(n.charAt(m))?(B=n.charAt(m),m++):(B=t,z===0&&M(tr));B!==t;)F.push(B),er.test(n.charAt(m))?(B=n.charAt(m),m++):(B=t,z===0&&M(tr));F!==t?(A=[A,F],y=A):(m=y,y=t)}else m=y,y=t;return y!==t&&(oe=u,y=Ao()),u=y,u}function mr(){var u,y,A;for(u=m,y=[],nr.test(n.charAt(m))?(A=n.charAt(m),m++):(A=t,z===0&&M(ir));A!==t;)y.push(A),nr.test(n.charAt(m))?(A=n.charAt(m),m++):(A=t,z===0&&M(ir));return y!==t&&(oe=u,y=Fo(y)),u=y,u}function Oo(){var u,y,A,F;if(z++,u=m,y=H(),y!==t){if(A=[],rr.test(n.charAt(m))?(F=n.charAt(m),m++):(F=t,z===0&&M(sr)),F!==t)for(;F!==t;)A.push(F),rr.test(n.charAt(m))?(F=n.charAt(m),m++):(F=t,z===0&&M(sr));else A=t;A!==t?(oe=u,y=No(),u=y):(m=u,u=t)}else m=u,u=t;return z--,u===t&&(y=t,z===0&&M(To)),u}function H(){var u,y;for(z++,u=[],ar.test(n.charAt(m))?(y=n.charAt(m),m++):(y=t,z===0&&M(or));y!==t;)u.push(y),ar.test(n.charAt(m))?(y=n.charAt(m),m++):(y=t,z===0&&M(or));return z--,u===t&&(y=t,z===0&&M(Lo)),u}if(sn=i(),sn!==t&&m===n.length)return sn;throw sn!==t&&m<n.length&&M(Bo()),Ro($n,Ce<n.length?n.charAt(Ce):null,Ce<n.length?hr(Ce,Ce+1):hr(Ce,Ce))}var $a={SyntaxError:Et,parse:uu};const du=$a,gu=`table bigChain
"bigChain pairwise alignment"
    (
    string chrom;       "Reference sequence chromosome or scaffold"
    uint   chromStart;  "Start position in chromosome"
    uint   chromEnd;    "End position in chromosome"
    string name;        "Name or ID of item, ideally both human readable and unique"
    uint score;         "Score (0-1000)"
    char[1] strand;     "+ or - for strand"
    uint tSize;         "size of target sequence"
    string qName;       "name of query sequence"
    uint qSize;         "size of query sequence"
    uint qStart;        "start of alignment on query sequence"
    uint qEnd;          "end of alignment on query sequence"
    uint chainScore;    "score from chain"
    )`,pu=`table bigGenePred
"bigGenePred gene models"
   (
   string chrom;       "Reference sequence chromosome or scaffold"
   uint   chromStart;  "Start position in chromosome"
   uint   chromEnd;    "End position in chromosome"
   string name;        "Name or ID of item, ideally both human readable and unique"
   uint score;         "Score (0-1000)"
   char[1] strand;     "+ or - for strand"
   uint thickStart;    "Start of where display should be thick (start codon)"
   uint thickEnd;      "End of where display should be thick (stop codon)"
   uint reserved;       "RGB value (use R,G,B string in input file)"
   int blockCount;     "Number of blocks"
   int[blockCount] blockSizes; "Comma separated list of block sizes"
   int[blockCount] chromStarts; "Start positions relative to chromStart"
   string name2;       "Alternative/human readable name"
   string cdsStartStat; "Status of CDS start annotation (none, unknown, incomplete, or complete)"
   string cdsEndStat;   "Status of CDS end annotation (none, unknown, incomplete, or complete)"
   int[blockCount] exonFrames; "Exon frame {0,1,2}, or -1 if no frame for exon"
   string type;        "Transcript type"
   string geneName;    "Primary identifier for gene"
   string geneName2;   "Alternative/human readable gene name"
   string geneType;    "Gene type"
   )`,mu=`table interact
"interaction between two regions"
    (
    string chrom;        "Chromosome (or contig, scaffold, etc.). For interchromosomal, use 2 records"
    uint chromStart;     "Start position of lower region. For interchromosomal, set to chromStart of this region"
    uint chromEnd;       "End position of upper region. For interchromosomal, set to chromEnd of this region"
    string name;         "Name of item, for display.  Usually 'sourceName/targetName/exp' or empty"
    uint score;          "Score (0-1000)"
    double value;        "Strength of interaction or other data value. Typically basis for score"
    string exp;          "Experiment name (metadata for filtering). Use . if not applicable"
    string color;        "Item color.  Specified as r,g,b or hexadecimal #RRGGBB or html color name, as in //www.w3.org/TR/css3-color/#html4. Use 0 and spectrum setting to shade by score"
    string sourceChrom;  "Chromosome of source region (directional) or lower region. For non-directional interchromosomal, chrom of this region."
    uint sourceStart;    "Start position in chromosome of source/lower/this region"
    uint sourceEnd;      "End position in chromosome of source/lower/this region"
    string sourceName;   "Identifier of source/lower/this region"
    string sourceStrand; "Orientation of source/lower/this region: + or -.  Use . if not applicable"
    string targetChrom;  "Chromosome of target region (directional) or upper region. For non-directional interchromosomal, chrom of other region"
    uint targetStart;    "Start position in chromosome of target/upper/this region"
    uint targetEnd;      "End position in chromosome of target/upper/this region"
    string targetName;   "Identifier of target/upper/this region"
    string targetStrand; "Orientation of target/upper/this region: + or -.  Use . if not applicable"

    )`,_u=`table bigLink
"bigLink pairwise alignment"
    (
    string chrom;       "Reference sequence chromosome or scaffold"
    uint   chromStart;  "Start position in chromosome"
    uint   chromEnd;    "End position in chromosome"
    string name;        "Name or ID of item, ideally both human readable and unique"
    uint qStart;        "start of alignment on query sequence"
    )`,bu=`table bedMaf
"Bed3 with MAF block"
    (
    string chrom;      "Reference sequence chromosome or scaffold"
    uint   chromStart; "Start position in chromosome"
    uint   chromEnd;   "End position in chromosome"
    lstring mafBlock;   "MAF block"
    )`,wu=`table bigNarrowPeak
"BED6+4 Peaks of signal enrichment based on pooled, normalized (interpreted) data."
(
    string chrom;        "Reference sequence chromosome or scaffold"
    uint   chromStart;   "Start position in chromosome"
    uint   chromEnd;     "End position in chromosome"
    string name;	 "Name given to a region (preferably unique). Use . if no name is assigned"
    uint   score;        "Indicates how dark the peak will be displayed in the browser (0-1000) "
    char[1]  strand;     "+ or - or . for unknown"
    float  signalValue;  "Measurement of average enrichment for the region"
    float  pValue;       "Statistical significance of signal value (-log10). Set to -1 if not used."
    float  qValue;       "Statistical significance with multiple-test correction applied (FDR -log10). Set to -1 if not used."
    int   peak;         "Point-source called for this peak; 0-based offset from chromStart. Set to -1 if no point-source called."
)`,yu=`table bigPsl
"bigPsl pairwise alignment"
    (
    string chrom;       "Reference sequence chromosome or scaffold"
    uint   chromStart;  "Start position in chromosome"
    uint   chromEnd;    "End position in chromosome"
    string name;        "Name or ID of item, ideally both human readable and unique"
    uint score;         "Score (0-1000)"
    char[1] strand;     "+ or - indicates whether the query aligns to the + or - strand on the reference"
    uint thickStart;    "Start of where display should be thick (start codon)"
    uint thickEnd;      "End of where display should be thick (stop codon)"
    uint reserved;       "RGB value (use R,G,B string in input file)"
    int blockCount;     "Number of blocks"
    int[blockCount] blockSizes; "Comma separated list of block sizes"
    int[blockCount] chromStarts; "Start positions relative to chromStart"

    uint    oChromStart;"Start position in other chromosome"
    uint    oChromEnd;  "End position in other chromosome"
    char[1] oStrand;    "+ or -, - means that psl was reversed into BED-compatible coordinates"
    uint    oChromSize; "Size of other chromosome."
    int[blockCount] oChromStarts; "Start positions relative to oChromStart or from oChromStart+oChromSize depending on strand"

    lstring  oSequence;  "Sequence on other chrom (or empty)"
    string   oCDS;       "CDS in NCBI format"

    uint    chromSize;"Size of target chromosome"

    uint match;        "Number of bases matched."
    uint misMatch; " Number of bases that don't match "
    uint repMatch; " Number of bases that match but are part of repeats "
    uint nCount;   " Number of 'N' bases "
    uint seqType;    "0=empty, 1=nucleotide, 2=amino_acid"
    )`,Su=`table defaultBedSchema
"BED12"
    (
    string chrom;      "The name of the chromosome (e.g. chr3, chrY, chr2_random) or scaffold (e.g. scaffold10671)."
    uint   chromStart; "The starting position of the feature in the chromosome or scaffold. The first base in a chromosome is numbered 0."
    uint   chromEnd;   "The ending position of the feature in the chromosome or scaffold. The chromEnd base is not included in the display of the feature. For example, the first 100 bases of a chromosome are defined as chromStart=0, chromEnd=100, and span the bases numbered 0-99."
    string   name;   "Defines the name of the BED line."
    float   score;   "Feature score, doesn't care about the 0-1000 limit as in bed"
    char   strand;   "Defines the strand. Either '.' (=no strand) or '+' or '-'"
    uint thickStart; "The starting position at which the feature is drawn thickly (for example, the start codon in gene displays). When there is no thick part, thickStart and thickEnd are usually set to the chromStart position."
    uint thickEnd; "The ending position at which the feature is drawn thickly (for example the stop codon in gene displays)."
    string itemRgb; "An RGB value of the form R,G,B (e.g. 255,0,0). "
    uint blockCount; " The number of blocks (exons) in the BED line."
    uint[blockCount] blockSizes; " A comma-separated list of the block sizes. The number of items in this list should correspond to blockCount."
    uint[blockCount] blockStarts; "A comma-separated list of block starts. All of the blockStart positions should be calculated relative to chromStart. The number of items in this list should correspond to blockCount."
    )`,Eu=`table mafFrames
"codon frame assignment for MAF components"
    (
    string chrom;      "Reference sequence chromosome or scaffold"
    uint   chromStart; "Start range in chromosome"
    uint   chromEnd;   "End range in chromosome"
    string src;        "Name of sequence source in MAF"
    ubyte frame;       "frame (0,1,2) for first base(+) or last bast(-)"
    char[1] strand;    "+ or -"
    string name;       "Name of gene used to define frame"
    int    prevFramePos;  "target position of the previous base (in transcription direction) that continues this frame, or -1 if none, or frame not contiguous"
    int    nextFramePos;  "target position of the next base (in transcription direction) that continues this frame, or -1 if none, or frame not contiguous"
    ubyte  isExonStart;  "does this start the CDS portion of an exon?"
    ubyte  isExonEnd;    "does this end the CDS portion of an exon?"
    )`,Cu=`table mafSummary
"Positions and scores for alignment blocks"
    (
    string chrom;      "Reference sequence chromosome or scaffold"
    uint   chromStart; "Start position in chromosome"
    uint   chromEnd;   "End position in chromosome"
    string src;        "Sequence name or database of alignment"
    float  score;      "Floating point score."
    char[1] leftStatus;  "Gap/break annotation for preceding block"
    char[1] rightStatus; "Gap/break annotation for following block"
    )`,xu=Object.freeze(Object.defineProperty({__proto__:null,bigChain:gu,bigGenePred:pu,bigInteract:mu,bigLink:_u,bigMaf:bu,bigNarrowPeak:wu,bigPsl:yu,defaultBedSchema:Su,mafFrames:Eu,mafSummary:Cu},Symbol.toStringTag,{value:"Module"})),fi=Object.fromEntries(Object.entries(xu).map(([n,e])=>[n,$a.parse(e.trim())]));function li(n){const e=["uint","int","float","long"];return{...n,fields:n.fields.map(t=>({...t,isArray:t.size&&t.type!=="char",arrayIsNumeric:t.size&&e.includes(t.type),isNumeric:!t.size&&e.includes(t.type)}))}}const ku={".":0,"-":-1,"+":1};function vu(n){var e;return n.length>=12&&!Number.isNaN(parseInt(n[9],10))&&((e=n[10])===null||e===void 0?void 0:e.split(",").filter(t=>!!t).length)===parseInt(n[9],10)}class Wd{constructor(e={}){if(e.autoSql)this.autoSql=li(du.parse(e.autoSql));else if(e.type){if(!fi[e.type])throw new Error("Type not found");this.autoSql=li(fi[e.type])}else this.autoSql=li(fi.defaultBedSchema),this.attemptDefaultBed=!0}parseLine(e,t={}){const{autoSql:r}=this,{uniqueId:i}=t,s=Array.isArray(e)?e:e.split("	");let a={};if(!this.attemptDefaultBed||this.attemptDefaultBed&&vu(s))for(let o=0;o<r.fields.length;o++){const l=r.fields[o];let c=s[o];const{isNumeric:f,isArray:g,arrayIsNumeric:d,name:h}=l;if(c==null)break;if(c!=="."){if(f){const p=Number(c);c=Number.isNaN(p)?c:p}else g&&(c=c.split(","),c[c.length-1]===""&&c.pop(),d&&(c=c.map(p=>Number(p))));a[h]=c}}else{const o=["chrom","chromStart","chromEnd","name"];a=Object.fromEntries(s.map((l,c)=>[o[c]||"field"+c,l])),a.chromStart=+a.chromStart,a.chromEnd=+a.chromEnd,Number.isNaN(Number.parseFloat(a.field4))||(a.score=+a.field4,delete a.field4),(a.field5==="+"||a.field5==="-")&&(a.strand=a.field5,delete a.field5)}return i&&(a.uniqueId=i),a.strand=ku[a.strand]||0,a.chrom=decodeURIComponent(a.chrom),a}}class Iu{constructor(e={}){if(!(e.maxSize&&e.maxSize>0))throw new TypeError("`maxSize` must be a number greater than 0");this.maxSize=e.maxSize,this.cache=new Map,this.oldCache=new Map,this._size=0}_set(e,t){this.cache.set(e,t),this._size++,this._size>=this.maxSize&&(this._size=0,this.oldCache=this.cache,this.cache=new Map)}get(e){if(this.cache.has(e))return this.cache.get(e);if(this.oldCache.has(e)){const t=this.oldCache.get(e);return this.oldCache.delete(e),this._set(e,t),t}}set(e,t){return this.cache.has(e)?this.cache.set(e,t):this._set(e,t),this}has(e){return this.cache.has(e)||this.oldCache.has(e)}peek(e){if(this.cache.has(e))return this.cache.get(e);if(this.oldCache.has(e))return this.oldCache.get(e)}delete(e){const t=this.cache.delete(e);return t&&this._size--,this.oldCache.delete(e)||t}clear(){this.cache.clear(),this.oldCache.clear(),this._size=0}*keys(){for(const[e]of this)yield e}*values(){for(const[,e]of this)yield e}*[Symbol.iterator](){for(const e of this.cache)yield e;for(const e of this.oldCache){const[t]=e;this.cache.has(t)||(yield e)}}get size(){let e=0;for(const t of this.oldCache.keys())this.cache.has(t)||e++;return this._size+e}}var Au=Iu;const Oa=Au;function qa(n){if(n.greaterThan(Number.MAX_SAFE_INTEGER)||n.lessThan(Number.MIN_SAFE_INTEGER))throw new Error("integer overflow");return n.toNumber()}class Fu extends Error{}function Ve(n){if(!!n&&n.aborted){if(typeof DOMException<"u")throw new DOMException("aborted","AbortError");{const e=new Fu("aborted");throw e.code="ERR_ABORTED",e}}}function Tu(n,e){return e.minv.blockPosition-n.maxv.blockPosition<65e3&&e.maxv.blockPosition-n.minv.blockPosition<5e6}function Ua(n,e){const t=[];let r=null;return n.length===0?n:(n.sort(function(i,s){const a=i.minv.blockPosition-s.minv.blockPosition;return a!==0?a:i.minv.dataPosition-s.minv.dataPosition}),n.forEach(i=>{(!e||i.maxv.compareTo(e)>0)&&(r===null?(t.push(i),r=i):Tu(r,i)?i.maxv.compareTo(r.maxv)>0&&(r.maxv=i.maxv):(t.push(i),r=i))}),t)}class Ai{constructor(e,t){this.blockPosition=e,this.dataPosition=t}toString(){return`${this.blockPosition}:${this.dataPosition}`}compareTo(e){return this.blockPosition-e.blockPosition||this.dataPosition-e.dataPosition}static min(...e){let t,r=0;for(;!t;r+=1)t=e[r];for(;r<e.length;r+=1)t.compareTo(e[r])>0&&(t=e[r]);return t}}function wt(n,e=0,t=!1){if(t)throw new Error("big-endian virtual file offsets not implemented");return new Ai(n[e+7]*1099511627776+n[e+6]*4294967296+n[e+5]*16777216+n[e+4]*65536+n[e+3]*256+n[e+2],n[e+1]<<8|n[e])}class Ln{constructor(e,t,r,i=void 0){this.minv=e,this.maxv=t,this.bin=r,this._fetchedSize=i}toUniqueString(){return`${this.minv}..${this.maxv} (bin ${this.bin}, fetchedSize ${this.fetchedSize()})`}toString(){return this.toUniqueString()}compareTo(e){return this.minv.compareTo(e.minv)||this.maxv.compareTo(e.maxv)||this.bin-e.bin}fetchedSize(){return this._fetchedSize!==void 0?this._fetchedSize:this.maxv.blockPosition+(1<<16)-this.minv.blockPosition}}class Ha{constructor({filehandle:e,renameRefSeqs:t=r=>r}){this.filehandle=e,this.renameRefSeq=t}async getMetadata(e={}){const{indices:t,...r}=await this.parse(e);return r}_findFirstData(e,t){return e?e.compareTo(t)>0?t:e:t}async parse(e={}){return this._parseCache||(this._parseCache=new De({cache:new Oa({maxSize:1}),fill:()=>this._parse(e)})),this._parseCache.get("index",null,void 0)}async hasRefSeq(e,t={}){return!!((await this.parse(t)).indices[e]||{}).binIndex}}const Nu=21578324,ws=14;function Lu(n,e){return n+=1,e-=1,[[0,0],[1+(n>>26),1+(e>>26)],[9+(n>>23),9+(e>>23)],[73+(n>>20),73+(e>>20)],[585+(n>>17),585+(e>>17)],[4681+(n>>14),4681+(e>>14)]]}class hi extends Ha{async lineCount(e,t={}){const r=await this.parse(t);if(!r)return-1;const i=r.refNameToId[e];if(!r.indices[i])return-1;const{stats:a}=r.indices[i];return a?a.lineCount:-1}async _parse(e={}){const t=await Je(await this.filehandle.readFile(e));if(Ve(e.signal),t.readUInt32LE(0)!==Nu)throw new Error("Not a TBI file");const r=t.readInt32LE(4),i=t.readInt32LE(8),s=i&65536?"zero-based-half-open":"1-based-closed",o={0:"generic",1:"SAM",2:"VCF"}[i&15];if(!o)throw new Error(`invalid Tabix preset format flags ${i}`);const l={ref:t.readInt32LE(12),start:t.readInt32LE(16),end:t.readInt32LE(20)},c=t.readInt32LE(24),f=5,g=((1<<(f+1)*3)-1)/7,d=2**(14+f*3),h=c?String.fromCharCode(c):null,p=t.readInt32LE(28),b=t.readInt32LE(32),{refNameToId:w,refIdToName:S}=this._parseNameBytes(t.slice(36,36+b));let E=36+b,v;return{indices:new Array(r).fill(0).map(()=>{const k=t.readInt32LE(E);E+=4;const I={};let C;for(let L=0;L<k;L+=1){const P=t.readUInt32LE(E);if(E+=4,P>g+1)throw new Error("tabix index contains too many bins, please use a CSI index");if(P===g+1){const ie=t.readInt32LE(E);E+=4,ie===2&&(C=this.parsePseudoBin(t,E)),E+=16*ie}else{const ie=t.readInt32LE(E);E+=4;const _e=new Array(ie);for(let Me=0;Me<ie;Me+=1){const tt=wt(t,E),$e=wt(t,E+8);E+=16,v=this._findFirstData(v,tt),_e[Me]=new Ln(tt,$e,P)}I[P]=_e}}const T=t.readInt32LE(E);E+=4;const N=new Array(T);for(let L=0;L<T;L+=1)N[L]=wt(t,E),E+=8,v=this._findFirstData(v,N[L]);return{binIndex:I,linearIndex:N,stats:C}}),metaChar:h,maxBinNumber:g,maxRefLength:d,skipLines:p,firstDataLine:v,columnNumbers:l,coordinateType:s,format:o,refIdToName:S,refNameToId:w,maxBlockSize:1<<16}}parsePseudoBin(e,t){return{lineCount:qa(Ct.fromBytesLE(e.slice(t+16,t+24),!0))}}_parseNameBytes(e){let t=0,r=0;const i=[],s={};for(let a=0;a<e.length;a+=1)if(!e[a]){if(r<a){let o=e.toString("utf8",r,a);o=this.renameRefSeq(o),i[t]=o,s[o]=t}r=a+1,t+=1}return{refNameToId:s,refIdToName:i}}async blocksForRange(e,t,r,i={}){t<0&&(t=0);const s=await this.parse(i);if(!s)return[];const a=s.refNameToId[e],o=s.indices[a];if(!o)return[];(o.linearIndex.length?o.linearIndex[t>>ws>=o.linearIndex.length?o.linearIndex.length-1:t>>ws]:new Ai(0,0))||console.warn("querying outside of possible tabix range");const c=Lu(t,r),f=[];for(const[b,w]of c)for(let S=b;S<=w;S++)if(o.binIndex[S]){const E=o.binIndex[S];for(let v=0;v<E.length;++v)f.push(new Ln(E[v].minv,E[v].maxv,S))}const g=o.linearIndex.length;let d=null;const h=Math.min(t>>14,g-1),p=Math.min(r>>14,g-1);for(let b=h;b<=p;++b){const w=o.linearIndex[b];w&&(!d||w.compareTo(d)<0)&&(d=w)}return Ua(f,d)}}const Bu=21582659,Ru=38359875;function zu(n,e){return n*2**e}function ys(n,e){return Math.floor(n/2**e)}class Ss extends Ha{constructor(e){super(e),this.maxBinNumber=0,this.depth=0,this.minShift=0}async lineCount(e,t={}){const r=await this.parse(t);if(!r)return-1;const i=r.refNameToId[e];if(!r.indices[i])return-1;const{stats:a}=r.indices[i];return a?a.lineCount:-1}async indexCov(){throw new Error("CSI indexes do not support indexcov")}parseAuxData(e,t,r){if(r<30)return{refIdToName:[],refNameToId:{}};const i=e.readInt32LE(t),s=i&65536?"zero-based-half-open":"1-based-closed",a={0:"generic",1:"SAM",2:"VCF"}[i&15];if(!a)throw new Error(`invalid Tabix preset format flags ${i}`);const o={ref:e.readInt32LE(t+4),start:e.readInt32LE(t+8),end:e.readInt32LE(t+12)},l=e.readInt32LE(t+16),c=l?String.fromCharCode(l):"",f=e.readInt32LE(t+20),g=e.readInt32LE(t+24),{refIdToName:d,refNameToId:h}=this._parseNameBytes(e.slice(t+28,t+28+g));return{refIdToName:d,refNameToId:h,skipLines:f,metaChar:c,columnNumbers:o,format:a,coordinateType:s}}_parseNameBytes(e){let t=0,r=0;const i=[],s={};for(let a=0;a<e.length;a+=1)if(!e[a]){if(r<a){let o=e.toString("utf8",r,a);o=this.renameRefSeq(o),i[t]=o,s[o]=t}r=a+1,t+=1}return{refNameToId:s,refIdToName:i}}async _parse(e={}){const t=await Je(await this.filehandle.readFile(e));let r;if(t.readUInt32LE(0)===Bu)r=1;else if(t.readUInt32LE(0)===Ru)r=2;else throw new Error("Not a CSI file");this.minShift=t.readInt32LE(4),this.depth=t.readInt32LE(8),this.maxBinNumber=((1<<(this.depth+1)*3)-1)/7;const i=2**(this.minShift+this.depth*3),s=t.readInt32LE(12);let a={refIdToName:[],refNameToId:{}};s&&(a=this.parseAuxData(t,16,s));const o=t.readInt32LE(16+s);let l,c=16+s+4;const f=new Array(o).fill(0).map(()=>{const g=t.readInt32LE(c);c+=4;const d={};let h;for(let p=0;p<g;p+=1){const b=t.readUInt32LE(c);if(b>this.maxBinNumber)h=this.parsePseudoBin(t,c+4),c+=4+8+4+16+16;else{const w=wt(t,c+4);l=this._findFirstData(l,w);const S=t.readInt32LE(c+12);c+=16;const E=new Array(S);for(let v=0;v<S;v+=1){const _=wt(t,c),k=wt(t,c+8);c+=16,E[v]=new Ln(_,k,b)}d[b]=E}}return{binIndex:d,stats:h}});return{...a,csi:!0,refCount:o,maxBlockSize:1<<16,firstDataLine:l,csiVersion:r,indices:f,depth:this.depth,maxBinNumber:this.maxBinNumber,maxRefLength:i}}parsePseudoBin(e,t){return{lineCount:qa(Ct.fromBytesLE(Array.prototype.slice.call(e,t+28,t+36),!0))}}async blocksForRange(e,t,r,i={}){t<0&&(t=0);const s=await this.parse(i);if(!s)return[];const a=s.refNameToId[e],o=s.indices[a];if(!o)return[];const l=this.reg2bins(t,r),c=[];for(const[f,g]of l)for(let d=f;d<=g;d++)if(o.binIndex[d]){const h=o.binIndex[d];for(let p=0;p<h.length;++p)c.push(new Ln(h[p].minv,h[p].maxv,d))}return Ua(c,new Ai(0,0))}reg2bins(e,t){e-=1,e<1&&(e=1),t>2**50&&(t=2**34),t-=1;let r=0,i=0,s=this.minShift+this.depth*3;const a=[];for(;r<=this.depth;s-=3,i+=zu(1,r*3),r+=1){const o=i+ys(e,s),l=i+ys(t,s);if(l-o+a.length>this.maxBinNumber)throw new Error(`query ${e}-${t} is too large for current binning scheme (shift ${this.minShift}, depth ${this.depth}), try a smaller query or a coarser index binning scheme`);a.push([o,l])}return a}}function Pu(n){return new Promise(e=>{setTimeout(e,n)})}class Qd{constructor({path:e,filehandle:t,tbiPath:r,tbiFilehandle:i,csiPath:s,csiFilehandle:a,chunkSizeLimit:o=5e7,renameRefSeqs:l=f=>f,chunkCacheSize:c=5*2**20}){if(t)this.filehandle=t;else if(e)this.filehandle=new X(e);else throw new TypeError("must provide either filehandle or path");if(i)this.index=new hi({filehandle:i,renameRefSeqs:l});else if(a)this.index=new Ss({filehandle:a,renameRefSeqs:l});else if(r)this.index=new hi({filehandle:new X(r),renameRefSeqs:l});else if(s)this.index=new Ss({filehandle:new X(s),renameRefSeqs:l});else if(e)this.index=new hi({filehandle:new X(`${e}.tbi`),renameRefSeqs:l});else throw new TypeError("must provide one of tbiFilehandle, tbiPath, csiFilehandle, or csiPath");this.chunkSizeLimit=o,this.renameRefSeq=l,this.chunkCache=new De({cache:new Oa({maxSize:Math.floor(c/(1<<16))}),fill:this.readChunk.bind(this)})}async getLines(e,t,r,i){let s,a={},o;if(typeof i>"u")throw new TypeError("line callback must be provided");if(typeof i=="function"?o=i:(a=i,o=i.lineCallback),e===void 0)throw new TypeError("must provide a reference sequence name");if(!o)throw new TypeError("line callback must be provided");const l=await this.index.getMetadata(a);if(Ve(s),t||(t=0),r||(r=l.maxRefLength),!(t<=r))throw new TypeError("invalid start and end coordinates. start must be less than or equal to end");if(t===r)return;const c=await this.index.blocksForRange(e,t,r,a);Ve(s);for(let g=0;g<c.length;g+=1){const d=c[g].fetchedSize();if(d>this.chunkSizeLimit)throw new Error(`Too much data. Chunk size ${d.toLocaleString()} bytes exceeds chunkSizeLimit of ${this.chunkSizeLimit.toLocaleString()}.`)}let f=Date.now();for(let g=0;g<c.length;g+=1){let d;const h=c[g],{buffer:p,cpositions:b,dpositions:w}=await this.chunkCache.get(h.toString(),h,s),S=(typeof TextDecoder<"u"?new TextDecoder("utf-8").decode(p):p.toString()).split(`
`);S.pop(),Ve(s);let E=h.minv.dataPosition,v;for(let _=0;_<S.length;_+=1){const k=S[_];for(v=0;E>=w[v];v+=1);const{startCoordinate:I,overlaps:C}=this.checkLine(l,e,t,r,k);if(d!==void 0&&I!==void 0&&d>I)throw new Error(`Lines not sorted by start coordinate (${d} > ${I}), this file is not usable with Tabix.`);if(d=I,C)o(k.trim(),b[v]*(1<<8)+(E-w[v]));else if(I!==void 0&&I>=r)return;E+=k.length+1,f-Date.now()>500&&(f=Date.now(),Ve(s),await Pu(1))}}}async getMetadata(e={}){return this.index.getMetadata(e)}async getHeaderBuffer(e={}){const{firstDataLine:t,metaChar:r,maxBlockSize:i}=await this.getMetadata(e);Ve(e.signal);const s=t&&t.blockPosition?t.blockPosition+i:i;let a=await this._readRegion(0,s,e);Ve(e.signal);try{a=await Je(a)}catch(o){throw console.error(o),new Error(`error decompressing block ${o.code} at 0 (length ${s}) ${o}`)}if(r){let o=-1;const l=`
`.charCodeAt(0),c=r.charCodeAt(0);for(let f=0;f<a.length&&!(f===o+1&&a[f]!==c);f+=1)a[f]===l&&(o=f);a=a.slice(0,o+1)}return a}async getHeader(e={}){const t=await this.getHeaderBuffer(e);return Ve(e.signal),t.toString("utf8")}async getReferenceSequenceNames(e={}){return(await this.getMetadata(e)).refIdToName}checkLine({columnNumbers:e,metaChar:t,coordinateType:r,format:i},s,a,o,l){if(l.charAt(0)===t)return{overlaps:!1};let{ref:c,start:f,end:g}=e;c||(c=0),f||(f=0),g||(g=0),i==="VCF"&&(g=8);const d=Math.max(c,f,g);let h=1,p=0,b="",w=-1/0;for(let S=0;S<l.length+1;S+=1)if(l[S]==="	"||S===l.length){if(h===c){if(this.renameRefSeq(l.slice(p,S))!==s)return{overlaps:!1}}else if(h===f){if(w=parseInt(l.slice(p,S),10),r==="1-based-closed"&&(w-=1),w>=o)return{startCoordinate:w,overlaps:!1};if((g===0||g===f)&&w+1<=a)return{startCoordinate:w,overlaps:!1}}else if(i==="VCF"&&h===4)b=l.slice(p,S);else if(h===g){let E;if(i==="VCF"?E=this._getVcfEnd(w,b,l.slice(p,S)):E=parseInt(l.slice(p,S),10),E<=a)return{overlaps:!1}}if(p=S+1,h+=1,h>d)break}return{startCoordinate:w,overlaps:!0}}_getVcfEnd(e,t,r){let i=e+t.length;const s=r.indexOf("SVTYPE=TRA")!==-1;if(r[0]!=="."&&!s){let a=";";for(let o=0;o<r.length;o+=1){if(a===";"&&r.slice(o,o+4)==="END="){let l=r.indexOf(";",o);l===-1&&(l=r.length),i=parseInt(r.slice(o+4,l),10);break}a=r[o]}}else if(s)return e+1;return i}async lineCount(e,t={}){return this.index.lineCount(e,t)}async _readRegion(e,t,r={}){const{bytesRead:i,buffer:s}=await this.filehandle.read($.Buffer.alloc(t),0,t,e,r);return i<t?s.slice(0,i):s}async readChunk(e,t={}){const r=await this._readRegion(e.minv.blockPosition,e.fetchedSize(),t);try{return Ws(r,e)}catch(i){throw new Error(`error decompressing chunk ${e.toString()} ${i}`)}}}var le={},en={},tn={};Object.defineProperty(tn,"__esModule",{value:!0});class Du extends Map{constructor(e,t={checkIndent:!0}){super();const{checkIndent:r}=t;this._checkIndent=r;let i;typeof e=="string"?i=e.trimEnd().split(/\r?\n/):e?i=e:i=[],this._keyAndCommentOrder=[],i.forEach(s=>{this.add(s)})}add(e){if(e==="")throw new Error("Invalid stanza, contained blank lines");if(e.trim().startsWith("#"))return this._keyAndCommentOrder.push(e.trim()),this;if(e.trimEnd().endsWith("\\")){const o=e.trimEnd().slice(0,-1);return this._continuedLine?this._continuedLine+=o.trimStart():this._continuedLine=o,this}let t=e;if(this._continuedLine&&(t=this._continuedLine+t.trimStart(),this._continuedLine=void 0),this.indent||this._checkIndent){const o=t.match(/^([ \t]+)/);if(this.indent===void 0)o?[,this.indent]=o:this.indent="";else if(this.indent===""&&o!==null||this.indent&&o&&this.indent!==o[1])throw new Error("Inconsistent indentation of stanza")}else this.indent="";const r=t.trim(),i=r.indexOf(" ");if(i===-1){if(!this.nameKey)throw new Error("First line in a stanza must have both a key and a value");return this.has(r)?this:(this._keyAndCommentOrder.push(r),super.set(r,""))}const s=r.slice(0,i),a=r.slice(i+1);if(this.has(s)&&a!==this.get(s))throw new Error(`Got duplicate key with a different value in stanza: "${s}" key has both ${this.get(s)} and ${a}`);return this._keyAndCommentOrder.push(s),this.nameKey||(this.nameKey=s,this.name=r.slice(i+1)),super.set(s,a)}set(e,t){if(typeof t!="string")throw new Error(`Value of ${e} must be a string, got ${typeof t}`);return super.set(e,t)}delete(e){if(e===this.nameKey)throw new Error("Cannot delete the first line in a stanza (you can still overwrite it with set()).");return this._keyAndCommentOrder.includes(e)&&(this._keyAndCommentOrder=this._keyAndCommentOrder.filter(t=>t!==e)),super.delete(e)}clear(){this._keyAndCommentOrder.length=0,this._continuedLine=void 0,this.indent=void 0,this.name=void 0,this.nameKey=void 0,super.clear()}toString(){if(this.size===0)return"";const e=[];return this._keyAndCommentOrder.forEach(t=>{t.startsWith("#")?e.push(`${this.indent}${t}`):e.push(`${this.indent}${t} ${this.get(t)}`.trimEnd())}),`${e.join(`
`)}
`}}tn.default=Du;var Mu=Ie&&Ie.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(en,"__esModule",{value:!0});const Es=Mu(tn);class $u extends Map{constructor(e,t={checkIndent:!0}){super();const{checkIndent:r}=t;this._checkIndent=r;let i;typeof e=="string"?i=e.trimEnd().split(/(?:[\t ]*\r?\n){2,}/):e?i=e:i=[],this._stanzaAndCommentOrder=[],i.forEach(s=>{this.add(s)})}add(e){if(e==="")throw new Error("Invalid stanza, was empty");if(e.trim().startsWith("#")){const r=e.trimEnd().split(/\r?\n/).map(i=>i.trim());if(r.every(i=>i.startsWith("#")))return this._stanzaAndCommentOrder.push(r.join(`
`)),this}const t=new Es.default(e,{checkIndent:this._checkIndent});if(!this.nameKey)this.nameKey=t.nameKey;else if(t.nameKey!==this.nameKey)throw new Error(`The first line in each stanza must have the same key. Saw both ${this.nameKey} and ${t.nameKey}`);if(!t.name)throw new Error(`No stanza name: ${t.name}`);if(this.has(t.name))throw new Error(`Got duplicate stanza name: ${t.name}`);return this._stanzaAndCommentOrder.push(t.name),super.set(t.name,t)}update(e,t){if(!(t instanceof Es.default))throw new Error(`Value of ${e} is not an RaStanza`);super.set(e,t)}delete(e){return this._stanzaAndCommentOrder.includes(e)&&(this._stanzaAndCommentOrder=this._stanzaAndCommentOrder.filter(t=>t!==e)),super.delete(e)}clear(){this._stanzaAndCommentOrder.length=0,this.nameKey=void 0,super.clear()}toString(){if(this.size===0)return"";const e=[];return this._stanzaAndCommentOrder.forEach(t=>{if(t.startsWith("#"))e.push(`${t}
`);else{const r=this.get(t);r&&e.push(r.toString())}}),e.join(`
`)}}en.default=$u;var Fi={},Ou=Ie&&Ie.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(Fi,"__esModule",{value:!0});const qu=Ou(en);class Uu extends qu.default{constructor(e){if(super(e,{checkIndent:!1}),this.nameKey!=="track")throw new Error(`trackDb has "${this.nameKey}" instead of "track" as the first line in each track`);this.forEach((t,r)=>{var i;const s=Array.from(t.keys()),a=[];if(["track","shortLabel"].forEach(d=>{s.includes(d)||a.push(d)}),a.length>0)throw new Error(`Track ${r} is missing required key(s): ${a.join(", ")}`);const l=["superTrack","compositeTrack","container","view"];if(!s.some(d=>l.includes(d))){if(!s.includes("bigDataUrl"))throw new Error(`Track ${r} is missing required key "bigDataUrl"`);if(!s.includes("type")){const d=this.settings(r);if(!Array.from(d.keys()).includes("type"))throw new Error(`Neither track ${r} nor any of its parent tracks have the required key "type"`)}}let c="",f=r;do f=(i=this.get(f))===null||i===void 0?void 0:i.get("parent"),f&&([f]=f.split(" "),c+="    ");while(f);const g=this.get(r);g&&(g.indent=c,this.set(r,g))})}settings(e){var t;if(!this.has(e))throw new Error(`Track ${e} does not exist`);const r=[e];let i=e;do i=(t=this.get(i))===null||t===void 0?void 0:t.get("parent"),i&&r.push(i);while(i);const s=new Map;return r.reverse(),r.forEach(a=>{var o;(o=this.get(a))===null||o===void 0||o.forEach((l,c)=>{s.set(c,l)})}),s}}Fi.default=Uu;var Ti={},Hu=Ie&&Ie.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(Ti,"__esModule",{value:!0});const Vu=Hu(tn);class Zu extends Vu.default{constructor(e){if(super(e),this.nameKey!=="hub")throw new Error('Hub file must begin with a line like "hub <hub_name>"');const t=["hub","shortLabel","longLabel","genomesFile","email","descriptionUrl"],r=[];if(this.forEach((s,a)=>{t.includes(a)||r.push(a)}),r.length>0)throw new Error(`Hub file has invalid entr${r.length===1?"y":"ies"}: ${r.join(", ")}`);const i=[];if(t.forEach(s=>{s!=="descriptionUrl"&&!this.get(s)&&i.push(s)}),i.length>0)throw new Error(`Hub file is missing required entr${i.length===1?"y":"ies"}: ${i.join(", ")}`)}}Ti.default=Zu;var Ni={},Gu=Ie&&Ie.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(Ni,"__esModule",{value:!0});const ju=Gu(en);class Ku extends ju.default{constructor(e){if(super(e),this.nameKey!=="genome")throw new Error('Genomes file must begin with a line like "genome <genome_name>"');const t=["genome","trackDb"];this.forEach((r,i)=>{const s=[];if(t.forEach(a=>{r.get(a)||s.push(a)}),s.length>0)throw new Error(`Genomes file entry ${i} is missing required entr${s.length===1?"y":"ies"}: ${s.join(", ")}`)})}}Ni.default=Ku;var nn=Ie&&Ie.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(le,"__esModule",{value:!0});var Va=le.GenomesFile=Ka=le.HubFile=ja=le.TrackDbFile=Ga=le.RaStanza=Za=le.RaFile=void 0;const Wu=nn(en);var Za=le.RaFile=Wu.default;const Qu=nn(tn);var Ga=le.RaStanza=Qu.default;const Yu=nn(Fi);var ja=le.TrackDbFile=Yu.default;const Xu=nn(Ti);var Ka=le.HubFile=Xu.default;const Ju=nn(Ni);Va=le.GenomesFile=Ju.default;const Yd=jo({__proto__:null,get GenomesFile(){return Va},get HubFile(){return Ka},get TrackDbFile(){return ja},get RaStanza(){return Ga},get RaFile(){return Za},default:le},[le]);function Mt(n){return n.replace(/%([0-9A-Fa-f]{2})/g,(e,t)=>String.fromCharCode(parseInt(t,16)))}function Wa(n,e){return String(e).replace(n,t=>`%${t.charCodeAt(0).toString(16).toUpperCase().padStart(2,"0")}`)}function Bt(n){return Wa(/[\n;\r\t=%&,\x00-\x1f\x7f-\xff]/g,n)}function Le(n){return Wa(/[\n\r\t%\x00-\x1f\x7f-\xff]/g,n)}function Qa(n){if(!(n&&n.length)||n===".")return{};const e={};return n.replace(/\r?\n$/,"").split(";").forEach(t=>{const r=t.split("=",2);if(!(r[1]&&r[1].length))return;r[0]=r[0].trim();let i=e[r[0].trim()];i||(i=[],e[r[0]]=i),i.push(...r[1].split(",").map(s=>s.trim()).map(Mt))}),e}function Ya(n){const e=n.split("	").map(r=>r==="."||r===""?null:r);return{seq_id:e[0]&&Mt(e[0]),source:e[1]&&Mt(e[1]),type:e[2]&&Mt(e[2]),start:e[3]===null?null:parseInt(e[3],10),end:e[4]===null?null:parseInt(e[4],10),score:e[5]===null?null:parseFloat(e[5]),strand:e[6],phase:e[7],attributes:e[8]===null?null:Qa(e[8])}}function Xa(n){const e=/^\s*##\s*(\S+)\s*(.*)/.exec(n);if(!e)return null;const[,t]=e;let[,,r]=e;const i={directive:t};if(r.length&&(r=r.replace(/\r?\n$/,""),i.value=r),t==="sequence-region"){const s=r.split(/\s+/,3);return{...i,seq_id:s[0],start:s[1]&&s[1].replace(/\D/g,""),end:s[2]&&s[2].replace(/\D/g,"")}}else if(t==="genome-build"){const[s,a]=r.split(/\s+/,2);return{...i,source:s,buildName:a}}return i}function Ja(n){const e=[];return Object.entries(n).forEach(([t,r])=>{if(!r)return;let i;r.hasOwnProperty("toString")?i=Bt(r.toString()):Array.isArray(r)?i=r.map(Bt).join(","):i=Bt(r),e.push(`${Bt(t)}=${i}`)}),e.length?e.join(";"):"."}function ed(n,e){const t=n.attributes===null||n.attributes===void 0?".":Ja(n.attributes),i=`${[n.seq_id===null?".":Le(n.seq_id),n.source===null?".":Le(n.source),n.type===null?".":Le(n.type),n.start===null?".":Le(n.start),n.end===null?".":Le(n.end),n.score===null?".":Le(n.score),n.strand===null?".":Le(n.strand),n.phase===null?".":Le(n.phase),t].join("	")}
`;return e[i]?"":(e[i]=!0,i)}function xn(n,e){if(Array.isArray(n))return n.map(r=>xn(r,e)).join("");const t=[ed(n,e)];return td(n)&&t.push(...n.child_features.map(r=>xn(r,e)),...n.derived_features.map(r=>xn(r,e))),t.join("")}function eo(n){return xn(n,{})}function to(n){let e=`##${n.directive}`;return n.value&&(e+=` ${n.value}`),e+=`
`,e}function no(n){return`# ${n.comment}
`}function Li(n){return`>${n.id}${n.description?` ${n.description}`:""}
${n.sequence}
`}function Bn(n){function e(t){return"attributes"in t?eo(t):"directive"in t?to(t):"sequence"in t?Li(t):"comment"in t?no(t):`# (invalid item found during format)
`}return Array.isArray(n)?n.map(e):e(n)}function td(n){return n.child_features!==void 0&&n.derived_features!==void 0}const nd=Object.freeze(Object.defineProperty({__proto__:null,unescape:Mt,escape:Bt,escapeColumn:Le,parseAttributes:Qa,parseFeature:Ya,parseDirective:Xa,formatAttributes:Ja,formatFeature:eo,formatDirective:to,formatComment:no,formatSequence:Li,formatItem:Bn},Symbol.toStringTag,{value:"Module"})),Cs={Parent:"child_features",Derives_from:"derived_features"};class xs{constructor(e){this.seqCallback=e,this.currentSequence=void 0}addLine(e){const t=/^>\s*(\S+)\s*(.*)/.exec(e);t?(this._flush(),this.currentSequence={id:t[1],sequence:""},t[2]&&(this.currentSequence.description=t[2].trim())):this.currentSequence&&/\S/.test(e)&&(this.currentSequence.sequence+=e.replace(/\s/g,""))}_flush(){this.currentSequence&&this.seqCallback(this.currentSequence)}finish(){this._flush()}}class io{constructor(e){this.fastaParser=void 0,this.eof=!1,this.lineNumber=0,this._underConstructionTopLevel=[],this._underConstructionById={},this._completedReferences={},this._underConstructionOrphans={};const t=()=>{};this.featureCallback=e.featureCallback||t,this.endCallback=e.endCallback||t,this.commentCallback=e.commentCallback||t,this.errorCallback=e.errorCallback||t,this.directiveCallback=e.directiveCallback||t,this.sequenceCallback=e.sequenceCallback||t,this.bufferSize=e.bufferSize===void 0?1e3:e.bufferSize}addLine(e){if(this.fastaParser){this.fastaParser.addLine(e);return}if(this.eof)return;if(this.lineNumber+=1,/^\s*[^#\s>]/.test(e)){this._bufferLine(e);return}const t=/^\s*(#+)(.*)/.exec(e);if(t){const[,r]=t;let[,,i]=t;if(r.length===3)this._emitAllUnderConstructionFeatures();else if(r.length===2){const s=Xa(e);s&&(s.directive==="FASTA"?(this._emitAllUnderConstructionFeatures(),this.eof=!0,this.fastaParser=new xs(this.sequenceCallback)):this._emitItem(s))}else i=i.replace(/\s*/,""),this._emitItem({comment:i})}else if(!/^\s*$/.test(e))if(/^\s*>/.test(e))this._emitAllUnderConstructionFeatures(),this.eof=!0,this.fastaParser=new xs(this.sequenceCallback),this.fastaParser.addLine(e);else{const r=e.replace(/\r?\n?$/g,"");throw new Error(`GFF3 parse error.  Cannot parse '${r}'.`)}}finish(){this._emitAllUnderConstructionFeatures(),this.fastaParser&&this.fastaParser.finish(),this.endCallback()}_emitItem(e){Array.isArray(e)?this.featureCallback(e):"directive"in e?this.directiveCallback(e):"comment"in e&&this.commentCallback(e)}_enforceBufferSizeLimit(e=0){const t=r=>{r&&Array.isArray(r)&&r[0].attributes&&r[0].attributes.ID&&r[0].attributes.ID[0]&&(r[0].attributes.ID.forEach(s=>{delete this._underConstructionById[s],delete this._completedReferences[s]}),r.forEach(s=>{s.child_features&&s.child_features.forEach(a=>t(a)),s.derived_features&&s.derived_features.forEach(a=>t(a))}))};for(;this._underConstructionTopLevel.length+e>this.bufferSize;){const r=this._underConstructionTopLevel.shift();r&&(this._emitItem(r),t(r))}}_emitAllUnderConstructionFeatures(){if(this._underConstructionTopLevel.forEach(this._emitItem.bind(this)),this._underConstructionTopLevel=[],this._underConstructionById={},this._completedReferences={},Array.from(Object.values(this._underConstructionOrphans)).length)throw new Error(`some features reference other features that do not exist in the file (or in the same '###' scope). ${JSON.stringify(this._underConstructionOrphans)}`)}_bufferLine(e){var t,r,i;const a={...Ya(e),child_features:[],derived_features:[]},o=((t=a.attributes)===null||t===void 0?void 0:t.ID)||[],l=((r=a.attributes)===null||r===void 0?void 0:r.Parent)||[],c=((i=a.attributes)===null||i===void 0?void 0:i.Derives_from)||[];if(!o.length&&!l.length&&!c.length){this._emitItem([a]);return}let f;o.forEach(g=>{const d=this._underConstructionById[g];d?(d[d.length-1].type!==a.type&&this._parseError(`multi-line feature "${g}" has inconsistent types: "${a.type}", "${d[d.length-1].type}"`),d.push(a),f=d):(f=[a],this._enforceBufferSizeLimit(1),!l.length&&!c.length&&this._underConstructionTopLevel.push(f),this._underConstructionById[g]=f,this._resolveReferencesTo(f,g))}),this._resolveReferencesFrom(f||[a],{Parent:l,Derives_from:c},o)}_resolveReferencesTo(e,t){const r=this._underConstructionOrphans[t];!r||(e.forEach(i=>{i.child_features.push(...r.Parent)}),e.forEach(i=>{i.derived_features.push(...r.Derives_from)}),delete this._underConstructionOrphans[t])}_parseError(e){this.eof=!0,this.errorCallback(`${this.lineNumber}: ${e}`)}_resolveReferencesFrom(e,t,r){function i(s,a,o){let l=s[a];l||(l={},s[a]=l);const c=l[o]||!1;return l[o]=!0,c}t.Parent.forEach(s=>{const a=this._underConstructionById[s];if(a){const o=Cs.Parent;r.filter(l=>i(this._completedReferences,l,`Parent,${s}`)).length||a.forEach(l=>{l[o].push(e)})}else{let o=this._underConstructionOrphans[s];o||(o={Parent:[],Derives_from:[]},this._underConstructionOrphans[s]=o),o.Parent.push(e)}}),t.Derives_from.forEach(s=>{const a=this._underConstructionById[s];if(a){const o=Cs.Derives_from;r.filter(l=>i(this._completedReferences,l,`Derives_from,${s}`)).length||a.forEach(l=>{l[o].push(e)})}else{let o=this._underConstructionOrphans[s];o||(o={Parent:[],Derives_from:[]},this._underConstructionOrphans[s]=o),o.Derives_from.push(e)}})}}function wi(n){X&&X.nextTick?X.nextTick(n):n()}function ro(n){const e={encoding:"utf8",parseFeatures:!0,parseDirectives:!1,parseSequences:!0,parseComments:!1,bufferSize:1e3,...n};return n.parseAll&&(e.parseFeatures=!0,e.parseDirectives=!0,e.parseComments=!0,e.parseSequences=!0),e}class id extends Ts.Transform{constructor(e={}){super({objectMode:!0}),this.textBuffer="";const t=ro(e);this.encoding=e.encoding||"utf8",this.decoder=new Go;const r=this.push.bind(this);this.parser=new io({featureCallback:t.parseFeatures?r:void 0,directiveCallback:t.parseDirectives?r:void 0,commentCallback:t.parseComments?r:void 0,sequenceCallback:t.parseSequences?r:void 0,errorCallback:i=>this.emit("error",i),bufferSize:t.bufferSize})}_addLine(e){e&&this.parser.addLine(e)}_nextText(e){const t=(this.textBuffer+e).split(/\r?\n/);this.textBuffer=t.pop()||"",t.forEach(r=>this._addLine(r))}_transform(e,t,r){this._nextText(this.decoder.write(e)),wi(r)}_flush(e){this.decoder.end&&this._nextText(this.decoder.end()),this.textBuffer!=null&&this._addLine(this.textBuffer),this.parser.finish(),wi(e)}}function rd(n={}){return new id(n)}function sd(n,e={}){if(!n)return[];const t=ro(e),r=[],i=r.push.bind(r),s=new io({featureCallback:t.parseFeatures?i:void 0,directiveCallback:t.parseDirectives?i:void 0,commentCallback:t.parseComments?i:void 0,sequenceCallback:t.parseSequences?i:void 0,bufferSize:1/0,errorCallback:a=>{throw a}});return n.split(/\r?\n/).forEach(s.addLine.bind(s)),s.finish(),r}function ad(n){const e=[],t=[];n.forEach(i=>{"sequence"in i?t.push(i):e.push(i)});let r=e.map(Bn).join("");return t.length&&(r+=`##FASTA
`,r+=t.map(Li).join("")),r}class so extends Ts.Transform{constructor(e={}){super(Object.assign(e,{objectMode:!0})),this.linesSinceLastSyncMark=0,this.haveWeEmittedData=!1,this.fastaMode=!1,this.minLinesBetweenSyncMarks=e.minSyncLines||100,this.insertVersionDirective=e.insertVersionDirective||!1}_transform(e,t,r){let i;if(!this.haveWeEmittedData&&this.insertVersionDirective){const s=Array.isArray(e)?e[0]:e;"directive"in s&&s.directive!=="gff-version"&&this.push(`##gff-version 3
`)}if("sequence"in e&&!this.fastaMode&&(this.push(`##FASTA
`),this.fastaMode=!0),Array.isArray(e)?i=e.map(Bn).join(""):i=Bn(e),this.push(i),this.linesSinceLastSyncMark>=this.minLinesBetweenSyncMarks)this.push(`###
`),this.linesSinceLastSyncMark=0;else{let s=0;for(let a=0;a<i.length;a+=1)i[a]===`
`&&(s+=1);this.linesSinceLastSyncMark+=s}this.haveWeEmittedData=!0,wi(r)}}function od(n={}){return new so(n)}function cd(n,e,t={}){const r={insertVersionDirective:!0,...t};return new Promise((i,s)=>{n.pipe(new so(r)).on("end",()=>i(null)).on("error",s).pipe(e)})}const Xd={parseStream:rd,parseStringSync:sd,formatSync:ad,formatStream:od,formatFile:cd,util:nd};class fd{constructor(e={}){if(!(e.maxSize&&e.maxSize>0))throw new TypeError("`maxSize` must be a number greater than 0");this.maxSize=e.maxSize,this.cache=new Map,this.oldCache=new Map,this._size=0}_set(e,t){this.cache.set(e,t),this._size++,this._size>=this.maxSize&&(this._size=0,this.oldCache=this.cache,this.cache=new Map)}get(e){if(this.cache.has(e))return this.cache.get(e);if(this.oldCache.has(e)){const t=this.oldCache.get(e);return this.oldCache.delete(e),this._set(e,t),t}}set(e,t){return this.cache.has(e)?this.cache.set(e,t):this._set(e,t),this}has(e){return this.cache.has(e)||this.oldCache.has(e)}peek(e){if(this.cache.has(e))return this.cache.get(e);if(this.oldCache.has(e))return this.oldCache.get(e)}delete(e){const t=this.cache.delete(e);return t&&this._size--,this.oldCache.delete(e)||t}clear(){this.cache.clear(),this.oldCache.clear(),this._size=0}*keys(){for(const[e]of this)yield e}*values(){for(const[,e]of this)yield e}*[Symbol.iterator](){for(const e of this.cache)yield e;for(const e of this.oldCache){const[t]=e;this.cache.has(t)||(yield e)}}get size(){let e=0;for(const t of this.oldCache.keys())this.cache.has(t)||e++;return this._size+e}}var ld=fd;const Bi=ld;async function Ri(n,e,t={}){const{defaultContent:r={}}=t;let i;try{return i=await e(n,{encoding:"utf8"}),JSON.parse(i)}catch(s){if(s.code==="ENOENT"||s.status===404)return r;throw s}}class hd{constructor({readFile:e,cacheSize:t=100}){if(this.topList=[],this.chunkCache=new De({cache:new Bi({maxSize:t}),fill:this.readChunkItems.bind(this)}),this.readFile=e,!this.readFile)throw new Error('must provide a "readFile" function')}importExisting(e,t,r,i,s){this.topList=e,this.attrs=t,this.start=t.makeFastGetter("Start"),this.end=t.makeFastGetter("End"),this.lazyClass=s,this.baseURL=r,this.lazyUrlTemplate=i}binarySearch(e,t,r){let i=-1,s=e.length,a;for(;s-i>1;)a=i+s>>>1,r(e[a])>=t?s=a:i=a;return r===this.end?s:i}readChunkItems(e){const t=X.resolve(this.baseURL,this.lazyUrlTemplate.replace(/\{Chunk\}/gi,e));return Ri(t,this.readFile,{defaultContent:[]})}async*iterateSublist(e,t,r,i,s,a,o){const l=this.attrs.makeGetter("Chunk"),c=this.attrs.makeGetter("Sublist"),f=[];for(let g=this.binarySearch(e,t,s);g<e.length&&g>=0&&i*a(e[g])<i*r;g+=i){if(e[g][0]===this.lazyClass){const h=l(e[g]),p=this.chunkCache.get(h,h).then(b=>[b,h]);f.push(p)}else yield[e[g],o.concat(g)];const d=c(e[g]);d&&(yield*this.iterateSublist(d,t,r,i,s,a,o.concat(g)))}for(let g=0;g<f.length;g+=1){const[d,h]=await f[g];d&&(yield*this.iterateSublist(d,t,r,i,s,a,[...o,h]))}}async*iterate(e,t){const r=e>t?-1:1,i=e>t?this.start:this.end,s=e>t?this.end:this.start;this.topList.length>0&&(yield*this.iterateSublist(this.topList,e,t,r,i,s,[0]))}async histogram(e,t,r){const i=new Array(r);i.fill(0);const s=(t-e)/r;for await(const a of this.iterate(e,t)){const o=Math.max(0,(this.start(a)-e)/s|0),l=Math.min(r,(this.end(a)-e)/s|0);for(let c=o;c<=l;c+=1)i[c]+=1}return i}}class ud{constructor(e){this.classes=e,this.fields=[];for(let t=0;t<e.length;t+=1){this.fields[t]={};for(let r=0;r<e[t].attributes.length;r+=1)this.fields[t][e[t].attributes[r]]=r+1;e[t].proto===void 0&&(e[t].proto={}),e[t].isArrayAttr===void 0&&(e[t].isArrayAttr={})}}attrIndices(e){return this.classes.map(t=>t.attributes.indexOf(e)+1||t.attributes.indexOf(e.toLowerCase())+1||void 0)}get(e,t){if(t in this.fields[e[0]])return e[this.fields[e[0]][t]];const r=t.toLowerCase();if(r in this.fields[e[0]])return e[this.fields[e[0]][r]];const i=this.classes[e[0]].attributes.length+1;return i>=e.length||!(t in e[i])?t in this.classes[e[0]].proto?this.classes[e[0]].proto[t]:void 0:e[i][t]}makeSetter(e){return(t,r)=>{this.set(t,e,r)}}makeGetter(e){return t=>this.get(t,e)}makeFastGetter(e){const t=this.attrIndices(e);return function(i){if(t[i[0]]!==void 0)return i[t[i[0]]]}}accessors(){return this._accessors||(this._accessors=this._makeAccessors()),this._accessors}_makeAccessors(){const e={},t={get(i){const s=this.get.field_accessors[i.toLowerCase()];if(s)return s.call(this)},set(i,s){const a=this.set.field_accessors[i];if(a)return a.call(this,s)},tags(){return r[this[0]]||[]}};t.get.field_accessors={},t.set.field_accessors={},this.classes.forEach((i,s)=>{(i.attributes||[]).forEach((a,o)=>{e[a]=e[a]||[],e[a][s]=o+1,a=a.toLowerCase(),e[a]=e[a]||[],e[a][s]=o+1})});const r=this.classes.map(i=>i.attributes);return Object.keys(e).forEach(i=>{const s=e[i];t.get.field_accessors[i]=s?function(){return this[s[this[0]]]}:function(){}}),t}}const dd=ud;class gd{constructor({urlTemplate:e,chunkSize:t,length:r,cacheSize:i=100,readFile:s},a){if(this.urlTemplate=e,this.chunkSize=t,this.length=r,this.baseUrl=a===void 0?"":a,this.readFile=s,!s)throw new Error("must provide readFile callback");this.chunkCache=new De({cache:new Bi({maxSize:i}),fill:this.getChunk.bind(this)})}index(e,t,r){this.range(e,e,t,void 0,r)}async*range(e,t){e=Math.max(0,e),t=Math.min(t,this.length-1);const r=Math.floor(e/this.chunkSize),i=Math.floor(t/this.chunkSize),s=[];for(let a=r;a<=i;a+=1)s.push(this.chunkCache.get(a,a));for(let a=0;a<s.length;a+=1){const[o,l]=await s[a];yield*this.filterChunkData(e,t,o,l)}}async getChunk(e){let t=this.urlTemplate.replace(/\{Chunk\}/gi,e);this.baseUrl&&(t=X.resolve(this.baseUrl,t));const r=await Ri(t,this.readFile);return[e,r]}*filterChunkData(e,t,r,i){const s=r*this.chunkSize,a=Math.max(0,e-s),o=Math.min(t-s,this.chunkSize-1);for(let l=a;l<=o;l+=1)yield[l+s,i[l]]}}function pd(){return this._uniqueID}function md(){return this._parent}function _d(){return this.get("subfeatures")}class Jd{constructor({baseUrl:e,urlTemplate:t,readFile:r,cacheSize:i=10}){if(this.baseUrl=e,this.urlTemplates={root:t},this.readFile=r,!this.readFile)throw new Error('must provide a "readFile" function argument');this.dataRootCache=new De({cache:new Bi({maxSize:i}),fill:this.fetchDataRoot.bind(this)})}makeNCList(){return new hd({readFile:this.readFile})}loadNCList(e,t,r){e.nclist.importExisting(t.intervals.nclist,e.attrs,r,t.intervals.urlTemplate,t.intervals.lazyClass)}getDataRoot(e){return this.dataRootCache.get(e,e)}fetchDataRoot(e){const t=X.resolve(this.baseUrl,this.urlTemplates.root.replace(/{\s*refseq\s*}/g,e));return Ri(t,this.readFile).then(r=>this.parseTrackInfo(r,t))}parseTrackInfo(e,t){const r={nclist:this.makeNCList(),stats:{featureCount:e.featureCount||0}};e.intervals&&(r.attrs=new dd(e.intervals.classes),this.loadNCList(r,e,t));const{histograms:i}=e;if(i&&i.meta){for(let s=0;s<i.meta.length;s+=1)i.meta[s].lazyArray=new gd({...i.meta[s].arrayParams,readFile:this.readFile},t);r._histograms=i}return r._histograms&&Object.keys(r._histograms).forEach(s=>{r._histograms[s].forEach(o=>{Object.keys(o).forEach(l=>{typeof o[l]=="string"&&String(Number(o[l]))===o[l]&&(o[l]=Number(o[l]))})})}),r}async getRegionStats(e){return(await this.getDataRoot(e.ref)).stats}async getRegionFeatureDensities({refName:e,start:t,end:r,numBins:i,basesPerBin:s}){const a=await this.getDataRoot(e);if(i)s=(r-t)/i;else if(s)i=Math.ceil((r-t)/s);else throw new TypeError("numBins or basesPerBin arg required for getRegionFeatureDensities");const l=(a._histograms.stats||[]).find(d=>d.basesPerBin>=s);let c=a._histograms.meta[0];for(let d=0;d<a._histograms.meta.length;d+=1)s>=a._histograms.meta[d].basesPerBin&&(c=a._histograms.meta[d]);let f=s/c.basesPerBin;if(f>.9&&Math.abs(f-Math.round(f))<1e-4){const d=Math.floor(t/c.basesPerBin);f=Math.round(f);const h=[];for(let p=0;p<i;p+=1)h[p]=0;for await(const[p,b]of c.lazyArray.range(d,d+f*i-1))h[Math.floor((p-d)/f)]+=b;return{bins:h,stats:l}}return{bins:await a.nclist.histogram(t,r,i),stats:l}}async*getFeatures({refName:e,start:t,end:r}){const i=await this.getDataRoot(e),s=i.attrs&&i.attrs.accessors();for await(const[a,o]of i.nclist.iterate(t,r)){if(!a.decorated){const l=o.join(",");this.decorateFeature(s,a,`${e},${l}`)}yield a}}decorateFeature(e,t,r,i){t.get=e.get,t.tags=e.tags,t._uniqueID=r,t.id=pd,t._parent=i,t.parent=md,t.children=_d,(t.get("subfeatures")||[]).forEach((s,a)=>{this.decorateFeature(e,s,`${r}-${a}`,t)}),t.decorated=!0}}const ks=440477507;function zi(n,e){const t=n.prototype[e],r=`_memo_${e}`;n.prototype[e]=function(){return r in this||(this[r]=t.call(this)),this[r]}}const _n=["T","C","A","G"],Pi=[];for(let n=0;n<256;n++)Pi.push(_n[n>>6&3]+_n[n>>4&3]+_n[n>>2&3]+_n[n&3]);const bd=Pi.map(n=>n.toLowerCase());class Di{constructor({filehandle:e,path:t}){if(e)this.filehandle=e;else if(t)this.filehandle=new X(t);else throw new Error("must supply path or filehandle");this.isBigEndian=void 0}async _getParser(e){const t=(await this._getParsers())[e];if(!t)throw new Error(`parser ${e} not found`);return t}async _detectEndianness(){const e=await this.filehandle.read($.Buffer.allocUnsafe(8),0,8,0),{buffer:t}=e;if(t.readInt32LE(0)===ks)this.isBigEndian=!1,this.version=t.readInt32LE(4);else if(t.readInt32BE(0)===ks)this.isBigEndian=!0,this.version=t.readInt32BE(4);else throw new Error("not a 2bit file")}async _getParsers(){await this._detectEndianness();const e=this.isBigEndian?"big":"little",t=this.isBigEndian?"be":"le";let r=new O().endianess(e).uint8("nameLength").string("name",{length:"nameLength"});return this.version===1?r=r.buffer("offsetBytes",{length:8}):r=r.uint32("offset"),{header:new O().endianess(e).int32("magic",{assert:s=>s===440477507}).int32("version",{assert:s=>s===0||s===1}).uint32("sequenceCount",{assert:s=>s>=0}).uint32("reserved"),index:new O().endianess(e).uint32("sequenceCount").uint32("reserved").array("index",{length:"sequenceCount",type:r}),record1:new O().endianess(e).uint32("dnaSize").uint32("nBlockCount"),record2:new O().endianess(e).uint32("nBlockCount").array("nBlockStarts",{length:"nBlockCount",type:`uint32${t}`}).array("nBlockSizes",{length:"nBlockCount",type:`uint32${t}`}).uint32("maskBlockCount"),record3:new O().endianess(e).uint32("maskBlockCount").array("maskBlockStarts",{length:"maskBlockCount",type:`uint32${t}`}).array("maskBlockSizes",{length:"maskBlockCount",type:`uint32${t}`}).int32("reserved")}}async getHeader(){await this._detectEndianness();const{buffer:e}=await this.filehandle.read($.Buffer.allocUnsafe(16),0,16,0);return(await this._getParser("header")).parse(e).result}async getIndex(){const e=await this.getHeader(),t=8+e.sequenceCount*(1+256+(this.version===1?8:4)),{buffer:r}=await this.filehandle.read($.Buffer.allocUnsafe(t),0,t,8),s=(await this._getParser("index")).parse(r).result.index,a={};return this.version===1?s.forEach(({name:o,offsetBytes:l})=>{const c=Ct.fromBytes(l,!0,!this.isBigEndian);if(c.greaterThan(Number.MAX_SAFE_INTEGER))throw new Error("integer overflow. File offset greater than 2^53-1 encountered. This library can only handle offsets up to 2^53-1.");a[o]=c.toNumber()}):s.forEach(({name:o,offset:l})=>{a[o]=l}),a}async getSequenceNames(){const e=await this.getIndex();return Object.keys(e)}async getSequenceSizes(){const e=await this.getIndex(),t=Object.keys(e),r=Object.values(e).map(a=>this._getSequenceSize(a)),i=await Promise.all(r),s={};for(let a=0;a<t.length;a+=1)s[t[a]]=i[a];return s}async getSequenceSize(e){const r=(await this.getIndex())[e];if(!!r)return this._getSequenceSize(r)}async _getSequenceSize(e){if(e===void 0||e<0)throw new Error("invalid offset");return(await this._parseItem(e,8,"record1")).dnaSize}async _getSequenceRecord(e){if(e===void 0||e<0)throw new Error("invalid offset");const t=await this._parseItem(e,8,"record1"),r=t.nBlockCount*8+8,i=await this._parseItem(e+4,r,"record2"),s=i.maskBlockCount*8+8,a=await this._parseItem(e+4+r-4,s,"record3");return{dnaSize:t.dnaSize,nBlocks:{starts:i.nBlockStarts,sizes:i.nBlockSizes},maskBlocks:{starts:a.maskBlockStarts,sizes:a.maskBlockSizes},dnaPosition:e+4+r-4+s}}async _parseItem(e,t,r){const{buffer:i}=await this.filehandle.read($.Buffer.allocUnsafe(t),0,t,e);return(await this._getParser(r)).parse(i).result}async getSequence(e,t=0,r){const s=(await this.getIndex())[e];if(!s)return;const a=await this._getSequenceRecord(s);if(t<0)throw new TypeError("regionStart cannot be less than 0");(r===void 0||r>a.dnaSize)&&(r=a.dnaSize);const o=this._getOverlappingBlocks(t,r,a.nBlocks.starts,a.nBlocks.sizes),l=this._getOverlappingBlocks(t,r,a.maskBlocks.starts,a.maskBlocks.sizes),c=$.Buffer.allocUnsafe(Math.ceil((r-t)/4)+1),f=Math.floor(t/4),{buffer:g}=await this.filehandle.read(c,0,c.length,a.dnaPosition+f);let d="";for(let h=t;h<r;h+=1){for(;l.length&&l[0].end<=h;)l.shift();const p=l[0]&&l[0].start<=h&&l[0].end>h;if(o[0]&&h>=o[0].start&&h<o[0].end){const b=o.shift();for(;h<b.end&&h<r;h+=1)d+=p?"n":"N";h-=1}else{const b=Math.floor(h/4)-f,w=h%4,S=g[b];d+=p?bd[S][w]:Pi[S][w]}}return d}_getOverlappingBlocks(e,t,r,i){let s,a;for(let l=0;l<r.length;l+=1){const c=r[l],f=i[l];if(e>=c+f||t<=c){if(s!==void 0){a=l;break}}else s===void 0&&(s=l)}if(s===void 0)return[];a===void 0&&(a=r.length);const o=new Array(a-s);for(let l=s;l<a;l+=1)o[l-s]={start:r[l],end:r[l]+i[l],size:i[l]};return o}}zi(Di,"_getParsers");zi(Di,"getIndex");zi(Di,"getHeader");function vs(n,e){return n.offset+n.lineBytes*Math.floor(e/n.lineLength)+e%n.lineLength}async function wd(n,e){const t=await n.readFile(e);if(!(t&&t.length))throw new Error("No data read from FASTA index (FAI) file");let r=0,i;const s=t.toString("utf8").split(/\r?\n/).filter(a=>/\S/.test(a)).map(a=>a.split("	")).filter(a=>a[0]!=="").map(a=>((!i||i.name!==a[0])&&(i={name:a[0],id:r},r+=1),{id:i.id,name:a[0],length:+a[1],start:0,end:+a[1],offset:+a[2],lineLength:+a[3],lineBytes:+a[4]}));return{name:Object.fromEntries(s.map(a=>[a.name,a])),id:Object.fromEntries(s.map(a=>[a.id,a]))}}class yd{constructor({fasta:e,fai:t,path:r,faiPath:i,chunkSizeLimit:s=1e6}){if(e)this.fasta=e;else if(r)this.fasta=new X(r);else throw new Error("Need to pass filehandle for fasta or path to localfile");if(t)this.fai=t;else if(i)this.fai=new X(i);else if(r)this.fai=new X(`${r}.fai`);else throw new Error("Need to pass filehandle for  or path to localfile");this.chunkSizeLimit=s}async _getIndexes(e){return this.indexes||(this.indexes=wd(this.fai,e)),this.indexes}async getSequenceNames(e){return Object.keys((await this._getIndexes(e)).name)}async getSequenceSizes(e){const t={},r=await this._getIndexes(e),i=Object.values(r.id);for(let s=0;s<i.length;s+=1)t[i[s].name]=i[s].length;return t}async getSequenceSize(e,t){var r;return(r=(await this._getIndexes(t)).name[e])===null||r===void 0?void 0:r.length}async hasReferenceSequence(e,t){return!!(await this._getIndexes(t)).name[e]}async getResiduesById(e,t,r,i){const s=(await this._getIndexes(i)).id[e];if(!!s)return this._fetchFromIndexEntry(s,t,r,i)}async getResiduesByName(e,t,r,i){const s=(await this._getIndexes(i)).name[e];if(!!s)return this._fetchFromIndexEntry(s,t,r,i)}async getSequence(e,t,r,i){return this.getResiduesByName(e,t,r,i)}async _fetchFromIndexEntry(e,t=0,r,i){let s=r;if(t<0)throw new TypeError("regionStart cannot be less than 0");if((s===void 0||s>e.length)&&(s=e.length),t>=s)return"";const a=vs(e,t),o=vs(e,s)-a;if(o>this.chunkSizeLimit)throw new Error(`data size of ${o.toLocaleString()} bytes exceeded chunk size limit of ${this.chunkSizeLimit.toLocaleString()} bytes`);const l=$.Buffer.allocUnsafe(o);return await this.fasta.read(l,0,o,a,i),l.toString("utf8").replace(/\s+/g,"")}}class eg extends yd{constructor({fasta:e,path:t,fai:r,faiPath:i,gzi:s,gziPath:a,chunkSizeLimit:o}){super({fasta:e,path:t,fai:r,faiPath:i,chunkSizeLimit:o}),e&&s?this.fasta=new Ir({filehandle:e,gziFilehandle:s}):t&&a&&(this.fasta=new Ir({path:t,gziPath:a}))}}export{Cf as B,Ud as C,Hd as H,qd as I,X as L,Jd as N,Od as T,Md as V,Dd as _,jd as a,Kd as b,Wd as c,Qd as d,Di as e,yd as f,Xd as g,eg as h,Yd as i,$d as p,Je as u};
