import{c as i}from"./@babel.d3038ccc.js";import{c as w}from"./abortcontroller-polyfill.e0408538.js";var p={},b={},s={};Object.defineProperty(s,"__esModule",{value:!0});s.AbortSignal=s.AbortController=void 0;const A=w;var d=function(){if(typeof self<"u")return self;if(typeof window<"u")return window;if(typeof i<"u")return i;throw new Error("unable to locate global object")};let y=typeof d().AbortController>"u"?A.AbortController:d().AbortController;s.AbortController=y;let v=typeof d().AbortController>"u"?A.AbortSignal:d().AbortSignal;s.AbortSignal=v;var h={};Object.defineProperty(h,"__esModule",{value:!0});const m=s;class E{}class C{constructor(){this.signals=new Set,this.abortController=new m.AbortController}addSignal(e=new E){if(this.signal.aborted)throw new Error("cannot add a signal, already aborted!");this.signals.add(e),e.aborted?this.handleAborted(e):typeof e.addEventListener=="function"&&e.addEventListener("abort",()=>{this.handleAborted(e)})}handleAborted(e){this.signals.delete(e),this.signals.size===0&&this.abortController.abort()}get signal(){return this.abortController.signal}abort(){this.abortController.abort()}}h.default=C;var g={};Object.defineProperty(g,"__esModule",{value:!0});class S{constructor(){this.callbacks=new Set}addCallback(e=()=>{}){this.callbacks.add(e),e(this.currentMessage)}callback(e){this.currentMessage=e,this.callbacks.forEach(t=>{t(e)})}}g.default=S;var _=i&&i.__importDefault||function(o){return o&&o.__esModule?o:{default:o}};Object.defineProperty(b,"__esModule",{value:!0});const j=s,P=_(h),R=_(g);class f{constructor({fill:e,cache:t}){if(typeof e!="function")throw new TypeError("must pass a fill function");if(typeof t!="object")throw new TypeError("must pass a cache object");if(typeof t.get!="function"||typeof t.set!="function"||typeof t.delete!="function")throw new TypeError("cache must implement get(key), set(key, val), and and delete(key)");this.cache=t,this.fillCallback=e}static isAbortException(e){return e.name==="AbortError"||e.code==="ERR_ABORTED"||e.message==="AbortError: aborted"||e.message==="Error: aborted"}evict(e,t){this.cache.get(e)===t&&this.cache.delete(e)}fill(e,t,r,l){const a=new P.default,u=new R.default;u.addCallback(l);const n={aborter:a,promise:this.fillCallback(t,a.signal,c=>{u.callback(c)}),settled:!1,statusReporter:u,get aborted(){return this.aborter.signal.aborted}};n.aborter.addSignal(r),n.aborter.signal.addEventListener("abort",()=>{n.settled||this.evict(e,n)}),n.promise.then(()=>{n.settled=!0},()=>{n.settled=!0,this.evict(e,n)}).catch(c=>{throw console.error(c),c}),this.cache.set(e,n)}static checkSinglePromise(e,t){function r(){if(t&&t.aborted)throw Object.assign(new Error("aborted"),{code:"ERR_ABORTED"})}return e.then(l=>(r(),l),l=>{throw r(),l})}has(e){return this.cache.has(e)}get(e,t,r,l){if(!r&&t instanceof j.AbortSignal)throw new TypeError("second get argument appears to be an AbortSignal, perhaps you meant to pass `null` for the fill data?");const a=this.cache.get(e);return a?a.aborted&&!a.settled?(this.evict(e,a),this.get(e,t,r,l)):a.settled?a.promise:(a.aborter.addSignal(r),a.statusReporter.addCallback(l),f.checkSinglePromise(a.promise,r)):(this.fill(e,t,r,l),f.checkSinglePromise(this.cache.get(e).promise,r))}delete(e){const t=this.cache.get(e);t&&(t.settled||t.aborter.abort(),this.cache.delete(e))}clear(){const e=this.cache.keys();let t=0;for(let r=e.next();!r.done;r=e.next())this.delete(r.value),t+=1;return t}}b.default=f;var M=i&&i.__importDefault||function(o){return o&&o.__esModule?o:{default:o}};Object.defineProperty(p,"__esModule",{value:!0});const k=M(b);var T=p.default=k.default;export{T as _,p as e};
